{"ERC20.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://eips.ethereum.org/EIPS/eip-20\n * Originally based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n *\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n * all accounts just by listening to said events. Note that this isn\u0027t required by the specification, and other\n * compliant implementations may not do it.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address =\u003e uint256) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev Total number of tokens in existence\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner The address to query the balance of.\n     * @return A uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n     * @dev Transfer token to a specified address\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender\u0027s allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _transfer(from, to, value);\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Transfer token for a specified addresses\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Approve an address to spend another addresses\u0027 tokens.\n     * @param owner The address that owns the tokens.\n     * @param spender The address that will spend the tokens.\n     * @param value The number of tokens that can be spent.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(spender != address(0));\n        require(owner != address(0));\n\n        _allowed[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender\u0027s allowance for said account. Uses the\n     * internal burn function.\n     * Emits an Approval event (reflecting the reduced allowance).\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burnFrom(address account, uint256 value) internal {\n        _burn(account, value);\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n    }\n}\n"},"ERC20Burnable.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./ERC20.sol\";\n\n/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n */\ncontract ERC20Burnable is ERC20 {\n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param value The amount of token to be burned.\n     */\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\n\n    /**\n     * @dev Burns a specific amount of tokens from the target address and decrements allowance\n     * @param from address The account whose tokens will be burned.\n     * @param value uint256 The amount of token to be burned.\n     */\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\n}\n"},"ERC20Capped.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./ERC20Mintable.sol\";\n\n/**\n * @title Capped token\n * @dev Mintable token with a token cap.\n */\ncontract ERC20Capped is ERC20Mintable {\n    uint256 private _cap;\n\n    constructor (uint256 cap) public {\n        require(cap \u003e 0);\n        _cap = cap;\n    }\n\n    /**\n     * @return the cap for the token minting.\n     */\n    function cap() public view returns (uint256) {\n        return _cap;\n    }\n\n    function _mint(address account, uint256 value) internal {\n        require(totalSupply().add(value) \u003c= _cap);\n        super._mint(account, value);\n    }\n}\n"},"ERC20Detailed.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./IERC20.sol\";\n\n/**\n * @title ERC20Detailed token\n * @dev The decimals are only for visualization purposes.\n * All the operations are done using the smallest and indivisible token unit,\n * just as on Ethereum all the operations are done in wei.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @return the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @return the symbol of the token.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @return the number of decimals of the token.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"},"ERC20Mintable.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./ERC20.sol\";\nimport \"./MinterRole.sol\";\n\n/**\n * @title ERC20Mintable\n * @dev ERC20 minting logic\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev Function to mint tokens\n     * @param to The address that will receive the minted tokens.\n     * @param value The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address to, uint256 value) public onlyMinter returns (bool) {\n        _mint(to, value);\n        return true;\n    }\n}\n"},"IERC20.sol":{"content":"pragma solidity ^0.5.2;\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"MinterRole.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./Roles.sol\";\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender));\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n"},"Roles.sol":{"content":"pragma solidity ^0.5.2;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address =\u003e bool) bearer;\n    }\n\n    /**\n     * @dev give an account access to this role\n     */\n    function add(Role storage role, address account) internal {\n        require(account != address(0));\n        require(!has(role, account));\n\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev remove an account\u0027s access to this role\n     */\n    function remove(Role storage role, address account) internal {\n        require(account != address(0));\n        require(has(role, account));\n\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev check if an account has this role\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0));\n        return role.bearer[account];\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.2;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n"},"SFtoken.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\r\n\r\nimport \"./ERC20.sol\";\r\nimport \"./ERC20Detailed.sol\";\r\nimport \"./ERC20Capped.sol\";\r\nimport \"./ERC20Burnable.sol\";\r\n\r\ncontract SFtoken is ERC20, ERC20Detailed, ERC20Burnable {\r\n\r\n    event CreateTokenSuccess(address owner, uint256 balance);\r\n\r\n    uint256 amount = 2100000000;\r\n    constructor(\r\n    )\r\n    ERC20Burnable()\r\n    ERC20Detailed(\"ERM\", \"ERM\", 18)\r\n    ERC20()\r\n    public\r\n    {\r\n        _mint(msg.sender, amount * (10 ** 18));\r\n        emit CreateTokenSuccess(msg.sender, balanceOf(msg.sender));\r\n    }\r\n}\r\n"},"SuperFair.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\r\n\r\nimport \"./SFtoken.sol\";\r\n\r\ncontract UtilFairWin {\r\n    uint ethWei = 1 ether;\r\n\r\n    function getLevel(uint value) public view returns(uint) {\r\n        if (value \u003e= 1*ethWei \u0026\u0026 value \u003c= 5*ethWei) {\r\n            return 1;\r\n        }\r\n        if (value \u003e= 6*ethWei \u0026\u0026 value \u003c= 10*ethWei) {\r\n            return 2;\r\n        }\r\n        if (value \u003e= 11*ethWei \u0026\u0026 value \u003c= 15*ethWei) {\r\n            return 3;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getLineLevel(uint value) public view returns(uint) {\r\n        if (value \u003e= 1*ethWei \u0026\u0026 value \u003c= 5*ethWei) {\r\n            return 1;\r\n        }\r\n        if (value \u003e= 6*ethWei \u0026\u0026 value \u003c= 10*ethWei) {\r\n            return 2;\r\n        }\r\n        if (value \u003e= 11*ethWei) {\r\n            return 3;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getScByLevel(uint level) public pure returns(uint) {\r\n        if (level == 1) {\r\n            return 5;\r\n        }\r\n        if (level == 2) {\r\n            return 7;\r\n        }\r\n        if (level == 3) {\r\n            return 10;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getFireScByLevel(uint level) public pure returns(uint) {\r\n        if (level == 1) {\r\n            return 3;\r\n        }\r\n        if (level == 2) {\r\n            return 6;\r\n        }\r\n        if (level == 3) {\r\n            return 10;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getRecommendScaleByLevelAndTim(uint level,uint times) public pure returns(uint){\r\n        if (level == 1 \u0026\u0026 times == 1) {\r\n            return 50;\r\n        }\r\n        if (level == 2 \u0026\u0026 times == 1) {\r\n            return 70;\r\n        }\r\n        if (level == 2 \u0026\u0026 times == 2) {\r\n            return 50;\r\n        }\r\n        if (level == 3) {\r\n            if(times == 1){\r\n                return 100;\r\n            }\r\n            if (times == 2) {\r\n                return 70;\r\n            }\r\n            if (times == 3) {\r\n                return 50;\r\n            }\r\n            if (times \u003e= 4 \u0026\u0026 times \u003c= 10) {\r\n                return 10;\r\n            }\r\n            if (times \u003e= 11 \u0026\u0026 times \u003c= 20) {\r\n                return 5;\r\n            }\r\n            if (times \u003e= 21) {\r\n                return 1;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function compareStr(string memory _str, string memory str) public pure returns(bool) {\r\n        if (keccak256(abi.encodePacked(_str)) == keccak256(abi.encodePacked(str))) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor() internal {}\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\ncontract WhitelistAdminRole is Context, Ownable {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistAdminAdded(address indexed account);\r\n    event WhitelistAdminRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelistAdmins;\r\n\r\n    constructor () internal {\r\n        _addWhitelistAdmin(_msgSender());\r\n    }\r\n\r\n    modifier onlyWhitelistAdmin() {\r\n        require(isWhitelistAdmin(_msgSender()) || isOwner(), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelistAdmin(address account) public view returns (bool) {\r\n        return _whitelistAdmins.has(account);\r\n    }\r\n\r\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\r\n        _addWhitelistAdmin(account);\r\n    }\r\n\r\n    function removeWhitelistAdmin(address account) public onlyOwner {\r\n        _whitelistAdmins.remove(account);\r\n        emit WhitelistAdminRemoved(account);\r\n    }\r\n\r\n    function renounceWhitelistAdmin() public {\r\n        _removeWhitelistAdmin(_msgSender());\r\n    }\r\n\r\n    function _addWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.add(account);\r\n        emit WhitelistAdminAdded(account);\r\n    }\r\n\r\n    function _removeWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.remove(account);\r\n        emit WhitelistAdminRemoved(account);\r\n    }\r\n}\r\n\r\ncontract SuperFair is UtilFairWin, WhitelistAdminRole {\r\n\r\n    using SafeMath for *;\r\n\r\n    string constant private name = \"SuperFair Official\";\r\n\r\n    uint ethWei = 1 ether;\r\n\r\n    struct User{\r\n        uint id;\r\n        address userAddress;\r\n        string inviteCode;\r\n        string referrer;\r\n        uint staticLevel;\r\n        uint dynamicLevel;\r\n        uint allInvest;\r\n        uint freezeAmount;\r\n        uint unlockAmount;\r\n        uint allStaticAmount;\r\n        uint allDynamicAmount;\r\n        uint hisStaticAmount;\r\n        uint hisDynamicAmount;\r\n        Invest[] invests;\r\n        uint staticFlag;\r\n    }\r\n\r\n    struct UserGlobal {\r\n        uint id;\r\n        address userAddress;\r\n        string inviteCode;\r\n        string referrer;\r\n    }\r\n\r\n    struct Invest{\r\n        address userAddress;\r\n        uint investAmount;\r\n        uint investTime;\r\n        uint times;\r\n        uint day;\r\n    }\r\n\r\n    struct Order {\r\n        address user;\r\n        uint256 amount;\r\n        string inviteCode;\r\n        string referrer;\r\n        bool execute;\r\n    }\r\n\r\n    struct WaitInfo {\r\n        uint256 totalAmount;\r\n        bool isWait;\r\n        uint256 time;\r\n        uint256[] seq;\r\n    }\r\n\r\n    string constant systemCode = \"99999999\";\r\n    uint coefficient = 10;\r\n    uint profit = 1;\r\n    uint startTime;\r\n    uint investCount = 0;\r\n    mapping(uint =\u003e uint) rInvestCount;\r\n    uint investMoney = 0;\r\n    mapping(uint =\u003e uint) rInvestMoney;\r\n    uint uid = 0;\r\n    uint rid = 1;\r\n    uint period = 3 days;\r\n    mapping (uint =\u003e mapping(address =\u003e User)) userRoundMapping;\r\n    mapping(address =\u003e UserGlobal) userMapping;\r\n    mapping (string =\u003e address) addressMapping;\r\n    mapping (string =\u003e address) codeRegister;\r\n    mapping (uint =\u003e address) public indexMapping;\r\n    mapping (uint =\u003e mapping(uint256 =\u003e Order)) public waitOrder;\r\n    mapping (uint =\u003e mapping(address =\u003e WaitInfo)) public waitInfo;\r\n    uint32  public ratio = 1000;     // eth to erc20 token ratio\r\n    mapping (uint =\u003e mapping(address =\u003e uint256[2])) public extraInfo;\r\n\r\n    address payable public eggAddress = 0x9ddc752e3D59Cd16e4360743C6eB9608d39e6119;\r\n    address payable public fivePercentWallet = 0x76594F0FA263Ac33aa28E3AdbFebBcBaf7Db76A9;\r\n    address payable public twoPercentWallet =  0x4200DBbda245be2b04a0a82eB1e08C6580D81C9b;\r\n    address payable public threePercentWallet = 0x07BeEec61D7B28177521bFDd0fdA5A07d992e51F;\r\n\r\n    SFtoken internal SFInstance;\r\n\r\n    bool public waitLine = true;\r\n    uint256 public numOrder = 1;\r\n    uint256 public startNum = 1;\r\n\r\n    modifier isHuman() {\r\n        address addr = msg.sender;\r\n        uint codeLength;\r\n\r\n        assembly {codeLength := extcodesize(addr)}\r\n        require(codeLength == 0, \"sorry humans only\");\r\n        require(tx.origin == msg.sender, \"sorry, human only\");\r\n        _;\r\n    }\r\n\r\n    event LogInvestIn(address indexed who, uint indexed uid, uint amount, uint time, string inviteCode, string referrer);\r\n    event LogWithdrawProfit(address indexed who, uint indexed uid, uint amount, uint time);\r\n    event LogRedeem(address indexed who, uint indexed uid, uint amount, uint now);\r\n\r\n    constructor (address _erc20Address) public {\r\n        SFInstance = SFtoken(_erc20Address);\r\n    }\r\n\r\n\r\n    function () external payable {\r\n    }\r\n\r\n    function calculateToken(address user, uint256 ethAmount)\r\n    internal\r\n    {\r\n        SFInstance.transfer(user, ethAmount.mul(ratio));\r\n    }\r\n\r\n\r\n    function activeGame(uint time) external onlyWhitelistAdmin\r\n    {\r\n        require(time \u003e now, \"invalid game start time\");\r\n        startTime = time;\r\n    }\r\n\r\n    function modifyProfit(uint p) external onlyWhitelistAdmin\r\n    {\r\n        profit = p;\r\n    }\r\n\r\n\r\n    function setCoefficient(uint coeff) external onlyWhitelistAdmin\r\n    {\r\n        require(coeff \u003e 0, \"invalid coeff\");\r\n        coefficient = coeff;\r\n    }\r\n\r\n    function setRatio(uint32 r) external onlyWhitelistAdmin\r\n    {\r\n        ratio = r;\r\n    }\r\n\r\n    function setWaitLine (bool wait) external onlyWhitelistAdmin\r\n    {\r\n        waitLine = wait;\r\n    }\r\n\r\n    function modifyStartNum(uint256 number) external onlyWhitelistAdmin\r\n    {\r\n        startNum = number;\r\n    }\r\n\r\n    function executeLine(uint256 end) external onlyWhitelistAdmin\r\n    {\r\n        require(waitLine, \"need wait line\");\r\n        for(uint256 i = startNum; i \u003c startNum + end; i++) {\r\n            require(waitOrder[rid][i].user != address(0), \"user address can not be 0X\");\r\n            investIn(waitOrder[rid][i].user, waitOrder[rid][i].amount, waitOrder[rid][i].inviteCode, waitOrder[rid][i].referrer);\r\n            waitOrder[rid][i].execute = true;\r\n            waitInfo[rid][waitOrder[rid][i].user].isWait = false;\r\n        }\r\n        startNum += end;\r\n    }\r\n\r\n    function gameStart() public view returns(bool) {\r\n        return startTime != 0 \u0026\u0026 now \u003e startTime;\r\n    }\r\n\r\n    function waitInvest(string memory inviteCode, string memory referrer)\r\n    public\r\n    isHuman()\r\n    payable\r\n    {\r\n        require(gameStart(), \"game not start\");\r\n        require(msg.value \u003e= 1*ethWei \u0026\u0026 msg.value \u003c= 15*ethWei, \"between 1 and 15\");\r\n        require(msg.value == msg.value.div(ethWei).mul(ethWei), \"invalid msg value\");\r\n        require(codeRegister[inviteCode] == address(0) || codeRegister[inviteCode] == msg.sender, \"can not repeat invite\");\r\n\r\n        UserGlobal storage userGlobal = userMapping[msg.sender];\r\n        if (userGlobal.id == 0) {\r\n            require(!compareStr(inviteCode, \"\"), \"empty invite code\");\r\n            address referrerAddr = getUserAddressByCode(referrer);\r\n            require(uint(referrerAddr) != 0, \"referer not exist\");\r\n            require(referrerAddr != msg.sender, \"referrer can\u0027t be self\");\r\n            require(!isUsed(inviteCode), \"invite code is used\");\r\n        }\r\n\r\n        Order storage order = waitOrder[rid][numOrder];\r\n        order.user = msg.sender;\r\n        order.amount = msg.value;\r\n        order.inviteCode = inviteCode;\r\n        order.referrer = referrer;\r\n\r\n        WaitInfo storage info = waitInfo[rid][msg.sender];\r\n        info.totalAmount += msg.value;\r\n        require(info.totalAmount \u003c= 15 ether, \"eth amount between 1 and 15\");\r\n        info.isWait = true;\r\n        info.seq.push(numOrder);\r\n        info.time = now;\r\n\r\n        codeRegister[inviteCode] = msg.sender;\r\n\r\n        if(!waitLine){\r\n            if(numOrder!=1){\r\n                require(waitOrder[rid][numOrder - 1].execute, \"last order not execute\");\r\n            }\r\n            investIn(order.user, order.amount, order.inviteCode, order.referrer);\r\n            order.execute = true;\r\n            info.isWait = false;\r\n            startNum += 1;\r\n        }\r\n\r\n        numOrder += 1;\r\n    }\r\n\r\n    function investIn(address usera, uint256 amount, string memory inviteCode, string memory referrer)\r\n    private\r\n    {\r\n        UserGlobal storage userGlobal = userMapping[usera];\r\n        if (userGlobal.id == 0) {\r\n            require(!compareStr(inviteCode, \"\"), \"empty invite code\");\r\n            address referrerAddr = getUserAddressByCode(referrer);\r\n            extraInfo[rid][referrerAddr][1] += 1;\r\n            require(uint(referrerAddr) != 0, \"referer not exist\");\r\n            require(referrerAddr != usera, \"referrer can\u0027t be self\");\r\n\r\n            require(!isUsed(inviteCode), \"invite code is used\");\r\n\r\n            registerUser(usera, inviteCode, referrer);\r\n        }\r\n\r\n        User storage user = userRoundMapping[rid][usera];\r\n        if (uint(user.userAddress) != 0) {\r\n            require(user.freezeAmount.add(amount) \u003c= 15*ethWei, \"can not beyond 15 eth\");\r\n            user.allInvest = user.allInvest.add(amount);\r\n            user.freezeAmount = user.freezeAmount.add(amount);\r\n            user.staticLevel = getLevel(user.freezeAmount);\r\n            user.dynamicLevel = getLineLevel(user.freezeAmount.add(user.unlockAmount));\r\n        } else {\r\n            user.id = userGlobal.id;\r\n            user.userAddress = usera;\r\n            user.freezeAmount = amount;\r\n            user.staticLevel = getLevel(amount);\r\n            user.allInvest = amount;\r\n            user.dynamicLevel = getLineLevel(amount);\r\n            user.inviteCode = userGlobal.inviteCode;\r\n            user.referrer = userGlobal.referrer;\r\n        }\r\n\r\n        Invest memory invest = Invest(usera, amount, now, 0, 0);\r\n        user.invests.push(invest);\r\n\r\n        investCount = investCount.add(1);\r\n        investMoney = investMoney.add(amount);\r\n        rInvestCount[rid] = rInvestCount[rid].add(1);\r\n        rInvestMoney[rid] = rInvestMoney[rid].add(amount);\r\n\r\n        calculateToken(usera, amount);\r\n\r\n        sendMoneyToUser(fivePercentWallet, amount.mul(5).div(100));\r\n        sendMoneyToUser(twoPercentWallet, amount.mul(2).div(100));\r\n        sendMoneyToUser(threePercentWallet, amount.mul(3).div(100));\r\n\r\n    emit LogInvestIn(usera, userGlobal.id, amount, now, userGlobal.inviteCode, userGlobal.referrer);\r\n    }\r\n\r\n    function withdrawProfit()\r\n    public\r\n    isHuman()\r\n    {\r\n        require(gameStart(), \"game not start\");\r\n        User storage user = userRoundMapping[rid][msg.sender];\r\n        uint sendMoney = user.allStaticAmount.add(user.allDynamicAmount);\r\n\r\n        bool isEnough = false;\r\n        uint resultMoney = 0;\r\n        (isEnough, resultMoney) = isEnoughBalance(sendMoney);\r\n        if (!isEnough) {\r\n            endRound();\r\n        }\r\n\r\n        uint256[2] storage extra = extraInfo[rid][msg.sender];\r\n        extra[0] += resultMoney;\r\n        if(extra[0] \u003e= waitInfo[rid][msg.sender].totalAmount) {\r\n            resultMoney = waitInfo[rid][msg.sender].totalAmount - (extra[0] - resultMoney);\r\n        }\r\n\r\n        if (resultMoney \u003e 0) {\r\n            sendMoneyToUser(eggAddress, resultMoney.mul(10).div(100));\r\n            sendMoneyToUser(msg.sender, resultMoney.mul(90).div(100));\r\n            user.allStaticAmount = 0;\r\n            user.allDynamicAmount = 0;\r\n            emit LogWithdrawProfit(msg.sender, user.id, resultMoney, now);\r\n        }\r\n\r\n    }\r\n\r\n    function isEnoughBalance(uint sendMoney) private view returns (bool, uint){\r\n        if (sendMoney \u003e= address(this).balance) {\r\n            return (false, address(this).balance);\r\n        } else {\r\n            return (true, sendMoney);\r\n        }\r\n    }\r\n\r\n    function sendMoneyToUser(address payable userAddress, uint money) private {\r\n        userAddress.transfer(money);\r\n    }\r\n\r\n    function calStaticProfit(address userAddr) external onlyWhitelistAdmin returns(uint)\r\n    {\r\n        return calStaticProfitInner(userAddr);\r\n    }\r\n\r\n    function calStaticProfitInner(address userAddr) private returns(uint)\r\n    {\r\n        User storage user = userRoundMapping[rid][userAddr];\r\n        if (user.id == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint scale = getScByLevel(user.staticLevel);\r\n        uint allStatic = 0;\r\n        for (uint i = user.staticFlag; i \u003c user.invests.length; i++) {\r\n            Invest storage invest = user.invests[i];\r\n            uint startDay = invest.investTime.sub(8 hours).div(1 days).mul(1 days);\r\n            uint staticGaps = now.sub(8 hours).sub(startDay).div(1 days);\r\n\r\n             uint unlockDay = now.sub(invest.investTime).div(1 days);\r\n            if (unlockDay\u003e100) {\r\n                unlockDay = 100;\r\n            }\r\n\r\n            if(staticGaps \u003e 5){\r\n                staticGaps = 5;\r\n             }\r\n            if (staticGaps \u003e invest.times) {\r\n                allStatic += staticGaps.sub(invest.times).mul(scale).mul(invest.investAmount).div(1000);\r\n                invest.times = staticGaps;\r\n            }\r\n\r\n           uint256[2] storage extra = extraInfo[rid][userAddr];\r\n\r\n           if(extra[0] \u003e= waitInfo[rid][userAddr].totalAmount) {\r\n               user.staticFlag++;\r\n               user.freezeAmount = 0;\r\n               user.unlockAmount = waitInfo[rid][userAddr].totalAmount;\r\n               user.staticLevel = getLevel(user.freezeAmount);\r\n            } else {\r\n               user.freezeAmount = user.freezeAmount.sub(invest.investAmount.div(100).mul(unlockDay).mul(profit));\r\n               user.unlockAmount = user.unlockAmount.add(invest.investAmount.div(100).mul(unlockDay).mul(profit));\r\n           }\r\n              invest.day = unlockDay;\r\n\r\n        }\r\n        allStatic = allStatic.mul(coefficient).div(10);\r\n        user.allStaticAmount = user.allStaticAmount.add(allStatic);\r\n        user.hisStaticAmount = user.hisStaticAmount.add(allStatic);\r\n        userRoundMapping[rid][userAddr] = user;\r\n        return user.allStaticAmount;\r\n    }\r\n\r\n    function calDynamicProfit(uint start, uint end) external onlyWhitelistAdmin {\r\n        for (uint i = start; i \u003c= end; i++) {\r\n            address userAddr = indexMapping[i];\r\n            User memory user = userRoundMapping[rid][userAddr];\r\n            if(user.allInvest \u003e 0) {\r\n                calStaticProfitInner(userAddr);\r\n            }\r\n            if (user.freezeAmount \u003e= 1*ethWei) {\r\n                uint scale = getScByLevel(user.staticLevel);\r\n                calUserDynamicProfit(user.referrer, user.freezeAmount, scale);\r\n            }\r\n        }\r\n    }\r\n\r\n    function registerUserInfo(address user, string calldata inviteCode, string calldata referrer) external onlyOwner {\r\n        registerUser(user, inviteCode, referrer);\r\n    }\r\n\r\n    function calUserDynamicProfit(string memory referrer, uint money, uint shareSc) private {\r\n        string memory tmpReferrer = referrer;\r\n\r\n        for (uint i = 1; i \u003c= 30; i++) {\r\n            if (compareStr(tmpReferrer, \"\")) {\r\n                break;\r\n            }\r\n            address tmpUserAddr = addressMapping[tmpReferrer];\r\n            User storage calUser = userRoundMapping[rid][tmpUserAddr];\r\n\r\n            uint fireSc = getFireScByLevel(calUser.staticLevel);\r\n            uint recommendSc = getRecommendScaleByLevelAndTim(calUser.dynamicLevel, i);\r\n            uint moneyResult = 0;\r\n            if (money \u003c= calUser.freezeAmount.add(calUser.unlockAmount)) {\r\n                moneyResult = money;\r\n            } else {\r\n                moneyResult = calUser.freezeAmount.add(calUser.unlockAmount);\r\n            }\r\n\r\n            if (recommendSc != 0) {\r\n                uint tmpDynamicAmount = moneyResult.mul(shareSc).mul(fireSc).mul(recommendSc);\r\n                tmpDynamicAmount = tmpDynamicAmount.div(1000).div(10).div(100);\r\n\r\n                tmpDynamicAmount = tmpDynamicAmount.mul(coefficient).div(10);\r\n                calUser.allDynamicAmount = calUser.allDynamicAmount.add(tmpDynamicAmount);\r\n                calUser.hisDynamicAmount = calUser.hisDynamicAmount.add(tmpDynamicAmount);\r\n            }\r\n\r\n            tmpReferrer = calUser.referrer;\r\n        }\r\n    }\r\n\r\n    function redeem()\r\n    public\r\n    isHuman()\r\n    {\r\n        withdrawProfit();\r\n        require(gameStart(), \"game not start\");\r\n        User storage user = userRoundMapping[rid][msg.sender];\r\n        require(user.id \u003e 0, \"user not exist\");\r\n\r\n        calStaticProfitInner(msg.sender);\r\n\r\n        uint sendMoney = user.unlockAmount;\r\n\r\n        bool isEnough = false;\r\n        uint resultMoney = 0;\r\n\r\n        (isEnough, resultMoney) = isEnoughBalance(sendMoney);\r\n\r\n        if (!isEnough) {\r\n            endRound();\r\n        }\r\n\r\n        if (resultMoney \u003e 0) {\r\n            if (resultMoney \u003c waitInfo[rid][msg.sender].totalAmount){\r\n                sendMoneyToUser(msg.sender, resultMoney);\r\n                delete waitInfo[rid][msg.sender];\r\n                delete userRoundMapping[rid][msg.sender];\r\n            }\r\n\r\n            emit LogRedeem(msg.sender, user.id, resultMoney, now);\r\n        }\r\n    }\r\n\r\n    function endRound() private {\r\n        rid++;\r\n        startTime = now.add(period).div(1 days).mul(1 days);\r\n        coefficient = 10;\r\n    }\r\n\r\n    function isUsed(string memory code) public view returns(bool) {\r\n        address user = getUserAddressByCode(code);\r\n        return uint(user) != 0;\r\n    }\r\n\r\n    function getUserAddressByCode(string memory code) public view returns(address) {\r\n        return addressMapping[code];\r\n    }\r\n\r\n\r\n    function getGameInfo() public isHuman() view returns(uint, uint, uint, uint, uint, uint, uint, uint) {\r\n        return (\r\n        rid,\r\n        uid,\r\n        startTime,\r\n        investCount,\r\n        investMoney,\r\n        rInvestCount[rid],\r\n        rInvestMoney[rid],\r\n        coefficient\r\n        );\r\n    }\r\n\r\n    function getUserInfo(address user, uint roundId) public isHuman() view returns(\r\n        uint[11] memory ct, string memory inviteCode, string memory referrer\r\n    ) {\r\n\r\n        if(roundId == 0){\r\n            roundId = rid;\r\n        }\r\n\r\n        User memory userInfo = userRoundMapping[roundId][user];\r\n\r\n        ct[0] = userInfo.id;\r\n        ct[1] = userInfo.staticLevel;\r\n        ct[2] = userInfo.dynamicLevel;\r\n        ct[3] = userInfo.allInvest;\r\n        ct[4] = userInfo.freezeAmount;\r\n        ct[5] = userInfo.unlockAmount;\r\n        ct[6] = userInfo.allStaticAmount;\r\n        ct[7] = userInfo.allDynamicAmount;\r\n        ct[8] = userInfo.hisStaticAmount;\r\n        ct[9] = userInfo.hisDynamicAmount;\r\n        ct[10] = extraInfo[rid][user][1];\r\n\r\n        inviteCode = userInfo.inviteCode;\r\n        referrer = userInfo.referrer;\r\n\r\n        return (\r\n        ct,\r\n        inviteCode,\r\n        referrer\r\n        );\r\n    }\r\n\r\n    function getUserById(uint id) public view returns(address){\r\n        return indexMapping[id];\r\n    }\r\n\r\n    function getWaitInfo(address user) public view returns (uint256 totalAmount, bool isWait, uint256 time, uint256[]  memory seq, bool wait) {\r\n        totalAmount = waitInfo[rid][user].totalAmount;\r\n        isWait = waitInfo[rid][user].isWait;\r\n        time = waitInfo[rid][user].time;\r\n        seq = waitInfo[rid][user].seq;\r\n        wait = waitLine;\r\n    }\r\n\r\n    function getWaitOrder(uint256 num) public view returns (address user, uint256 amount, string memory inviteCode, string  memory referrer, bool execute) {\r\n        user = waitOrder[rid][num].user;\r\n        amount = waitOrder[rid][num].amount;\r\n        inviteCode = waitOrder[rid][num].inviteCode;\r\n        referrer = waitOrder[rid][num].referrer;\r\n        execute = waitOrder[rid][num].execute;\r\n    }\r\n\r\n    function getInviteNum() public view returns(uint256 num){\r\n        num = extraInfo[rid][msg.sender][1];\r\n    }\r\n\r\n    function getLatestUnlockAmount(address userAddr) public view returns(uint)\r\n    {\r\n        User memory user = userRoundMapping[rid][userAddr];\r\n        uint allUnlock = user.unlockAmount;\r\n        for (uint i = user.staticFlag; i \u003c user.invests.length; i++) {\r\n            Invest memory invest = user.invests[i];\r\n\r\n            uint unlockDay = now.sub(invest.investTime).div(1 days);\r\n            allUnlock = allUnlock.add(invest.investAmount.div(100).mul(unlockDay).mul(profit));\r\n\r\n            allUnlock = allUnlock.add(invest.investAmount.div(100).mul(unlockDay).mul(profit));\r\n        }\r\n        allUnlock = allUnlock \u003c= waitInfo[rid][msg.sender].totalAmount ? allUnlock : waitInfo[rid][msg.sender].totalAmount;\r\n        return allUnlock;\r\n    }\r\n\r\n    function registerUser(address user, string memory inviteCode, string memory referrer) private {\r\n\r\n        uid++;\r\n        userMapping[user].id = uid;\r\n        userMapping[user].userAddress = user;\r\n        userMapping[user].inviteCode = inviteCode;\r\n        userMapping[user].referrer = referrer;\r\n\r\n        addressMapping[inviteCode] = user;\r\n        indexMapping[uid] = user;\r\n    }\r\n\r\n    function isCode(string memory invite) public view returns (bool){\r\n        return codeRegister[invite] == address(0);\r\n    }\r\n\r\n    function getUid() public view returns(uint){\r\n        return uid;\r\n    }\r\n\r\n    function withdrawEgg(uint256 money) external\r\n    payable\r\n    onlyWhitelistAdmin\r\n    {\r\n        if (money \u003e address(this).balance){\r\n            sendMoneyToUser(eggAddress, address(this).balance);\r\n        } else {\r\n            sendMoneyToUser(eggAddress, money);\r\n        }\r\n    }\r\n}\r\n"}}