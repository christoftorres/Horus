{"Activatable.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Ownable.sol\";\n\n\n/**\n * @title Activatable\n * @dev Contract is initial deactivated and can be activated by owner.\n * @author Dicether\n */\ncontract Activatable is Ownable {\n    bool public activated = false;\n\n    /// @dev Event is fired if activated.\n    event LogActive();\n\n    /// @dev Modifier, which only allows function execution if activated.\n    modifier onlyActivated() {\n        require(activated);\n        _;\n    }\n\n    /// @dev Modifier, which only allows function execution if not activated.\n    modifier onlyNotActivated() {\n        require(!activated);\n        _;\n    }\n\n    /// @dev activate contract, can be only called once by the contract owner.\n    function activate() public onlyOwner onlyNotActivated {\n        activated = true;\n        emit LogActive();\n    }\n}\n"},"ConflictResolutionInterface.sol":{"content":"pragma solidity ^0.5.0;\n\n\n/**\n * @title Conflict Resolution Interface\n * @dev interface to contract used for conflict resolution. Only needed if server or\n * user stops responding during game session. For documentation consult implementation\n * contract.\n * @author dicether\n */\ninterface ConflictResolutionInterface {\n    function minHouseStake(uint activeGames) external view returns(uint);\n\n    function maxBalance() external view returns(int);\n\n    function conflictEndFine() external pure returns(int);\n\n    function isValidBet(uint8 _gameType, uint _betNum, uint _betValue) external view returns(bool);\n\n    function endGameConflict(\n        uint8 _gameType,\n        uint _betNum,\n        uint _betValue,\n        int _balance,\n        uint _stake,\n        bytes32 _serverSeed,\n        bytes32 _userSeed\n    )\n        external\n        view\n        returns(int);\n\n    function serverForceGameEnd(\n        uint8 gameType,\n        uint _betNum,\n        uint _betValue,\n        int _balance,\n        uint _stake,\n        bytes32 _serverSeed,\n        bytes32 _userSeed,\n        uint _endInitiatedTime\n    )\n        external\n        view\n        returns(int);\n\n    function userForceGameEnd(\n        uint8 _gameType,\n        uint _betNum,\n        uint _betValue,\n        int _balance,\n        uint _stake,\n        uint _endInitiatedTime\n    )\n        external\n        view\n        returns(int);\n}\n"},"ConflictResolutionManager.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ConflictResolutionInterface.sol\";\nimport \"./Ownable.sol\";\n\n\n/**\n * @title Conflict Resolution Manager\n * @author dicether\n */\ncontract ConflictResolutionManager is Ownable {\n    /// @dev Conflict resolution contract.\n    ConflictResolutionInterface public conflictRes;\n\n    /// @dev New Conflict resolution contract.\n    address public newConflictRes = address(0);\n\n    /// @dev Time update of new conflict resolution contract was initiated.\n    uint public updateTime = 0;\n\n    /// @dev Min time before new conflict res contract can be activated after initiating update.\n    uint public constant MIN_TIMEOUT = 3 days;\n\n    /// @dev Min time before new conflict res contract can be activated after initiating update.\n    uint public constant MAX_TIMEOUT = 6 days;\n\n    /// @dev Update of conflict resolution contract was initiated.\n    event LogUpdatingConflictResolution(address newConflictResolutionAddress);\n\n    /// @dev New conflict resolution contract is active.\n    event LogUpdatedConflictResolution(address newConflictResolutionAddress);\n\n    /**\n     * @dev Constructor\n     * @param _conflictResAddress conflict resolution contract address.\n     */\n    constructor(address _conflictResAddress) public {\n        conflictRes = ConflictResolutionInterface(_conflictResAddress);\n    }\n\n    /**\n     * @dev Initiate conflict resolution contract update.\n     * @param _newConflictResAddress New conflict resolution contract address.\n     */\n    function updateConflictResolution(address _newConflictResAddress) public onlyOwner {\n        newConflictRes = _newConflictResAddress;\n        updateTime = block.timestamp;\n\n        emit LogUpdatingConflictResolution(_newConflictResAddress);\n    }\n\n    /**\n     * @dev Active new conflict resolution contract.\n     */\n    function activateConflictResolution() public onlyOwner {\n        require(newConflictRes != address(0));\n        require(updateTime != 0);\n        require(updateTime + MIN_TIMEOUT \u003c= block.timestamp \u0026\u0026 block.timestamp \u003c= updateTime + MAX_TIMEOUT);\n\n        conflictRes = ConflictResolutionInterface(newConflictRes);\n        newConflictRes = address(0);\n        updateTime = 0;\n\n        emit LogUpdatedConflictResolution(newConflictRes);\n    }\n}\n"},"Destroyable.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Pausable.sol\";\n\n\n/**\n * @title Destroyable\n * @dev Provides destroy support\n * @author dicether\n */\ncontract Destroyable is Pausable {\n    /// @dev After pausing the contract for 20 days owner can selfdestruct it.\n    uint public constant TIMEOUT_DESTROY = 20 days;\n\n    /**\n     * @dev Destroy contract and transfer ether to owner.\n     */\n    function destroy() public onlyOwner onlyPausedSince(TIMEOUT_DESTROY) {\n        selfdestruct(owner);\n    }\n}\n"},"GameChannel.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./GameChannelConflict.sol\";\n\n\n/**\n * @title Game Channel\n * @author dicether\n */\ncontract GameChannel is GameChannelConflict {\n    /**\n     * @dev contract constructor\n     * @param _serverAddress Server address.\n     * @param _minStake Min value user needs to deposit to create game session.\n     * @param _maxStake Max value user can deposit to create game session.\n     * @param _conflictResAddress Conflict resolution contract address.\n     * @param _houseAddress House address to move profit to.\n     * @param _chainId Chain id for signature domain.\n     */\n    constructor(\n        address _serverAddress,\n        uint128 _minStake,\n        uint128 _maxStake,\n        address _conflictResAddress,\n        address payable _houseAddress,\n        uint _chainId\n    )\n        public\n        GameChannelConflict(_serverAddress, _minStake, _maxStake, _conflictResAddress, _houseAddress, _chainId)\n    {\n        // nothing to do\n    }\n\n    /**\n     * @notice Create games session request. msg.value needs to be valid stake value.\n     * @param _userEndHash Last entry of users\u0027 hash chain.\n     * @param _previousGameId User\u0027s previous game id, initial 0.\n     * @param _createBefore Game can be only created before this timestamp.\n     * @param _serverEndHash Last entry of server\u0027s hash chain.\n     * @param _serverSig Server signature. See verifyCreateSig\n     */\n    function createGame(\n        bytes32 _userEndHash,\n        uint _previousGameId,\n        uint _createBefore,\n        bytes32 _serverEndHash,\n        bytes memory _serverSig\n    )\n        public\n        payable\n        onlyValidValue\n        onlyValidHouseStake(activeGames + 1)\n        onlyNotPaused\n    {\n        uint previousGameId = userGameId[msg.sender];\n        Game storage game = gameIdGame[previousGameId];\n\n        require(game.status == GameStatus.ENDED, \"prev game not ended\");\n        require(previousGameId == _previousGameId, \"inv gamePrevGameId\");\n        require(block.timestamp \u003c _createBefore, \"expired\");\n\n        verifyCreateSig(msg.sender, _previousGameId, _createBefore, _serverEndHash, _serverSig);\n\n        uint gameId = gameIdCntr++;\n        userGameId[msg.sender] = gameId;\n        Game storage newGame = gameIdGame[gameId];\n\n        newGame.stake = uint128(msg.value); // It\u0027s safe to cast msg.value as it is limited, see onlyValidValue\n        newGame.status = GameStatus.ACTIVE;\n\n        activeGames = activeGames.add(1);\n\n        // It\u0027s safe to cast msg.value as it is limited, see onlyValidValue\n        emit LogGameCreated(msg.sender, gameId, uint128(msg.value), _serverEndHash,  _userEndHash);\n    }\n\n\n    /**\n     * @dev Regular end game session. Used if user and house have both\n     * accepted current game session state.\n     * The game session with gameId _gameId is closed\n     * and the user paid out. This functions is called by the server after\n     * the user requested the termination of the current game session.\n     * @param _roundId Round id of bet.\n     * @param _balance Current balance.\n     * @param _serverHash Hash of server\u0027s seed for this bet.\n     * @param _userHash Hash of user\u0027s seed for this bet.\n     * @param _gameId Game session id.\n     * @param _contractAddress Address of this contract.\n     * @param _userAddress Address of user.\n     * @param _userSig User\u0027s signature of this bet.\n     */\n    function serverEndGame(\n        uint32 _roundId,\n        int _balance,\n        bytes32 _serverHash,\n        bytes32 _userHash,\n        uint _gameId,\n        address _contractAddress,\n        address payable _userAddress,\n        bytes memory _userSig\n    )\n        public\n        onlyServer\n    {\n        verifySig(\n                _roundId,\n                0,\n                0,\n                0,\n                _balance,\n                _serverHash,\n                _userHash,\n                _gameId,\n                _contractAddress,\n                _userSig,\n                _userAddress\n        );\n\n        regularEndGame(_userAddress, _roundId, _balance, _gameId, _contractAddress);\n    }\n\n    /**\n     * @notice Regular end game session. Normally not needed as server ends game (@see serverEndGame).\n     * Can be used by user if server does not end game session.\n     * @param _roundId Round id of bet.\n     * @param _balance Current balance.\n     * @param _serverHash Hash of server\u0027s seed for this bet.\n     * @param _userHash Hash of user\u0027s seed for this bet.\n     * @param _gameId Game session id.\n     * @param _contractAddress Address of this contract.\n     * @param _serverSig Server\u0027s signature of this bet.\n     */\n    function userEndGame(\n        uint32 _roundId,\n        int _balance,\n        bytes32 _serverHash,\n        bytes32 _userHash,\n        uint _gameId,\n        address _contractAddress,\n        bytes memory _serverSig\n    )\n        public\n    {\n        verifySig(\n                _roundId,\n                0,\n                0,\n                0,\n                _balance,\n                _serverHash,\n                _userHash,\n                _gameId,\n                _contractAddress,\n                _serverSig,\n                serverAddress\n        );\n\n        regularEndGame(msg.sender, _roundId, _balance, _gameId, _contractAddress);\n    }\n\n    /**\n     * @dev Verify server signature.\n     * @param _userAddress User\u0027s address.\n     * @param _previousGameId User\u0027s previous game id, initial 0.\n     * @param _createBefore Game can be only created before this timestamp.\n     * @param _serverEndHash Last entry of server\u0027s hash chain.\n     * @param _serverSig Server signature.\n     */\n    function verifyCreateSig(\n        address _userAddress,\n        uint _previousGameId,\n        uint _createBefore,\n        bytes32 _serverEndHash,\n        bytes memory _serverSig\n    )\n        private view\n    {\n        address contractAddress = address(this);\n        bytes32 hash = keccak256(abi.encodePacked(\n            contractAddress, _userAddress, _previousGameId, _createBefore, _serverEndHash\n        ));\n\n        verify(hash, _serverSig, serverAddress);\n    }\n\n    /**\n     * @dev Regular end game session implementation. Used if user and house have both\n     * accepted current game session state. The game session with gameId _gameId is closed\n     * and the user paid out.\n     * @param _userAddress Address of user.\n     * @param _balance Current balance.\n     * @param _gameId Game session id.\n     * @param _contractAddress Address of this contract.\n     */\n    function regularEndGame(\n        address payable _userAddress,\n        uint32 _roundId,\n        int _balance,\n        uint _gameId,\n        address _contractAddress\n    )\n        private\n    {\n        uint gameId = userGameId[_userAddress];\n        Game storage game = gameIdGame[gameId];\n        int maxBalance = conflictRes.maxBalance();\n        int gameStake = game.stake;\n\n        require(_gameId == gameId, \"inv gameId\");\n        require(_roundId \u003e 0, \"inv roundId\");\n        // save to cast as game.stake hash fixed range\n        require(-gameStake \u003c= _balance \u0026\u0026 _balance \u003c= maxBalance, \"inv balance\");\n        require(game.status == GameStatus.ACTIVE, \"inv status\");\n\n        assert(_contractAddress == address(this));\n\n        closeGame(game, gameId, _roundId, _userAddress, ReasonEnded.REGULAR_ENDED, _balance);\n    }\n}\n"},"GameChannelBase.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ConflictResolutionInterface.sol\";\nimport \"./ConflictResolutionManager.sol\";\nimport \"./Destroyable.sol\";\nimport \"./MathUtil.sol\";\nimport \"./SafeCast.sol\";\nimport \"./SafeMath.sol\";\n\n\n/**\n * @title Game Channel Base\n * @dev Base contract for state channel implementation.\n * @author dicether\n */\ncontract GameChannelBase is Destroyable, ConflictResolutionManager {\n    using SafeCast for int;\n    using SafeCast for uint;\n    using SafeMath for int;\n    using SafeMath for uint;\n\n\n    /// @dev Different game session states.\n    enum GameStatus {\n        ENDED, ///\u003c @dev Game session is ended.\n        ACTIVE, ///\u003c @dev Game session is active.\n        USER_INITIATED_END, ///\u003c @dev User initiated non regular end.\n        SERVER_INITIATED_END ///\u003c @dev Server initiated non regular end.\n    }\n\n    /// @dev Reason game session ended.\n    enum ReasonEnded {\n        REGULAR_ENDED, ///\u003c @dev Game session is regularly ended.\n        SERVER_FORCED_END, ///\u003c @dev User did not respond. Server forced end.\n        USER_FORCED_END, ///\u003c @dev Server did not respond. User forced end.\n        CONFLICT_ENDED ///\u003c @dev Server or user raised conflict ans pushed game state, opponent pushed same game state.\n    }\n\n    struct Game {\n        /// @dev Game session status.\n        GameStatus status;\n\n        /// @dev User\u0027s stake.\n        uint128 stake;\n\n        /// @dev Last game round info if not regularly ended.\n        /// If game session is ended normally this data is not used.\n        uint8 gameType;\n        uint32 roundId;\n        uint betNum;\n        uint betValue;\n        int balance;\n        bytes32 userSeed;\n        bytes32 serverSeed;\n        uint endInitiatedTime;\n    }\n\n    /// @dev Minimal time span between profit transfer.\n    uint public constant MIN_TRANSFER_TIMESPAN = 1 days;\n\n    /// @dev Maximal time span between profit transfer.\n    uint public constant MAX_TRANSFER_TIMSPAN = 6 * 30 days;\n\n    bytes32 public constant EIP712DOMAIN_TYPEHASH = keccak256(\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n    );\n\n    bytes32 public constant BET_TYPEHASH = keccak256(\n        \"Bet(uint32 roundId,uint8 gameType,uint256 number,uint256 value,int256 balance,bytes32 serverHash,bytes32 userHash,uint256 gameId)\"\n    );\n\n    bytes32 public DOMAIN_SEPERATOR;\n\n    /// @dev Current active game sessions.\n    uint public activeGames = 0;\n\n    /// @dev Game session id counter. Points to next free game session slot. So gameIdCntr -1 is the\n    // number of game sessions created.\n    uint public gameIdCntr = 1;\n\n    /// @dev Only this address can accept and end games.\n    address public serverAddress;\n\n    /// @dev Address to transfer profit to.\n    address payable public houseAddress;\n\n    /// @dev Current house stake.\n    uint public houseStake = 0;\n\n    /// @dev House profit since last profit transfer.\n    int public houseProfit = 0;\n\n    /// @dev Min value user needs to deposit for creating game session.\n    uint128 public minStake;\n\n    /// @dev Max value user can deposit for creating game session.\n    uint128 public maxStake;\n\n    /// @dev Timeout until next profit transfer is allowed.\n    uint public profitTransferTimeSpan = 14 days;\n\n    /// @dev Last time profit transferred to house.\n    uint public lastProfitTransferTimestamp;\n\n    /// @dev Maps gameId to game struct.\n    mapping (uint =\u003e Game) public gameIdGame;\n\n    /// @dev Maps user address to current user game id.\n    mapping (address =\u003e uint) public userGameId;\n\n    /// @dev Maps user address to pending returns.\n    mapping (address =\u003e uint) public pendingReturns;\n\n    /// @dev Modifier, which only allows to execute if house stake is high enough.\n    modifier onlyValidHouseStake(uint _activeGames) {\n        uint minHouseStake = conflictRes.minHouseStake(_activeGames);\n        require(houseStake \u003e= minHouseStake, \"inv houseStake\");\n        _;\n    }\n\n    /// @dev Modifier to check if value send fulfills user stake requirements.\n    modifier onlyValidValue() {\n        require(minStake \u003c= msg.value \u0026\u0026 msg.value \u003c= maxStake, \"inv stake\");\n        _;\n    }\n\n    /// @dev Modifier, which only allows server to call function.\n    modifier onlyServer() {\n        require(msg.sender == serverAddress);\n        _;\n    }\n\n    /// @dev Modifier, which only allows to set valid transfer timeouts.\n    modifier onlyValidTransferTimeSpan(uint transferTimeout) {\n        require(transferTimeout \u003e= MIN_TRANSFER_TIMESPAN\n                \u0026\u0026 transferTimeout \u003c= MAX_TRANSFER_TIMSPAN);\n        _;\n    }\n\n    /// @dev This event is fired when user creates game session.\n    event LogGameCreated(address indexed user, uint indexed gameId, uint128 stake, bytes32 indexed serverEndHash, bytes32 userEndHash);\n\n    /// @dev This event is fired when user requests conflict end.\n    event LogUserRequestedEnd(address indexed user, uint indexed gameId);\n\n    /// @dev This event is fired when server requests conflict end.\n    event LogServerRequestedEnd(address indexed user, uint indexed gameId);\n\n    /// @dev This event is fired when game session is ended.\n    event LogGameEnded(address indexed user, uint indexed gameId, uint32 roundId, int balance, ReasonEnded reason);\n\n    /// @dev this event is fired when owner modifies user\u0027s stake limits.\n    event LogStakeLimitsModified(uint minStake, uint maxStake);\n\n    /**\n     * @dev Contract constructor.\n     * @param _serverAddress Server address.\n     * @param _minStake Min value user needs to deposit to create game session.\n     * @param _maxStake Max value user can deposit to create game session.\n     * @param _conflictResAddress Conflict resolution contract address.\n     * @param _houseAddress House address to move profit to.\n     * @param _chainId Chain id for signature domain.\n     */\n    constructor(\n        address _serverAddress,\n        uint128 _minStake,\n        uint128 _maxStake,\n        address _conflictResAddress,\n        address payable _houseAddress,\n        uint _chainId\n    )\n        public\n        ConflictResolutionManager(_conflictResAddress)\n    {\n        require(_minStake \u003e 0 \u0026\u0026 _minStake \u003c= _maxStake);\n\n        serverAddress = _serverAddress;\n        houseAddress = _houseAddress;\n        lastProfitTransferTimestamp = block.timestamp;\n        minStake = _minStake;\n        maxStake = _maxStake;\n\n        DOMAIN_SEPERATOR =  keccak256(abi.encode(\n            EIP712DOMAIN_TYPEHASH,\n            keccak256(\"Dicether\"),\n            keccak256(\"2\"),\n            _chainId,\n            address(this)\n        ));\n    }\n\n    /**\n     * @dev Set gameIdCntr. Can be only set before activating contract.\n     */\n    function setGameIdCntr(uint _gameIdCntr) public onlyOwner onlyNotActivated {\n        require(gameIdCntr \u003e 0);\n        gameIdCntr = _gameIdCntr;\n    }\n\n    /**\n     * @notice Withdraw pending returns.\n     */\n    function withdraw() public {\n        uint toTransfer = pendingReturns[msg.sender];\n        require(toTransfer \u003e 0);\n\n        pendingReturns[msg.sender] = 0;\n        msg.sender.transfer(toTransfer);\n    }\n\n    /**\n     * @notice Transfer house profit to houseAddress.\n     */\n    function transferProfitToHouse() public {\n        require(lastProfitTransferTimestamp.add(profitTransferTimeSpan) \u003c= block.timestamp);\n\n        // update last transfer timestamp\n        lastProfitTransferTimestamp = block.timestamp;\n\n        if (houseProfit \u003c= 0) {\n            // no profit to transfer\n            return;\n        }\n\n        uint toTransfer = houseProfit.castToUint();\n\n        houseProfit = 0;\n        houseStake = houseStake.sub(toTransfer);\n\n        houseAddress.transfer(toTransfer);\n    }\n\n    /**\n     * @dev Set profit transfer time span.\n     */\n    function setProfitTransferTimeSpan(uint _profitTransferTimeSpan)\n        public\n        onlyOwner\n        onlyValidTransferTimeSpan(_profitTransferTimeSpan)\n    {\n        profitTransferTimeSpan = _profitTransferTimeSpan;\n    }\n\n    /**\n     * @dev Increase house stake by msg.value\n     */\n    function addHouseStake() public payable onlyOwner {\n        houseStake = houseStake.add(msg.value);\n    }\n\n    /**\n     * @dev Withdraw house stake.\n     */\n    function withdrawHouseStake(uint value) public onlyOwner {\n        uint minHouseStake = conflictRes.minHouseStake(activeGames);\n\n        require(value \u003c= houseStake \u0026\u0026 houseStake.sub(value) \u003e= minHouseStake);\n        require(houseProfit \u003c= 0 || houseProfit.castToUint() \u003c= houseStake.sub(value));\n\n        houseStake = houseStake.sub(value);\n        owner.transfer(value);\n    }\n\n    /**\n     * @dev Withdraw house stake and profit.\n     */\n    function withdrawAll() public onlyOwner onlyPausedSince(3 days) {\n        houseProfit = 0;\n        uint toTransfer = houseStake;\n        houseStake = 0;\n        owner.transfer(toTransfer);\n    }\n\n    /**\n     * @dev Set new house address.\n     * @param _houseAddress New house address.\n     */\n    function setHouseAddress(address payable _houseAddress) public onlyOwner {\n        houseAddress = _houseAddress;\n    }\n\n    /**\n     * @dev Set stake min and max value.\n     * @param _minStake Min stake.\n     * @param _maxStake Max stake.\n     */\n    function setStakeRequirements(uint128 _minStake, uint128 _maxStake) public onlyOwner {\n        require(_minStake \u003e 0 \u0026\u0026 _minStake \u003c= _maxStake);\n        minStake = _minStake;\n        maxStake = _maxStake;\n        emit LogStakeLimitsModified(minStake, maxStake);\n    }\n\n    /**\n     * @dev Close game session.\n     * @param _game Game session data.\n     * @param _gameId Id of game session.\n     * @param _userAddress User\u0027s address of game session.\n     * @param _reason Reason for closing game session.\n     * @param _balance Game session balance.\n     */\n    function closeGame(\n        Game storage _game,\n        uint _gameId,\n        uint32 _roundId,\n        address payable _userAddress,\n        ReasonEnded _reason,\n        int _balance\n    )\n        internal\n    {\n        _game.status = GameStatus.ENDED;\n\n        activeGames = activeGames.sub(1);\n\n        payOut(_userAddress, _game.stake, _balance);\n\n        emit LogGameEnded(_userAddress, _gameId, _roundId, _balance, _reason);\n    }\n\n    /**\n     * @dev End game by paying out user and server.\n     * @param _userAddress User\u0027s address.\n     * @param _stake User\u0027s stake.\n     * @param _balance User\u0027s balance.\n     */\n    function payOut(address payable _userAddress, uint128 _stake, int _balance) internal {\n        int stakeInt = _stake;\n        int houseStakeInt = houseStake.castToInt();\n\n        assert(_balance \u003c= conflictRes.maxBalance());\n        assert((stakeInt.add(_balance)) \u003e= 0);\n\n        if (_balance \u003e 0 \u0026\u0026 houseStakeInt \u003c _balance) {\n            // Should never happen!\n            // House is bankrupt.\n            // Payout left money.\n            _balance = houseStakeInt;\n        }\n\n        houseProfit = houseProfit.sub(_balance);\n\n        int newHouseStake = houseStakeInt.sub(_balance);\n        houseStake = newHouseStake.castToUint();\n\n        uint valueUser = stakeInt.add(_balance).castToUint();\n        pendingReturns[_userAddress] += valueUser;\n        if (pendingReturns[_userAddress] \u003e 0) {\n            safeSend(_userAddress);\n        }\n    }\n\n    /**\n     * @dev Send value of pendingReturns[_address] to _address.\n     * @param _address Address to send value to.\n     */\n    function safeSend(address payable _address) internal {\n        uint valueToSend = pendingReturns[_address];\n        assert(valueToSend \u003e 0);\n\n        pendingReturns[_address] = 0;\n        if (_address.send(valueToSend) == false) {\n            pendingReturns[_address] = valueToSend;\n        }\n    }\n\n    /**\n     * @dev Verify signature of given data. Throws on verification failure.\n     * @param _sig Signature of given data in the form of rsv.\n     * @param _address Address of signature signer.\n     */\n    function verifySig(\n        uint32 _roundId,\n        uint8 _gameType,\n        uint _num,\n        uint _value,\n        int _balance,\n        bytes32 _serverHash,\n        bytes32 _userHash,\n        uint _gameId,\n        address _contractAddress,\n        bytes memory _sig,\n        address _address\n    )\n        internal\n        view\n    {\n        // check if this is the correct contract\n        address contractAddress = address(this);\n        require(_contractAddress == contractAddress, \"inv contractAddress\");\n\n        bytes32 roundHash = calcHash(\n                _roundId,\n                _gameType,\n                _num,\n                _value,\n                _balance,\n                _serverHash,\n                _userHash,\n                _gameId\n        );\n\n        verify(\n                roundHash,\n                _sig,\n                _address\n        );\n    }\n\n     /**\n     * @dev Check if _sig is valid signature of _hash. Throws if invalid signature.\n     * @param _hash Hash to check signature of.\n     * @param _sig Signature of _hash.\n     * @param _address Address of signer.\n     */\n    function verify(\n        bytes32 _hash,\n        bytes memory _sig,\n        address _address\n    )\n        internal\n        pure\n    {\n        (bytes32 r, bytes32 s, uint8 v) = signatureSplit(_sig);\n        address addressRecover = ecrecover(_hash, v, r, s);\n        require(addressRecover == _address, \"inv sig\");\n    }\n\n    /**\n     * @dev Calculate typed hash of given data (compare eth_signTypedData).\n     * @return Hash of given data.\n     */\n    function calcHash(\n        uint32 _roundId,\n        uint8 _gameType,\n        uint _num,\n        uint _value,\n        int _balance,\n        bytes32 _serverHash,\n        bytes32 _userHash,\n        uint _gameId\n    )\n        private\n        view\n        returns(bytes32)\n    {\n        bytes32 betHash = keccak256(abi.encode(\n            BET_TYPEHASH,\n            _roundId,\n            _gameType,\n            _num,\n            _value,\n            _balance,\n            _serverHash,\n            _userHash,\n            _gameId\n        ));\n\n        return keccak256(abi.encodePacked(\n            \"\\x19\\x01\",\n            DOMAIN_SEPERATOR,\n            betHash\n        ));\n    }\n\n    /**\n     * @dev Split the given signature of the form rsv in r s v. v is incremented with 27 if\n     * it is below 2.\n     * @param _signature Signature to split.\n     * @return r s v\n     */\n    function signatureSplit(bytes memory _signature)\n        private\n        pure\n        returns (bytes32 r, bytes32 s, uint8 v)\n    {\n        require(_signature.length == 65, \"inv sig\");\n\n        assembly {\n            r := mload(add(_signature, 32))\n            s := mload(add(_signature, 64))\n            v := and(mload(add(_signature, 65)), 0xff)\n        }\n        if (v \u003c 2) {\n            v = v + 27;\n        }\n    }\n}\n"},"GameChannelConflict.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./GameChannelBase.sol\";\n\n\n/**\n * @title Game Channel Conflict\n * @dev Conflict handling implementation.\n * @author dicether\n */\ncontract GameChannelConflict is GameChannelBase {\n    using SafeCast for int;\n    using SafeCast for uint;\n    using SafeMath for int;\n    using SafeMath for uint;\n\n    /**\n     * @dev Contract constructor.\n     * @param _serverAddress Server address.\n     * @param _minStake Min value user needs to deposit to create game session.\n     * @param _maxStake Max value user can deposit to create game session.\n     * @param _conflictResAddress Conflict resolution contract address\n     * @param _houseAddress House address to move profit to\n     * @param _chainId Chain id for signature domain.\n     */\n    constructor(\n        address _serverAddress,\n        uint128 _minStake,\n        uint128 _maxStake,\n        address _conflictResAddress,\n        address payable _houseAddress,\n        uint _chainId\n    )\n        public\n        GameChannelBase(_serverAddress, _minStake, _maxStake, _conflictResAddress, _houseAddress, _chainId)\n    {\n        // nothing to do\n    }\n\n    /**\n     * @dev Used by server if user does not end game session.\n     * @param _roundId Round id of bet.\n     * @param _gameType Game type of bet.\n     * @param _num Number of bet.\n     * @param _value Value of bet.\n     * @param _balance Balance before this bet.\n     * @param _serverHash Hash of server seed for this bet.\n     * @param _userHash Hash of user seed for this bet.\n     * @param _gameId Game session id.\n     * @param _contractAddress Address of this contract.\n     * @param _userSig User signature of this bet.\n     * @param _userAddress Address of user.\n     * @param _serverSeed Server seed for this bet.\n     * @param _userSeed User seed for this bet.\n     */\n    function serverEndGameConflict(\n        uint32 _roundId,\n        uint8 _gameType,\n        uint _num,\n        uint _value,\n        int _balance,\n        bytes32 _serverHash,\n        bytes32 _userHash,\n        uint _gameId,\n        address _contractAddress,\n        bytes memory _userSig,\n        address payable _userAddress,\n        bytes32 _serverSeed,\n        bytes32 _userSeed\n    )\n        public\n        onlyServer\n    {\n        verifySig(\n                _roundId,\n                _gameType,\n                _num,\n                _value,\n                _balance,\n                _serverHash,\n                _userHash,\n                _gameId,\n                _contractAddress,\n                _userSig,\n                _userAddress\n        );\n\n        serverEndGameConflictImpl(\n                _roundId,\n                _gameType,\n                _num,\n                _value,\n                _balance,\n                _serverHash,\n                _userHash,\n                _serverSeed,\n                _userSeed,\n                _gameId,\n                _userAddress\n        );\n    }\n\n    /**\n     * @notice Can be used by user if server does not answer to the end game session request.\n     * @param _roundId Round id of bet.\n     * @param _gameType Game type of bet.\n     * @param _num Number of bet.\n     * @param _value Value of bet.\n     * @param _balance Balance before this bet.\n     * @param _serverHash Hash of server seed for this bet.\n     * @param _userHash Hash of user seed for this bet.\n     * @param _gameId Game session id.\n     * @param _contractAddress Address of this contract.\n     * @param _serverSig Server signature of this bet.\n     * @param _userSeed User seed for this bet.\n     */\n    function userEndGameConflict(\n        uint32 _roundId,\n        uint8 _gameType,\n        uint _num,\n        uint _value,\n        int _balance,\n        bytes32 _serverHash,\n        bytes32 _userHash,\n        uint _gameId,\n        address _contractAddress,\n        bytes memory _serverSig,\n        bytes32 _userSeed\n    )\n        public\n    {\n        verifySig(\n            _roundId,\n            _gameType,\n            _num,\n            _value,\n            _balance,\n            _serverHash,\n            _userHash,\n            _gameId,\n            _contractAddress,\n            _serverSig,\n            serverAddress\n        );\n\n        userEndGameConflictImpl(\n            _roundId,\n            _gameType,\n            _num,\n            _value,\n            _balance,\n            _userHash,\n            _userSeed,\n            _gameId,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Cancel active game without playing. Useful if server stops responding before\n     * one game is played.\n     * @param _gameId Game session id.\n     */\n    function userCancelActiveGame(uint _gameId) public {\n        address payable userAddress = msg.sender;\n        uint gameId = userGameId[userAddress];\n        Game storage game = gameIdGame[gameId];\n\n        require(gameId == _gameId, \"inv gameId\");\n\n        if (game.status == GameStatus.ACTIVE) {\n            game.endInitiatedTime = block.timestamp;\n            game.status = GameStatus.USER_INITIATED_END;\n\n            emit LogUserRequestedEnd(msg.sender, gameId);\n        } else if (game.status == GameStatus.SERVER_INITIATED_END \u0026\u0026 game.roundId == 0) {\n            cancelActiveGame(game, gameId, userAddress);\n        } else {\n            revert();\n        }\n    }\n\n    /**\n     * @dev Cancel active game without playing. Useful if user starts game session and\n     * does not play.\n     * @param _userAddress Users\u0027 address.\n     * @param _gameId Game session id.\n     */\n    function serverCancelActiveGame(address payable _userAddress, uint _gameId) public onlyServer {\n        uint gameId = userGameId[_userAddress];\n        Game storage game = gameIdGame[gameId];\n\n        require(gameId == _gameId, \"inv gameId\");\n\n        if (game.status == GameStatus.ACTIVE) {\n            game.endInitiatedTime = block.timestamp;\n            game.status = GameStatus.SERVER_INITIATED_END;\n\n            emit LogServerRequestedEnd(msg.sender, gameId);\n        } else if (game.status == GameStatus.USER_INITIATED_END \u0026\u0026 game.roundId == 0) {\n            cancelActiveGame(game, gameId, _userAddress);\n        } else {\n            revert();\n        }\n    }\n\n    /**\n    * @dev Force end of game if user does not respond. Only possible after a certain period of time\n    * to give the user a chance to respond.\n    * @param _userAddress User\u0027s address.\n    */\n    function serverForceGameEnd(address payable _userAddress, uint _gameId) public onlyServer {\n        uint gameId = userGameId[_userAddress];\n        Game storage game = gameIdGame[gameId];\n\n        require(gameId == _gameId, \"inv gameId\");\n        require(game.status == GameStatus.SERVER_INITIATED_END, \"inv status\");\n\n        // theoretically we have enough data to calculate winner\n        // but as user did not respond assume he has lost.\n        int newBalance = conflictRes.serverForceGameEnd(\n            game.gameType,\n            game.betNum,\n            game.betValue,\n            game.balance,\n            game.stake,\n            game.serverSeed,\n            game.userSeed,\n            game.endInitiatedTime\n        );\n\n        closeGame(game, gameId, game.roundId, _userAddress, ReasonEnded.SERVER_FORCED_END, newBalance);\n    }\n\n    /**\n    * @notice Force end of game if server does not respond. Only possible after a certain period of time\n    * to give the server a chance to respond.\n    */\n    function userForceGameEnd(uint _gameId) public {\n        address payable userAddress = msg.sender;\n        uint gameId = userGameId[userAddress];\n        Game storage game = gameIdGame[gameId];\n\n        require(gameId == _gameId, \"inv gameId\");\n        require(game.status == GameStatus.USER_INITIATED_END, \"inv status\");\n\n        int newBalance = conflictRes.userForceGameEnd(\n            game.gameType,\n            game.betNum,\n            game.betValue,\n            game.balance,\n            game.stake,\n            game.endInitiatedTime\n        );\n\n        closeGame(game, gameId, game.roundId, userAddress, ReasonEnded.USER_FORCED_END, newBalance);\n    }\n\n    /**\n     * @dev Conflict handling implementation. Stores game data and timestamp if game\n     * is active. If server has already marked conflict for game session the conflict\n     * resolution contract is used (compare conflictRes).\n     * @param _roundId Round id of bet.\n     * @param _gameType Game type of bet.\n     * @param _num Number of bet.\n     * @param _value Value of bet.\n     * @param _balance Balance before this bet.\n     * @param _userHash Hash of user\u0027s seed for this bet.\n     * @param _userSeed User\u0027s seed for this bet.\n     * @param _gameId game Game session id.\n     * @param _userAddress User\u0027s address.\n     */\n    function userEndGameConflictImpl(\n        uint32 _roundId,\n        uint8 _gameType,\n        uint _num,\n        uint _value,\n        int _balance,\n        bytes32 _userHash,\n        bytes32 _userSeed,\n        uint _gameId,\n        address payable _userAddress\n    )\n        private\n    {\n        uint gameId = userGameId[_userAddress];\n        Game storage game = gameIdGame[gameId];\n        int maxBalance = conflictRes.maxBalance();\n        int gameStake = game.stake;\n\n        require(gameId == _gameId, \"inv gameId\");\n        require(_roundId \u003e 0, \"inv roundId\");\n        require(keccak256(abi.encodePacked(_userSeed)) == _userHash, \"inv userSeed\");\n        require(-gameStake \u003c= _balance \u0026\u0026 _balance \u003c= maxBalance, \"inv balance\"); // game.stake save to cast as uint128\n        require(conflictRes.isValidBet(_gameType, _num, _value), \"inv bet\");\n        require(gameStake.add(_balance).sub(_value.castToInt()) \u003e= 0, \"value too high\"); // game.stake save to cast as uint128\n\n        if (game.status == GameStatus.SERVER_INITIATED_END \u0026\u0026 game.roundId == _roundId) {\n            game.userSeed = _userSeed;\n            endGameConflict(game, gameId, _userAddress);\n        } else if (game.status == GameStatus.ACTIVE\n                || (game.status == GameStatus.SERVER_INITIATED_END \u0026\u0026 game.roundId \u003c _roundId)) {\n            game.status = GameStatus.USER_INITIATED_END;\n            game.endInitiatedTime = block.timestamp;\n            game.roundId = _roundId;\n            game.gameType = _gameType;\n            game.betNum = _num;\n            game.betValue = _value;\n            game.balance = _balance;\n            game.userSeed = _userSeed;\n            game.serverSeed = bytes32(0);\n\n            emit LogUserRequestedEnd(msg.sender, gameId);\n        } else {\n            revert(\"inv state\");\n        }\n    }\n\n    /**\n     * @dev Conflict handling implementation. Stores game data and timestamp if game\n     * is active. If user has already marked conflict for game session the conflict\n     * resolution contract is used (compare conflictRes).\n     * @param _roundId Round id of bet.\n     * @param _gameType Game type of bet.\n     * @param _num Number of bet.\n     * @param _value Value of bet.\n     * @param _balance Balance before this bet.\n     * @param _serverHash Hash of server\u0027s seed for this bet.\n     * @param _userHash Hash of user\u0027s seed for this bet.\n     * @param _serverSeed Server\u0027s seed for this bet.\n     * @param _userSeed User\u0027s seed for this bet.\n     * @param _userAddress User\u0027s address.\n     */\n    function serverEndGameConflictImpl(\n        uint32 _roundId,\n        uint8 _gameType,\n        uint _num,\n        uint _value,\n        int _balance,\n        bytes32 _serverHash,\n        bytes32 _userHash,\n        bytes32 _serverSeed,\n        bytes32 _userSeed,\n        uint _gameId,\n        address payable _userAddress\n    )\n        private\n    {\n        uint gameId = userGameId[_userAddress];\n        Game storage game = gameIdGame[gameId];\n        int maxBalance = conflictRes.maxBalance();\n        int gameStake = game.stake;\n\n        require(gameId == _gameId, \"inv gameId\");\n        require(_roundId \u003e 0, \"inv roundId\");\n        require(keccak256(abi.encodePacked(_serverSeed)) == _serverHash, \"inv serverSeed\");\n        require(keccak256(abi.encodePacked(_userSeed)) == _userHash, \"inv userSeed\");\n        require(-gameStake \u003c= _balance \u0026\u0026 _balance \u003c= maxBalance, \"inv balance\"); // game.stake save to cast as uint128\n        require(conflictRes.isValidBet(_gameType, _num, _value), \"inv bet\");\n        require(gameStake.add(_balance).sub(_value.castToInt()) \u003e= 0, \"too high value\"); // game.stake save to cast as uin128\n\n        if (game.status == GameStatus.USER_INITIATED_END \u0026\u0026 game.roundId == _roundId) {\n            game.serverSeed = _serverSeed;\n            endGameConflict(game, gameId, _userAddress);\n        } else if (game.status == GameStatus.ACTIVE\n                || (game.status == GameStatus.USER_INITIATED_END \u0026\u0026 game.roundId \u003c _roundId)) {\n            game.status = GameStatus.SERVER_INITIATED_END;\n            game.endInitiatedTime = block.timestamp;\n            game.roundId = _roundId;\n            game.gameType = _gameType;\n            game.betNum = _num;\n            game.betValue = _value;\n            game.balance = _balance;\n            game.serverSeed = _serverSeed;\n            game.userSeed = _userSeed;\n\n            emit LogServerRequestedEnd(_userAddress, gameId);\n        } else {\n            revert(\"inv state\");\n        }\n    }\n\n    /**\n     * @dev End conflicting game without placed bets.\n     * @param _game Game session data.\n     * @param _gameId Game session id.\n     * @param _userAddress User\u0027s address.\n     */\n    function cancelActiveGame(Game storage _game, uint _gameId, address payable _userAddress) private {\n        // user need to pay a fee when conflict ended.\n        // this ensures a malicious, rich user can not just generate game sessions and then wait\n        // for us to end the game session and then confirm the session status, so\n        // we would have to pay a high gas fee without profit.\n        int newBalance = -conflictRes.conflictEndFine();\n\n        // do not allow balance below user stake\n        int stake = _game.stake;\n        if (newBalance \u003c -stake) {\n            newBalance = -stake;\n        }\n        closeGame(_game, _gameId, 0, _userAddress, ReasonEnded.CONFLICT_ENDED, newBalance);\n    }\n\n    /**\n     * @dev End conflicting game.\n     * @param _game Game session data.\n     * @param _gameId Game session id.\n     * @param _userAddress User\u0027s address.\n     */\n    function endGameConflict(Game storage _game, uint _gameId, address payable _userAddress) private {\n        int newBalance = conflictRes.endGameConflict(\n            _game.gameType,\n            _game.betNum,\n            _game.betValue,\n            _game.balance,\n            _game.stake,\n            _game.serverSeed,\n            _game.userSeed\n        );\n\n        closeGame(_game, _gameId, _game.roundId, _userAddress, ReasonEnded.CONFLICT_ENDED, newBalance);\n    }\n}\n"},"MathUtil.sol":{"content":"pragma solidity ^0.5.0;\n\n\n/**\n * @title Math utils\n * @author dicether\n */\nlibrary MathUtil {\n    /**\n     * @dev Returns the absolute value of _val.\n     * @param _val value\n     * @return The absolute value of _val.\n     */\n    function abs(int _val) internal pure returns(uint) {\n        if (_val \u003c 0) {\n            return uint(-_val);\n        } else {\n            return uint(_val);\n        }\n    }\n\n    /**\n     * @dev Calculate maximum.\n     */\n    function max(uint _val1, uint _val2) internal pure returns(uint) {\n        return _val1 \u003e= _val2 ? _val1 : _val2;\n    }\n\n    /**\n     * @dev Calculate minimum.\n     */\n    function min(uint _val1, uint _val2) internal pure returns(uint) {\n        return _val1 \u003c= _val2 ? _val1 : _val2;\n    }\n}\n"},"Migrations.sol":{"content":"pragma solidity ^0.5.0;\n\ncontract Migrations {\n    address public owner;\n    uint public last_completed_migration;\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setCompleted(uint completed) public restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.5.0;\n\n\n/**\n * @title Owned\n * @dev Basic contract for authorization control.\n * @author dicether\n */\ncontract Ownable {\n    address payable public owner;\n    address payable public pendingOwner;\n\n    event LogOwnerShipTransferred(address indexed previousOwner, address indexed newOwner);\n    event LogOwnerShipTransferInitiated(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Modifier, which throws if called by other account than owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Modifier throws if called by any account other than the pendingOwner.\n     */\n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner);\n        _;\n    }\n\n    /**\n     * @dev Set contract creator as initial owner\n     */\n    constructor() public {\n        owner = msg.sender;\n        pendingOwner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to set the pendingOwner address.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address payable _newOwner) public onlyOwner {\n        pendingOwner = _newOwner;\n        emit LogOwnerShipTransferInitiated(owner, _newOwner);\n    }\n\n    /**\n     * @dev PendingOwner can accept ownership.\n     */\n    function claimOwnership() public onlyPendingOwner {\n        owner = pendingOwner;\n        pendingOwner = address(0);\n        emit LogOwnerShipTransferred(owner, pendingOwner);\n    }\n}\n"},"Pausable.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Activatable.sol\";\nimport \"./SafeMath.sol\";\n\n\n/**\n * @title Pausable\n * @dev Provides pausing support.\n * @author dicether\n */\ncontract Pausable is Activatable {\n    using SafeMath for uint;\n\n    /// @dev Is contract paused. Initial it is paused.\n    bool public paused = true;\n\n    /// @dev Time pause was called\n    uint public timePaused = block.timestamp;\n\n    /// @dev Modifier, which only allows function execution if not paused.\n    modifier onlyNotPaused() {\n        require(!paused, \"paused\");\n        _;\n    }\n\n    /// @dev Modifier, which only allows function execution if paused.\n    modifier onlyPaused() {\n        require(paused);\n        _;\n    }\n\n    /// @dev Modifier, which only allows function execution if paused longer than timeSpan.\n    modifier onlyPausedSince(uint timeSpan) {\n        require(paused \u0026\u0026 (timePaused.add(timeSpan) \u003c= block.timestamp));\n        _;\n    }\n\n    /// @dev Event is fired if paused.\n    event LogPause();\n\n    /// @dev Event is fired if pause is ended.\n    event LogUnpause();\n\n    /**\n     * @dev Pause contract. No new game sessions can be created.\n     */\n    function pause() public onlyOwner onlyNotPaused {\n        paused = true;\n        timePaused = block.timestamp;\n        emit LogPause();\n    }\n\n    /**\n     * @dev Unpause contract. Initial contract is paused and can only be unpaused after activating it.\n     */\n    function unpause() public onlyOwner onlyPaused onlyActivated {\n        paused = false;\n        timePaused = 0;\n        emit LogUnpause();\n    }\n}\n"},"SafeCast.sol":{"content":"pragma solidity ^0.5.0;\n\nlibrary SafeCast {\n    /**\n     * Cast unsigned a to signed a.\n     */\n    function castToInt(uint a) internal pure returns(int) {\n        assert(a \u003c (1 \u003c\u003c 255));\n        return int(a);\n    }\n\n    /**\n     * Cast signed a to unsigned a.\n     */\n    function castToUint(int a) internal pure returns(uint) {\n        assert(a \u003e= 0);\n        return uint(a);\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error.\n * From zeppelin-solidity\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two unsigned integers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Multiplies two signed integers, throws on overflow.\n    */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than asserting \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n        int256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two unsigned integers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n        return a / b;\n    }\n\n    /**\n    * @dev Integer division of two signed integers, truncating the quotient.\n    */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        // assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n        // Overflow only happens when the smallest negative int is multiplied by -1.\n        int256 INT256_MIN = int256((uint256(1) \u003c\u003c 255));\n        assert(a != INT256_MIN || b != - 1);\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two unsigned integers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b \u003c= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Subtracts two signed integers, throws on overflow.\n    */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        assert((b \u003e= 0 \u0026\u0026 c \u003c= a) || (b \u003c 0 \u0026\u0026 c \u003e a));\n        return c;\n    }\n\n    /**\n    * @dev Adds two unsigned integers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c \u003e= a);\n        return c;\n    }\n\n    /**\n    * @dev Adds two signed integers, throws on overflow.\n    */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        assert((b \u003e= 0 \u0026\u0026 c \u003e= a) || (b \u003c 0 \u0026\u0026 c \u003c a));\n        return c;\n    }\n}\n"}}