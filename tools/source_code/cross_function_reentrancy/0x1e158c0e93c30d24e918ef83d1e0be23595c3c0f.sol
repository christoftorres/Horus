{"Eth2DaiReserve.sol":{"content":"pragma solidity 0.5.11;\n\nimport \"./IERC20.sol\";\nimport \"./IKyberReserve.sol\";\nimport \"./WithdrawableV5.sol\";\nimport \"./UtilsV5.sol\";\nimport \"./IOtc.sol\";\n\ncontract IWeth is IERC20 {\n    function deposit() public payable;\n    function withdraw(uint) public;\n}\n\ncontract Eth2DaiReserve is IKyberReserve, Withdrawable, Utils {\n\n    // constants\n    uint constant internal INVALID_ID = uint(-1);\n    uint constant internal POW_2_32 = 2 ** 32;\n    uint constant internal POW_2_96 = 2 ** 96;\n    uint constant internal BPS = 10000; // 10^4\n\n    // values\n    address public kyberNetwork;\n    bool public tradeEnabled;\n    uint public feeBps;\n\n    IOtc public otc;\n    IWeth public wethToken;// = IWeth(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    mapping(address =\u003e bool) public isTokenListed;\n    // 1 bit: isInternalInventoryEnabled, 95 bits: min token, 96 bits: max token, 32 bits: premiumBps, 32 bits: minSpreadBps;\n    mapping(address =\u003e uint) internal internalInventoryData;\n    // basicData contains compact data of min eth support, max traverse and max takes\n    // min eth support (first 192 bits) + max traverse (32 bits) + max takes (32 bits) = 256 bits\n    mapping(address =\u003e uint) internal tokenBasicData;\n    // factorData contains compact data of factors to compute max traverse, max takes, and min take order size\n    // 6 params, each 32 bits (6 * 32 = 192 bits)\n    mapping(address =\u003e uint) internal tokenFactorData;\n\n    struct BasicDataConfig {\n        uint minETHSupport;\n        uint maxTraverse;\n        uint maxTakes;\n    }\n\n    struct FactorDataConfig {\n        uint maxTraverseX;\n        uint maxTraverseY;\n        uint maxTakeX;\n        uint maxTakeY;\n        uint minOrderSizeX;\n        uint minOrderSizeY;\n    }\n\n    struct InternalInventoryData {\n        bool isEnabled;\n        uint minTokenBal;\n        uint maxTokenBal;\n        uint premiumBps;\n        uint minSpreadBps;\n    }\n\n    struct OfferData {\n        uint payAmount;\n        uint buyAmount;\n        uint id;\n    }\n\n    constructor(address _kyberNetwork, uint _feeBps, address _otc, address _weth, address _admin) \n        public Withdrawable(_admin)\n    {\n        require(_kyberNetwork != address(0), \"constructor: kyberNetwork\u0027s address is missing\");\n        require(_otc != address(0), \"constructor: otc\u0027s address is missing\");\n        require(_weth != address(0), \"constructor: weth\u0027s address is missing\");\n        require(_feeBps \u003c BPS, \"constructor: fee \u003e= bps\");\n        \n        wethToken = IWeth(_weth);\n        require(getDecimals(wethToken) == MAX_DECIMALS, \"constructor: wethToken\u0027s decimals is not MAX_DECIMALS\");\n        require(wethToken.approve(_otc, 2**255), \"constructor: failed to approve otc (wethToken)\");\n\n        kyberNetwork = _kyberNetwork;\n        otc = IOtc(_otc);\n        feeBps = _feeBps;\n        admin = _admin;\n        tradeEnabled = true;\n    }\n\n    function() external payable {} // solhint-disable-line no-empty-blocks\n\n    /**\n        Returns conversion rate of given pair and srcQty, use 1 as srcQty if srcQty = 0\n        Using eth amount to compute offer limit configurations\n        =\u003e need to check spread is ok for token -\u003e eth\n        Last bit of the rate indicates whether to use internal inventory:\n          0 - use eth2dai\n          1 - use internal inventory\n    */\n    function getConversionRate(IERC20 src, IERC20 dest, uint srcQty, uint) public view returns(uint) {\n        if (!tradeEnabled) { return 0; }\n        if (srcQty == 0) { return 0; }\n        // check if token\u0027s listed\n        IERC20 token = src == ETH_TOKEN_ADDRESS ? dest : src;\n        if (!isTokenListed[address(token)]) { return 0; }\n\n        OfferData memory bid;\n        OfferData memory ask;\n        (bid, ask) = getFirstBidAndAskOrders(token);\n\n        // if token is src, need to check for valid spread\n        if (token == src \u0026\u0026 !checkValidSpread(bid, ask, false, 0)) { return 0; }\n\n        uint destQty;\n        OfferData[] memory offers;\n\n        if (src == ETH_TOKEN_ADDRESS) {\n            (destQty, offers) = findBestOffers(dest, wethToken, srcQty, bid, ask);\n        } else {\n            (destQty, offers) = findBestOffers(wethToken, src, srcQty, bid, ask);\n        }\n\n        if (offers.length == 0 || destQty == 0) { return 0; } // no offer or destQty == 0, return 0 for rate\n\n        uint rate = calcRateFromQty(srcQty, destQty, MAX_DECIMALS, MAX_DECIMALS);\n\n        bool useInternalInventory;\n        uint premiumBps;\n\n        if (src == ETH_TOKEN_ADDRESS) {\n            (useInternalInventory, premiumBps) = shouldUseInternalInventory(dest,\n                                                                            destQty,\n                                                                            srcQty,\n                                                                            true,\n                                                                            bid,\n                                                                            ask\n                                                                            );\n        } else {\n            (useInternalInventory, premiumBps) = shouldUseInternalInventory(src,\n                                                                            srcQty,\n                                                                            destQty,\n                                                                            false,\n                                                                            bid,\n                                                                            ask\n                                                                            );\n        }\n\n        if (useInternalInventory) {\n            rate = valueAfterAddingPremium(rate, premiumBps);\n        } else {\n            rate = valueAfterReducingFee(rate);\n        }\n\n        return applyInternalInventoryHintToRate(rate, useInternalInventory);\n    }\n\n    event TradeExecute(\n        address indexed origin,\n        address src,\n        uint srcAmount,\n        address destToken,\n        uint destAmount,\n        address payable destAddress\n    );\n\n    function trade(\n        IERC20 srcToken,\n        uint srcAmount,\n        IERC20 destToken,\n        address payable destAddress,\n        uint conversionRate,\n        bool validate\n    )\n        public\n        payable\n        returns(bool)\n    {\n        require(tradeEnabled, \"trade: tradeEnabled is false\");\n        require(msg.sender == kyberNetwork, \"trade: not call from kyberNetwork\u0027s contract\");\n        require(srcToken == ETH_TOKEN_ADDRESS || destToken == ETH_TOKEN_ADDRESS, \"trade: srcToken or destToken must be ETH\");\n\n        IERC20 token = srcToken == ETH_TOKEN_ADDRESS ? destToken : srcToken;\n        require(isTokenListed[address(token)], \"trade: token is not listed\");\n\n        require(doTrade(srcToken, srcAmount, destToken, destAddress, conversionRate, validate), \"trade: doTrade returns false\");\n        return true;\n    }\n\n    event TokenConfigDataSet(\n        IERC20 token, uint maxTraverse, uint traveseFactorX, uint traveseFactorY,\n        uint maxTake, uint takeFactorX, uint takeFactorY,\n        uint minSizeFactorX, uint minSizeFactorY, uint minETHSupport\n    );\n\n    function setTokenConfigData(\n        IERC20 token, uint maxTraverse, uint traveseFactorX, uint traveseFactorY,\n        uint maxTake, uint takeFactorX, uint takeFactorY,\n        uint minSizeFactorX, uint minSizeFactorY, uint minETHSupport\n    )\n        public onlyAdmin\n    {\n        address tokenAddr = address(token);\n        require(isTokenListed[tokenAddr]);\n        tokenBasicData[tokenAddr] = encodeTokenBasicData(minETHSupport, maxTraverse, maxTake);\n        tokenFactorData[tokenAddr] = encodeFactorData(\n            traveseFactorX,\n            traveseFactorY,\n            takeFactorX,\n            takeFactorY,\n            minSizeFactorX,\n            minSizeFactorY\n        );\n        emit TokenConfigDataSet(\n            token, maxTraverse, traveseFactorX, takeFactorY,\n            maxTake, takeFactorX, takeFactorY,\n            minSizeFactorX, minSizeFactorY, minETHSupport\n        );\n    }\n\n    event TradeEnabled(bool enable);\n\n    function enableTrade() public onlyAdmin returns(bool) {\n        tradeEnabled = true;\n        emit TradeEnabled(true);\n\n        return true;\n    }\n\n    function disableTrade() public onlyAlerter returns(bool) {\n        tradeEnabled = false;\n        emit TradeEnabled(false);\n\n        return true;\n    }\n\n    event ContractsSet(address kyberNetwork, address otc);\n\n    function setContracts(address _kyberNetwork, address _otc) public onlyAdmin {\n        require(_kyberNetwork != address(0), \"setContracts: kyberNetwork\u0027s address is missing\");\n        require(_otc != address(0), \"setContracts: otc\u0027s address is missing\");\n\n        kyberNetwork = _kyberNetwork;\n\n        if (_otc != address(otc)) {\n            // new otc address\n            require(wethToken.approve(address(otc), 0), \"setContracts: failed to reset allowance for old otc (wethToken)\");\n            otc = IOtc(_otc);\n            require(wethToken.approve(_otc, 2**255), \"setContracts: failed to approve otc (wethToken)\");\n        }\n\n        emit ContractsSet(_kyberNetwork, _otc);\n    }\n\n    event InternalInventoryDataSet(uint minToken, uint maxToken, uint pricePremiumBps, uint minSpreadBps);\n\n    function setInternalInventoryData(\n        IERC20 token,\n        bool isEnabled,\n        uint minToken,\n        uint maxToken,\n        uint pricePremiumBps,\n        uint minSpreadBps\n    )\n        public onlyAdmin\n    {\n        require(isTokenListed[address(token)], \"setInternalInventoryData: token is not listed\");\n        require(minToken \u003c POW_2_96/2, \"setInternalInventoryData: minToken \u003e 2**95\");\n        require(maxToken \u003c POW_2_96, \"setInternalInventoryData: maxToken \u003e 2**96\");\n        require(pricePremiumBps \u003c POW_2_32, \"setInternalInventoryData: pricePremiumBps \u003e 2**32\");\n        require(minSpreadBps \u003c POW_2_32, \"setInternalInventoryData: minSpreadBps \u003e 2**32\");\n\n        internalInventoryData[address(token)] = encodeInternalInventoryData(isEnabled, minToken, maxToken, pricePremiumBps, minSpreadBps);\n\n        emit InternalInventoryDataSet(minToken, maxToken, pricePremiumBps, minSpreadBps);\n    }\n\n    event TokenListed(IERC20 token);\n\n    function listToken(IERC20 token) public onlyAdmin {\n        address tokenAddr = address(token);\n\n        require(tokenAddr != address(0), \"listToken: token\u0027s address is missing\");\n        require(!isTokenListed[tokenAddr], \"listToken: token\u0027s alr listed\");\n        require(getDecimals(token) == MAX_DECIMALS, \"listToken: token\u0027s decimals is not MAX_DECIMALS\");\n        require(token.approve(address(otc), 2**255), \"listToken: approve token otc failed\");\n\n        isTokenListed[tokenAddr] = true;\n\n        emit TokenListed(token);\n    }\n\n    event TokenDelisted(IERC20 token);\n\n    function delistToken(IERC20 token) public onlyAdmin {\n        address tokenAddr = address(token);\n\n        require(isTokenListed[tokenAddr], \"delistToken: token is not listed\");\n        require(token.approve(address(otc), 0), \"delistToken: reset approve token failed\");\n\n        delete isTokenListed[tokenAddr];\n        delete internalInventoryData[tokenAddr];\n        delete tokenFactorData[tokenAddr];\n        delete tokenBasicData[tokenAddr];\n\n        emit TokenDelisted(token);\n    }\n\n    event FeeBpsSet(uint feeBps);\n\n    function setFeeBps(uint _feeBps) public onlyAdmin {\n        require(_feeBps \u003c BPS, \"setFeeBps: feeBps \u003e= bps\");\n\n        feeBps = _feeBps;\n        emit FeeBpsSet(feeBps);\n    }\n\n    function showBestOffers(IERC20 token, bool isEthToToken, uint srcAmountToken)\n        public view\n        returns(uint destAmount, uint destAmountToken, uint[] memory offerIds) \n    {\n        if (srcAmountToken == 0) {\n            // return 0\n            destAmount = 0;\n            destAmountToken = 0;\n            offerIds = new uint[](0);\n            return (destAmount, destAmountToken, offerIds);\n        }\n\n        OfferData[] memory offers;\n        IERC20 dstToken = isEthToToken ? token : wethToken;\n        IERC20 srcToken = isEthToToken ? wethToken : token;\n\n        OfferData memory bid;\n        OfferData memory ask;\n        (bid, ask) = getFirstBidAndAskOrders(token);\n\n        (destAmount, offers) = findBestOffers(dstToken, srcToken, (srcAmountToken * 10 ** 18), bid, ask);\n\n        destAmountToken = destAmount / 10 ** 18;\n\n        uint i;\n        for (i; i \u003c offers.length; i++) {\n            if (offers[i].id == 0) {\n                break;\n            }\n        }\n\n        offerIds = new uint[](i);\n        for (i = 0; i \u003c offerIds.length; i++) {\n            offerIds[i] = offers[i].id;\n        }\n    }\n\n    function getTokenBasicDataPub(IERC20 token)\n        public view\n        returns (uint minETHSupport, uint maxTraverse, uint maxTakes)\n    {\n        (minETHSupport, maxTraverse, maxTakes) = decodeTokenBasicData(tokenBasicData[address(token)]);\n    }\n\n    function getFactorDataPub(IERC20 token)\n        public view\n        returns (uint maxTraverseX, uint maxTraverseY, uint maxTakeX, uint maxTakeY, uint minOrderSizeX, uint minOrderSizeY)\n    {\n        (maxTraverseX, maxTraverseY, maxTakeX, maxTakeY, minOrderSizeX, minOrderSizeY) = decodeFactorData(tokenFactorData[address(token)]);\n    }\n\n    function getInternalInventoryDataPub(IERC20 token)\n        public view\n        returns(bool isEnabled, uint minTokenBal, uint maxTokenBal, uint premiumBps, uint minSpreadBps)\n    {\n        (isEnabled, minTokenBal, maxTokenBal, premiumBps, minSpreadBps) = decodeInternalInventoryData(internalInventoryData[address(token)]);\n    }\n\n    /// @dev do a trade\n    /// @param srcToken Src token\n    /// @param srcAmount Amount of src token\n    /// @param destToken Destination token\n    /// @param destAddress Destination address to send tokens to\n    /// @return true iff trade is successful\n    function doTrade(\n        IERC20 srcToken,\n        uint srcAmount,\n        IERC20 destToken,\n        address payable destAddress,\n        uint conversionRate,\n        bool validate\n    )\n        internal\n        returns(bool)\n    {\n        // can skip validation if done at kyber network level\n        if (validate) {\n            require(conversionRate \u003e 0, \"doTrade: conversionRate is 0\");\n            if (srcToken == ETH_TOKEN_ADDRESS)\n                require(msg.value == srcAmount, \"doTrade: msg.value != srcAmount\");\n            else\n                require(msg.value == 0, \"doTrade: msg.value must be 0\");\n        }\n\n        uint userExpectedDestAmount = calcDstQty(srcAmount, MAX_DECIMALS, MAX_DECIMALS, conversionRate);\n        require(userExpectedDestAmount \u003e 0, \"doTrade: userExpectedDestAmount == 0\"); // sanity check\n\n        uint actualDestAmount;\n\n        // using hint to check if we should use our internal inventory\n        bool useInternalInventory = conversionRate % 2 == 1;\n\n        if (useInternalInventory) {\n            // taking from internal inventory and return\n            if (srcToken == ETH_TOKEN_ADDRESS) {\n                // transfer back only requested dest amount.\n                require(destToken.transfer(destAddress, userExpectedDestAmount), \"doTrade: (useInternalInventory) can not transfer back token\");\n            } else {\n                // collect src token\n                require(srcToken.transferFrom(msg.sender, address(this), srcAmount), \"doTrade: (useInternalInventory) can not collect src token\");\n                // transfer back only requested dest amount.\n                destAddress.transfer(userExpectedDestAmount);\n            }\n\n            emit TradeExecute(msg.sender, address(srcToken), srcAmount, address(destToken), userExpectedDestAmount, destAddress);\n            return true;\n        }\n\n        OfferData memory bid;\n        OfferData memory ask;\n        (bid, ask) = getFirstBidAndAskOrders(srcToken == ETH_TOKEN_ADDRESS ? destToken : srcToken);\n\n        // get offers to take\n        OfferData[] memory offers;\n        if (srcToken == ETH_TOKEN_ADDRESS) {\n            (actualDestAmount, offers) = findBestOffers(destToken, wethToken, srcAmount, bid, ask);\n        } else {\n            (actualDestAmount, offers) = findBestOffers(wethToken, srcToken, srcAmount, bid, ask);\n        }\n\n        require(actualDestAmount \u003e= userExpectedDestAmount, \"doTrade: actualDestAmount is less than userExpectedDestAmount\");\n\n        if (srcToken == ETH_TOKEN_ADDRESS) {\n            wethToken.deposit.value(msg.value)();\n            actualDestAmount = takeMatchingOrders(destToken, srcAmount, offers);\n            require(actualDestAmount \u003e= userExpectedDestAmount, \"doTrade: actualDestAmount is less than userExpectedDestAmount, eth to token\");\n            // transfer back only requested dest amount\n            require(destToken.transfer(destAddress, userExpectedDestAmount), \"doTrade: can not transfer back requested token\");\n        } else {\n            // collect src tokens\n            require(srcToken.transferFrom(msg.sender, address(this), srcAmount), \"doTrade: can not collect src token\");\n            actualDestAmount = takeMatchingOrders(wethToken, srcAmount, offers);\n            require(actualDestAmount \u003e= userExpectedDestAmount, \"doTrade: actualDestAmount is less than userExpectedDestAmount, token to eth\");\n            wethToken.withdraw(actualDestAmount);\n            // transfer back only requested dest amount.\n            destAddress.transfer(userExpectedDestAmount);\n        }\n\n        emit TradeExecute(msg.sender, address(srcToken), srcAmount, address(destToken), userExpectedDestAmount, destAddress);\n        return true;\n    }\n\n    function takeMatchingOrders(IERC20 destToken, uint srcAmount, OfferData[] memory offers)\n        internal\n        returns(uint actualDestAmount)\n    {\n        require(destToken != ETH_TOKEN_ADDRESS, \"takeMatchingOrders: destToken is ETH\");\n\n        uint lastReserveBalance = destToken.balanceOf(address(this));\n        uint remainingSrcAmount = srcAmount;\n\n        for (uint i = 0; i \u003c offers.length; i++) {\n            if (offers[i].id == 0 || remainingSrcAmount == 0) { break; }\n\n            uint payAmount = minOf(remainingSrcAmount, offers[i].payAmount);\n            uint buyAmount = payAmount * offers[i].buyAmount / offers[i].payAmount;\n\n            otc.take(bytes32(offers[i].id), uint128(buyAmount));\n            remainingSrcAmount -= payAmount;\n        }\n\n        // must use all amount\n        require(remainingSrcAmount == 0, \"takeMatchingOrders: did not take all src amount\");\n\n        uint newReserveBalance = destToken.balanceOf(address(this));\n\n        require(newReserveBalance \u003e lastReserveBalance, \"takeMatchingOrders: newReserveBalance \u003c= lastReserveBalance\");\n\n        actualDestAmount = newReserveBalance - lastReserveBalance;\n    }\n\n    function shouldUseInternalInventory(\n        IERC20 token,\n        uint tokenVal,\n        uint ethVal,\n        bool ethToToken,\n        OfferData memory bid,\n        OfferData memory ask\n    )\n        internal view\n        returns(bool shouldUse, uint premiumBps)\n    {\n        shouldUse = false;\n        premiumBps = 0;\n\n        if (tokenVal \u003e MAX_QTY) { return (shouldUse, premiumBps); }\n\n        InternalInventoryData memory inventoryData = getInternalInventoryData(token);\n        if (!inventoryData.isEnabled) { return (shouldUse, premiumBps); }\n\n        premiumBps = inventoryData.premiumBps;\n\n        uint tokenBalance = token.balanceOf(address(this));\n\n        if (ethToToken) {\n            if (tokenBalance \u003c tokenVal) { return (shouldUse, premiumBps); }\n            if (tokenBalance - tokenVal \u003c inventoryData.minTokenBal) { return (shouldUse, premiumBps); }\n        } else {\n            if (address(this).balance \u003c ethVal) { return (shouldUse, premiumBps); }\n            if (tokenBalance + tokenVal \u003e inventoryData.maxTokenBal) { return (shouldUse, premiumBps); }\n        }\n\n        if (!checkValidSpread(bid, ask, true, inventoryData.minSpreadBps)) {\n            return (shouldUse, premiumBps);\n        }\n\n        shouldUse = true;\n    }\n\n    function applyInternalInventoryHintToRate(\n        uint rate,\n        bool useInternalInventory\n    )\n        internal pure\n        returns(uint)\n    {\n        return rate % 2 == (useInternalInventory ? 1 : 0)\n            ? rate\n            : rate - 1;\n    }\n\n    function valueAfterReducingFee(uint val) internal view returns(uint) {\n        require(val \u003c= MAX_QTY, \"valueAfterReducingFee: val \u003e MAX_QTY\");\n        return ((BPS - feeBps) * val) / BPS;\n    }\n\n    function valueAfterAddingPremium(uint val, uint premium) internal pure returns(uint) {\n        require(val \u003c= MAX_QTY, \"valueAfterAddingPremium: val \u003e MAX_QTY\");\n        return val * (BPS + premium) / BPS;\n    }\n\n    function findBestOffers(\n        IERC20 dstToken,\n        IERC20 srcToken,\n        uint srcAmount,\n        OfferData memory bid,\n        OfferData memory ask\n    )\n        internal view\n        returns(uint totalDestAmount, OfferData[] memory offers)\n    {\n        uint remainingSrcAmount = srcAmount;\n        uint maxOrdersToTake;\n        uint maxTraversedOrders;\n        uint minPayAmount;\n        uint numTakenOffer = 0;\n        totalDestAmount = 0;\n        IERC20 token = srcToken == wethToken ? dstToken : srcToken;\n\n        (maxOrdersToTake, maxTraversedOrders, minPayAmount) = calcOfferLimitsFromFactorData(\n            token,\n            (srcToken == wethToken),\n            bid,\n            ask,\n            srcAmount\n        );\n\n        offers = new OfferData[](maxTraversedOrders);\n\n        // return earlier, we don\u0027t want to take any orders\n        if (maxTraversedOrders == 0 || maxOrdersToTake == 0) {\n            return (totalDestAmount, offers);\n        }\n\n        // otc\u0027s terminology is of offer maker, so their sellGem is our (the taker\u0027s) dest token.\n        // if we don\u0027t have best offers, get them.\n        if ((srcToken == wethToken \u0026\u0026 bid.id == 0) || (dstToken == wethToken \u0026\u0026 ask.id == 0)) {\n            offers[0].id = otc.getBestOffer(dstToken, srcToken);\n            // assuming pay amount is taker pay amount. (in otc it is used differently)\n            (offers[0].buyAmount, , offers[0].payAmount, ) = otc.getOffer(offers[0].id);\n        } else {\n            offers[0] = srcToken == wethToken ? bid : ask;\n        }\n\n        uint thisOffer;\n\n        OfferData memory biggestSkippedOffer = OfferData(0, 0, 0);\n\n        for (; maxTraversedOrders \u003e 0; --maxTraversedOrders) {\n            thisOffer = numTakenOffer;\n\n            // in case both biggestSkippedOffer \u0026 current offer have amount \u003e= remainingSrcAmount\n            // biggestSkippedOffer should have better rate than current offer\n            if (biggestSkippedOffer.payAmount \u003e= remainingSrcAmount) {\n                offers[numTakenOffer].id = biggestSkippedOffer.id;\n                offers[numTakenOffer].buyAmount = remainingSrcAmount * biggestSkippedOffer.buyAmount / biggestSkippedOffer.payAmount;\n                offers[numTakenOffer].payAmount = remainingSrcAmount;\n                totalDestAmount += offers[numTakenOffer].buyAmount;\n                ++numTakenOffer;\n                remainingSrcAmount = 0;\n                break;\n            } else if (offers[numTakenOffer].payAmount \u003e= remainingSrcAmount) {\n                offers[numTakenOffer].buyAmount = remainingSrcAmount * offers[numTakenOffer].buyAmount / offers[numTakenOffer].payAmount;\n                offers[numTakenOffer].payAmount = remainingSrcAmount;\n                totalDestAmount += offers[numTakenOffer].buyAmount;\n                ++numTakenOffer;\n                remainingSrcAmount = 0;\n                break;\n            } else if ((maxOrdersToTake - numTakenOffer) \u003e 1\n                        \u0026\u0026 offers[numTakenOffer].payAmount \u003e= minPayAmount) {\n                totalDestAmount += offers[numTakenOffer].buyAmount;\n                remainingSrcAmount -= offers[numTakenOffer].payAmount;\n                ++numTakenOffer;\n            } else if (offers[numTakenOffer].payAmount \u003e biggestSkippedOffer.payAmount) {\n                biggestSkippedOffer.payAmount = offers[numTakenOffer].payAmount;\n                biggestSkippedOffer.buyAmount = offers[numTakenOffer].buyAmount;\n                biggestSkippedOffer.id = offers[numTakenOffer].id;\n            }\n\n            offers[numTakenOffer].id = otc.getWorseOffer(offers[thisOffer].id);\n            (offers[numTakenOffer].buyAmount, , offers[numTakenOffer].payAmount, ) = otc.getOffer(offers[numTakenOffer].id);\n        }\n\n        if (remainingSrcAmount \u003e 0) totalDestAmount = 0;\n        if (totalDestAmount == 0) offers = new OfferData[](0);\n    }\n\n    // returns max takes, max traverse, min order size to take using config factor data\n    function calcOfferLimitsFromFactorData(\n        IERC20 token,\n        bool isEthToToken,\n        OfferData memory bid,\n        OfferData memory ask, uint srcAmount\n    )\n        internal view\n        returns(uint maxTakes, uint maxTraverse, uint minPayAmount)\n    {\n        if (!isEthToToken \u0026\u0026 (ask.id == 0 || bid.id == 0)) {\n            // need to compute equivalent eth amount but no ask and bid offers are available\n            maxTakes = 0;\n            maxTraverse = 0;\n            minPayAmount = 0;\n            return (maxTakes, maxTraverse, minPayAmount);\n        }\n\n        uint order0Pay = 0;\n        uint order0Buy = 0;\n\n        if (!isEthToToken) {\n            // only need to use median when token -\u003e eth trade\n            order0Pay = ask.payAmount;\n            order0Buy = (ask.buyAmount + ask.payAmount * bid.payAmount / bid.buyAmount) / 2;\n        }\n\n        uint ethOrderSize = isEthToToken ? srcAmount : srcAmount * order0Buy / order0Pay;\n\n        BasicDataConfig memory basicData = getTokenBasicData(token);\n\n        if (basicData.minETHSupport \u003e ethOrderSize) {\n            maxTakes = 0;\n            maxTraverse = 0;\n            minPayAmount = 0;\n            return (maxTakes, maxTraverse, minPayAmount);\n        }\n\n        FactorDataConfig memory factorData = getFactorData(token);\n\n        uint tokenFactorBPS = 100000; // 10^5\n\n        maxTraverse = (factorData.maxTraverseX * ethOrderSize / PRECISION + factorData.maxTraverseY) / tokenFactorBPS;\n        maxTraverse = minOf(maxTraverse, basicData.maxTraverse);\n\n        maxTakes = (factorData.maxTakeX * ethOrderSize / PRECISION + factorData.maxTakeY) / tokenFactorBPS;\n        maxTakes = minOf(maxTakes, basicData.maxTakes);\n\n        uint minETHAmount = (factorData.minOrderSizeX * ethOrderSize + factorData.minOrderSizeY * PRECISION) / tokenFactorBPS;\n\n        // translate min amount to pay token\n        minPayAmount = isEthToToken ? minETHAmount : minETHAmount * order0Pay / order0Buy;\n    }\n\n    // bid: buy WETH, ask: sell WETH (their base token is DAI)\n    function getFirstBidAndAskOrders(IERC20 token)\n        internal view\n        returns(OfferData memory bid, OfferData memory ask)\n    {\n        // getting first bid offer (buy WETH)\n        (bid.id, bid.payAmount, bid.buyAmount) = getFirstOffer(token, wethToken);\n        // getting first ask offer (sell WETH)\n        (ask.id, ask.payAmount, ask.buyAmount) = getFirstOffer(wethToken, token);\n    }\n\n    function getFirstOffer(IERC20 offerSellGem, IERC20 offerBuyGem)\n        internal view\n        returns(uint offerId, uint offerPayAmount, uint offerBuyAmount)\n    {\n        offerId = otc.getBestOffer(offerSellGem, offerBuyGem);\n        (offerBuyAmount, , offerPayAmount, ) = otc.getOffer(offerId);\n    }\n\n    function checkValidSpread(OfferData memory bid, OfferData memory ask, bool isCheckingMinSpread, uint minSpreadBps)\n        internal pure\n        returns(bool)\n    {\n        // if no bid or ask order, consider as invalid spread?\n        if (bid.id == 0 || ask.id == 0 || bid.buyAmount \u003e MAX_QTY || bid.payAmount \u003e MAX_QTY || ask.buyAmount \u003e MAX_QTY || ask.payAmount \u003e MAX_QTY) {\n            return false;\n        }\n\n        uint x1 = ask.payAmount * bid.payAmount;\n        uint x2 = ask.buyAmount * bid.buyAmount;\n\n        // must check sellRate \u003e buyRate\n        if (x1 \u003c= x2) { return false; }\n\n        // if no need to check for min spread, return true here\n        if (!isCheckingMinSpread) { return true; }\n\n        // spread should be bigger than minSpreadBps\n        if (BPS * (x1 - x2) \u003c= x2 * minSpreadBps) { return false; }\n\n        return true;\n    }\n\n    function getTokenBasicData(IERC20 token)\n        internal view\n        returns(BasicDataConfig memory data)\n    {\n        (data.minETHSupport, data.maxTraverse, data.maxTakes) = decodeTokenBasicData(tokenBasicData[address(token)]);\n    }\n\n    function getFactorData(IERC20 token)\n        internal view\n        returns(FactorDataConfig memory data)\n    {\n        (data.maxTraverseX, data.maxTraverseY, data.maxTakeX, data.maxTakeY, data.minOrderSizeX, data.minOrderSizeY) = decodeFactorData(tokenFactorData[address(token)]);\n    }\n\n    function getInternalInventoryData(IERC20 token)\n        internal view\n        returns(InternalInventoryData memory data)\n    {\n        (bool isEnabled, uint minTokenBal, uint maxTokenBal, uint premiumBps, uint minSpreadBps) = decodeInternalInventoryData(internalInventoryData[address(token)]);\n        data.isEnabled = isEnabled;\n        data.minTokenBal = minTokenBal;\n        data.maxTokenBal = maxTokenBal;\n        data.premiumBps = premiumBps;\n        data.minSpreadBps = minSpreadBps;\n    }\n\n    function encodeInternalInventoryData(bool isEnabled, uint minTokenBal, uint maxTokenBal, uint premiumBps, uint minSpreadBps)\n        internal pure\n        returns(uint data)\n    {\n        require(minSpreadBps \u003c POW_2_32, \"encodeInternalInventoryData: minSpreadBps is too big\");\n        require(premiumBps \u003c POW_2_32, \"encodeInternalInventoryData: premiumBps is too big\");\n        require(maxTokenBal \u003c POW_2_96, \"encodeInternalInventoryData: maxTokenBal is too big\");\n        require(minTokenBal \u003c POW_2_96, \"encodeInternalInventoryData: minTokenBal is too big\");\n        data = minSpreadBps \u0026 (POW_2_32 - 1);\n        data |= (premiumBps \u0026 (POW_2_32 - 1)) * POW_2_32;\n        data |= (maxTokenBal \u0026 (POW_2_96 - 1)) * POW_2_32 * POW_2_32;\n        data |= (minTokenBal \u0026 (POW_2_96 / 2 - 1)) * POW_2_96 * POW_2_32 * POW_2_32;\n        data |= (isEnabled ? 1 : 0) * (POW_2_96 / 2) * POW_2_96 * POW_2_32 * POW_2_32;\n    }\n\n    function decodeInternalInventoryData(uint data)\n        internal pure\n        returns(bool isEnabled, uint minTokenBal, uint maxTokenBal, uint premiumBps, uint minSpreadBps)\n    {\n        minSpreadBps = data \u0026 (POW_2_32 - 1);\n        premiumBps = (data / POW_2_32) \u0026 (POW_2_32 - 1);\n        maxTokenBal = (data / (POW_2_32 * POW_2_32)) \u0026 (POW_2_96 - 1);\n        minTokenBal = (data / (POW_2_96 * POW_2_32 * POW_2_32)) \u0026 (POW_2_96 / 2 - 1);\n        isEnabled = (data / ((POW_2_96 / 2) * POW_2_96 * POW_2_32 * POW_2_32)) % 2 == 0 ? false : true;\n    }\n\n    function encodeTokenBasicData(uint ethSize, uint maxTraverse, uint maxTakes)\n        internal pure\n        returns(uint data)\n    {\n        require(maxTakes \u003c POW_2_32, \"encodeTokenBasicData: maxTakes is too big\");\n        require(maxTraverse \u003c POW_2_32, \"encodeTokenBasicData: maxTraverse is too big\");\n        require(ethSize \u003c POW_2_96, \"encodeTokenBasicData: ethSize is too big\");\n        data = maxTakes \u0026 (POW_2_32 - 1);\n        data |= (maxTraverse \u0026 (POW_2_32 - 1)) * POW_2_32;\n        data |= (ethSize \u0026 (POW_2_96 * POW_2_96 - 1)) * POW_2_32 * POW_2_32;\n    }\n\n    function decodeTokenBasicData(uint data)\n        internal pure\n        returns(uint ethSize, uint maxTraverse, uint maxTakes)\n    {\n        maxTakes = data \u0026 (POW_2_32 - 1);\n        maxTraverse = (data / POW_2_32) \u0026 (POW_2_32 - 1);\n        ethSize = (data / (POW_2_32 * POW_2_32)) \u0026 (POW_2_96 * POW_2_96 - 1);\n    }\n\n    function encodeFactorData(uint traverseX, uint traverseY, uint takeX, uint takeY, uint minSizeX, uint minSizeY)\n        internal pure\n        returns(uint data)\n    {\n        require(minSizeY \u003c POW_2_32, \"encodeFactorData: minSizeY is too big\");\n        require(minSizeX \u003c POW_2_32, \"encodeFactorData: minSizeX is too big\");\n        require(takeY \u003c POW_2_32, \"encodeFactorData: takeY is too big\");\n        require(takeX \u003c POW_2_32, \"encodeFactorData: takeX is too big\");\n        require(traverseY \u003c POW_2_32, \"encodeFactorData: traverseY is too big\");\n        require(traverseX \u003c POW_2_32, \"encodeFactorData: traverseX is too big\");\n        data = (minSizeY \u0026 (POW_2_32 - 1));\n        data |= (minSizeX \u0026 (POW_2_32 - 1)) * POW_2_32;\n        data |= (takeY \u0026 (POW_2_32 - 1)) * POW_2_32 * POW_2_32;\n        data |= (takeX \u0026 (POW_2_32 - 1)) * POW_2_96;\n        data |= (traverseY \u0026 (POW_2_32 - 1)) * POW_2_96 * POW_2_32;\n        data |= (traverseX \u0026 (POW_2_32 - 1)) * POW_2_96 * POW_2_32 * POW_2_32;\n    }\n\n    function decodeFactorData(uint data)\n        internal pure\n        returns(uint traverseX, uint traverseY, uint takeX, uint takeY, uint minSizeX, uint minSizeY)\n    {\n        minSizeY = data \u0026 (POW_2_32 - 1);\n        minSizeX = (data / POW_2_32) \u0026 (POW_2_32 - 1);\n        takeY = (data / (POW_2_32 * POW_2_32)) \u0026 (POW_2_32 - 1);\n        takeX = (data / POW_2_96) \u0026 (POW_2_32 - 1);\n        traverseY = (data / (POW_2_96 * POW_2_32)) \u0026 (POW_2_32 - 1);\n        traverseX = (data / (POW_2_96 * POW_2_32 * POW_2_32)) \u0026 (POW_2_32 - 1);\n    }\n}\n"},"IERC20.sol":{"content":"pragma solidity 0.5.11;\n\n\ninterface IERC20 {\n    function transfer(address _to, uint _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n    function approve(address _spender, uint _value) external returns (bool success);\n    function totalSupply() external view returns (uint supply);\n    function balanceOf(address _owner) external view returns (uint balance);\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\n    function decimals() external view returns(uint digits);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n"},"IKyberReserve.sol":{"content":"pragma solidity 0.5.11;\n\nimport \"./IERC20.sol\";\n\n\n/// @title Kyber Reserve contract\ninterface IKyberReserve {\n\n    function trade(\n        IERC20 srcToken,\n        uint srcAmount,\n        IERC20 destToken,\n        address payable destAddress,\n        uint conversionRate,\n        bool validate\n    )\n        external\n        payable\n        returns(bool);\n\n    function getConversionRate(IERC20 src, IERC20 dest, uint srcQty, uint blockNumber) external view returns(uint);\n}\n"},"IOtc.sol":{"content":"pragma solidity 0.5.11;\n\nimport \"./IERC20.sol\";\n\ncontract IOtc {\n    function getOffer(uint id) external view returns (uint, IERC20, uint, IERC20);\n    function getBestOffer(IERC20 sellGem, IERC20 buyGem) external view returns(uint);\n    function getWorseOffer(uint id) external view returns(uint);\n    function take(bytes32 id, uint128 maxTakeAmount) external;\n}\n"},"PermissionGroupsV5.sol":{"content":"pragma solidity 0.5.11;\n\n\ncontract PermissionGroups {\n\n    address public admin;\n    address public pendingAdmin;\n    mapping(address=\u003ebool) internal operators;\n    mapping(address=\u003ebool) internal alerters;\n    address[] internal operatorsGroup;\n    address[] internal alertersGroup;\n    uint constant internal MAX_GROUP_SIZE = 50;\n\n    constructor(address _admin) public {\n        require(_admin != address(0), \"Admin 0\");\n        admin = _admin;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(operators[msg.sender]);\n        _;\n    }\n\n    modifier onlyAlerter() {\n        require(alerters[msg.sender]);\n        _;\n    }\n\n    function getOperators () external view returns(address[] memory) {\n        return operatorsGroup;\n    }\n\n    function getAlerters () external view returns(address[] memory) {\n        return alertersGroup;\n    }\n\n    event TransferAdminPending(address pendingAdmin);\n\n    /**\n     * @dev Allows the current admin to set the pendingAdmin address.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdmin(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0));\n        emit TransferAdminPending(pendingAdmin);\n        pendingAdmin = newAdmin;\n    }\n\n    /**\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0));\n        emit TransferAdminPending(newAdmin);\n        emit AdminClaimed(newAdmin, admin);\n        admin = newAdmin;\n    }\n\n    event AdminClaimed( address newAdmin, address previousAdmin);\n\n    /**\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\n     */\n    function claimAdmin() public {\n        require(pendingAdmin == msg.sender);\n        emit AdminClaimed(pendingAdmin, admin);\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n    event AlerterAdded (address newAlerter, bool isAdd);\n\n    function addAlerter(address newAlerter) public onlyAdmin {\n        require(!alerters[newAlerter]); // prevent duplicates.\n        require(alertersGroup.length \u003c MAX_GROUP_SIZE);\n\n        emit AlerterAdded(newAlerter, true);\n        alerters[newAlerter] = true;\n        alertersGroup.push(newAlerter);\n    }\n\n    function removeAlerter (address alerter) public onlyAdmin {\n        require(alerters[alerter]);\n        alerters[alerter] = false;\n\n        for (uint i = 0; i \u003c alertersGroup.length; ++i) {\n            if (alertersGroup[i] == alerter) {\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\n                alertersGroup.length--;\n                emit AlerterAdded(alerter, false);\n                break;\n            }\n        }\n    }\n\n    event OperatorAdded(address newOperator, bool isAdd);\n\n    function addOperator(address newOperator) public onlyAdmin {\n        require(!operators[newOperator]); // prevent duplicates.\n        require(operatorsGroup.length \u003c MAX_GROUP_SIZE);\n\n        emit OperatorAdded(newOperator, true);\n        operators[newOperator] = true;\n        operatorsGroup.push(newOperator);\n    }\n\n    function removeOperator (address operator) public onlyAdmin {\n        require(operators[operator]);\n        operators[operator] = false;\n\n        for (uint i = 0; i \u003c operatorsGroup.length; ++i) {\n            if (operatorsGroup[i] == operator) {\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\n                operatorsGroup.length -= 1;\n                emit OperatorAdded(operator, false);\n                break;\n            }\n        }\n    }\n}\n"},"UtilsV5.sol":{"content":"pragma solidity 0.5.11;\n\nimport \"./IERC20.sol\";\n\n\n/// @title Kyber utils and utils2 contracts\ncontract Utils {\n\n    IERC20 constant internal ETH_TOKEN_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    uint  constant internal PRECISION = (10**18);\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\n    uint  constant internal MAX_DECIMALS = 18;\n    uint  constant internal ETH_DECIMALS = 18;\n\n    mapping(address=\u003euint) internal decimals;\n\n    /// @dev get the balance of a user.\n    /// @param token The token type\n    /// @return The balance\n    function getBalance(IERC20 token, address user) public view returns(uint) {\n        if (token == ETH_TOKEN_ADDRESS)\n            return user.balance;\n        else\n            return token.balanceOf(user);\n    }\n\n    function setDecimals(IERC20 token) internal {\n        if (token == ETH_TOKEN_ADDRESS)\n            decimals[address(token)] = ETH_DECIMALS;\n        else\n            decimals[address(token)] = token.decimals();\n    }\n\n    function getDecimals(IERC20 token) internal view returns(uint) {\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\n        uint tokenDecimals = decimals[address(token)];\n        // moreover, very possible that old tokens have decimals 0\n        // these tokens will just have higher gas fees.\n        if (tokenDecimals == 0) return token.decimals();\n\n        return tokenDecimals;\n    }\n\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\n        require(srcQty \u003c= MAX_QTY);\n        require(rate \u003c= MAX_RATE);\n\n        if (dstDecimals \u003e= srcDecimals) {\n            require((dstDecimals - srcDecimals) \u003c= MAX_DECIMALS);\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\n        } else {\n            require((srcDecimals - dstDecimals) \u003c= MAX_DECIMALS);\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\n        }\n    }\n\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\n        require(dstQty \u003c= MAX_QTY);\n        require(rate \u003c= MAX_RATE);\n\n        //source quantity is rounded up. to avoid dest quantity being too low.\n        uint numerator;\n        uint denominator;\n        if (srcDecimals \u003e= dstDecimals) {\n            require((srcDecimals - dstDecimals) \u003c= MAX_DECIMALS);\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\n            denominator = rate;\n        } else {\n            require((dstDecimals - srcDecimals) \u003c= MAX_DECIMALS);\n            numerator = (PRECISION * dstQty);\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\n        }\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\n    }\n\n    function calcDestAmount(IERC20 src, IERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\n    }\n\n    function calcSrcAmount(IERC20 src, IERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\n    }\n\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\n        internal pure returns(uint)\n    {\n        require(srcAmount \u003c= MAX_QTY);\n        require(destAmount \u003c= MAX_QTY);\n\n        if (dstDecimals \u003e= srcDecimals) {\n            require((dstDecimals - srcDecimals) \u003c= MAX_DECIMALS);\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\n        } else {\n            require((srcDecimals - dstDecimals) \u003c= MAX_DECIMALS);\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\n        }\n    }\n\n    function minOf(uint x, uint y) internal pure returns(uint) {\n        return x \u003e y ? y : x;\n    }\n}\n"},"WithdrawableV5.sol":{"content":"pragma solidity 0.5.11;\n\nimport \"./IERC20.sol\";\nimport \"./PermissionGroupsV5.sol\";\n\n\ncontract Withdrawable is PermissionGroups {\n\n    constructor(address _admin) public \n        PermissionGroups(_admin) \n        {}\n        \n    event TokenWithdraw(IERC20 token, uint amount, address sendTo);\n\n    /**\n     * @dev Withdraw all IERC20 compatible tokens\n     * @param token IERC20 The address of the token contract\n     */\n    function withdrawToken(IERC20 token, uint amount, address sendTo) external onlyAdmin {\n        require(token.transfer(sendTo, amount));\n        emit TokenWithdraw(token, amount, sendTo);\n    }\n\n    event EtherWithdraw(uint amount, address sendTo);\n\n    /**\n     * @dev Withdraw Ethers\n     */\n    function withdrawEther(uint amount, address payable sendTo) external onlyAdmin {\n        sendTo.transfer(amount);\n        emit EtherWithdraw(amount, sendTo);\n    }\n}\n"}}