{{
  "language": "Solidity",
  "settings": {
    "remappings": [
      "main=./src"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "istanbul",
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "./src/dependencies/DSAuth.sol": {
      "content": "/// @notice Modified from DappHub (https://git.io/fpwrq)\n\npragma solidity 0.6.1;\n\nabstract contract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view virtual returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n"
    },
    "./src/dependencies/DSGuard.sol": {
      "content": "/// @notice Retrieved from DappHub (https://git.io/fpwMi)\n\npragma solidity 0.6.1;\n\nimport \"./DSAuth.sol\";\n\ncontract DSGuardEvents {\n    event LogPermit(\n        bytes32 indexed src,\n        bytes32 indexed dst,\n        bytes32 indexed sig\n    );\n\n    event LogForbid(\n        bytes32 indexed src,\n        bytes32 indexed dst,\n        bytes32 indexed sig\n    );\n}\n\ncontract DSGuard is DSAuth, DSAuthority, DSGuardEvents {\n    bytes32 constant public ANY = bytes32(uint(-1));\n\n    mapping (bytes32 => mapping (bytes32 => mapping (bytes32 => bool))) acl;\n\n    function canCall(\n        address src_, address dst_, bytes4 sig\n    ) public view override returns (bool) {\n        bytes32 src = bytes32(bytes20(src_));\n        bytes32 dst = bytes32(bytes20(dst_));\n\n        return acl[src][dst][sig]\n            || acl[src][dst][ANY]\n            || acl[src][ANY][sig]\n            || acl[src][ANY][ANY]\n            || acl[ANY][dst][sig]\n            || acl[ANY][dst][ANY]\n            || acl[ANY][ANY][sig]\n            || acl[ANY][ANY][ANY];\n    }\n\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public auth {\n        acl[src][dst][sig] = true;\n        emit LogPermit(src, dst, sig);\n    }\n\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public auth {\n        acl[src][dst][sig] = false;\n        emit LogForbid(src, dst, sig);\n    }\n\n    function permit(address src, address dst, bytes32 sig) public {\n        permit(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\n    }\n    function forbid(address src, address dst, bytes32 sig) public {\n        forbid(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\n    }\n\n}\n\ncontract DSGuardFactory {\n    mapping (address => bool)  public  isGuard;\n\n    function newGuard() public returns (DSGuard guard) {\n        guard = new DSGuard();\n        guard.setOwner(msg.sender);\n        isGuard[address(guard)] = true;\n    }\n}\n"
    },
    "./src/dependencies/DSMath.sol": {
      "content": "/// DSMath.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >0.4.13;\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n"
    },
    "./src/dependencies/SafeMath.sol": {
      "content": "pragma solidity 0.6.1;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    uint256 c = _a * _b;\n    require(c / _a == _b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    require(_b <= _a);\n    uint256 c = _a - _b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    uint256 c = _a + _b;\n    require(c >= _a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n"
    },
    "./src/dependencies/token/BurnableToken.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"./PreminedToken.sol\";\n\n/// @dev Just a wrapper for premined tokens which can actually be burnt\ncontract BurnableToken is PreminedToken {\n    constructor(string memory _symbol, uint8 _decimals, string memory _name)\n        public\n        PreminedToken(_symbol, _decimals, _name)\n    {}\n\n    function burn(uint _amount) public {\n        _burn(msg.sender, _amount);\n    }\n\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\n}\n\n"
    },
    "./src/dependencies/token/IERC20.sol": {
      "content": "pragma solidity 0.6.1;\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n * Altered from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a466e76d26c394b1faa6e2797aefe34668566392/contracts/token/ERC20/ERC20.sol\n */\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address _who) external view returns (uint256);\n\n  function allowance(address _owner, address _spender)\n    external view returns (uint256);\n\n  function transfer(address _to, uint256 _value) external returns (bool);\n\n  function approve(address _spender, uint256 _value) external returns (bool);\n\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n/// @dev Just adds extra functions that we use elsewhere\nabstract contract ERC20WithFields is IERC20 {\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n}\n"
    },
    "./src/dependencies/token/PreminedToken.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"./StandardToken.sol\";\n\ncontract PreminedToken is StandardToken {\n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n\n    constructor(string memory _symbol, uint8 _decimals, string memory _name) public {\n        symbol = _symbol;\n        decimals = _decimals;\n        name = _name;\n        totalSupply_ = 1000000 * 10**uint(decimals);\n        balances[msg.sender] = totalSupply_;\n        emit Transfer(address(0), msg.sender, totalSupply_);\n    }\n}\n\n"
    },
    "./src/dependencies/token/StandardToken.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"./IERC20.sol\";\nimport \"../SafeMath.sol\";\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n * Modified from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a466e76d26c394b1faa6e2797aefe34668566392/contracts/token/ERC20/StandardToken.sol\n */\ncontract StandardToken is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) balances;\n\n    mapping (address => mapping (address => uint256)) allowed;\n\n    uint256 totalSupply_;\n\n    /**\n     * @dev Total number of tokens in existence\n     */\n    function totalSupply() public view override returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view override returns (uint256) {\n        return balances[_owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param _owner address The address which owns the funds.\n     * @param _spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _value The amount to be transferred.\n    */\n    function transfer(address _to, uint256 _value) public virtual override returns (bool) {\n        require(_value <= balances[msg.sender]);\n        require(_to != address(0));\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds.\n        * @param _value The amount of tokens to be spent.\n        */\n    function approve(address _spender, uint256 _value) public virtual override returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n    * @dev Transfer tokens from one address to another\n    * @param _from address The address which you want to send tokens from\n    * @param _to address The address which you want to transfer to\n    * @param _value uint256 the amount of tokens to be transferred\n    */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n        require(_to != address(0));\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Approval(_from, msg.sender, allowed[_from][msg.sender]);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To increment\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _addedValue The amount of tokens to increase the allowance by.\n    */\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        virtual\n        returns (bool)\n    {\n        allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue >= oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n    * @dev Internal function that mints an amount of the token and assigns it to\n    * an account. This encapsulates the modification of balances such that the\n    * proper events are emitted.\n    * @param _account The account that will receive the created tokens.\n    * @param _amount The amount that will be created.\n     */\n    function _mint(address _account, uint256 _amount) internal {\n        require(_account != address(0));\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_account] = balances[_account].add(_amount);\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param _account The account whose tokens will be burnt.\n     * @param _amount The amount that will be burnt.\n     */\n    function _burn(address _account, uint256 _amount) internal {\n        require(_account != address(0));\n        require(_amount <= balances[_account]);\n\n        totalSupply_ = totalSupply_.sub(_amount);\n        balances[_account] = balances[_account].sub(_amount);\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal _burn function.\n     * @param _account The account whose tokens will be burnt.\n     * @param _amount The amount that will be burnt.\n     */\n    function _burnFrom(address _account, uint256 _amount) internal {\n        require(_amount <= allowed[_account][msg.sender]);\n        allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\n        emit Approval(_account, msg.sender, allowed[_account][msg.sender]);\n        _burn(_account, _amount);\n    }\n}\n"
    },
    "./src/dependencies/TokenUser.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"./token/IERC20.sol\";\nimport \"./DSMath.sol\";\n\n/// @notice Wrapper to ensure tokens are received\ncontract TokenUser is DSMath {\n    function safeTransfer(\n        address _token,\n        address _to,\n        uint _value\n    ) internal {\n        uint receiverPreBalance = IERC20(_token).balanceOf(_to);\n        IERC20(_token).transfer(_to, _value);\n        uint receiverPostBalance = IERC20(_token).balanceOf(_to);\n        require(\n            add(receiverPreBalance, _value) == receiverPostBalance,\n            \"Receiver did not receive tokens in transfer\"\n        );\n    }\n\n    function safeTransferFrom(\n        address _token,\n        address _from,\n        address _to,\n        uint _value\n    ) internal {\n        uint receiverPreBalance = IERC20(_token).balanceOf(_to);\n        IERC20(_token).transferFrom(_from, _to, _value);\n        uint receiverPostBalance = IERC20(_token).balanceOf(_to);\n        require(\n            add(receiverPreBalance, _value) == receiverPostBalance,\n            \"Receiver did not receive tokens in transferFrom\"\n        );\n    }\n}\n"
    },
    "./src/dependencies/WETH.sol": {
      "content": "pragma solidity 0.6.1;\n\ncontract WETH {\n    string public name     = \"Wrapped Ether\";\n    string public symbol   = \"WETH\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n\n    receive() external payable {\n        deposit();\n    }\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        msg.sender.transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n\n"
    },
    "./src/engine/AmguConsumer.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"../dependencies/DSMath.sol\";\nimport \"../dependencies/token/IERC20.sol\";\nimport \"../prices/IPriceSource.sol\";\nimport \"../version/IVersion.sol\";\nimport \"./IEngine.sol\";\nimport \"../version/Registry.sol\";\n\n/// @notice Abstract contracts\n/// @notice inherit this to pay AMGU on a function call\nabstract contract AmguConsumer is DSMath {\n\n    /// @dev each of these must be implemented by the inheriting contract\n    function engine() public view virtual returns (address);\n    function mlnToken() public view virtual returns (address);\n    function priceSource() public view virtual returns (address);\n    function registry() public view virtual returns (address);\n    event AmguPaid(address indexed payer, uint256 totalAmguPaidInEth, uint256 amguChargableGas, uint256 incentivePaid);\n\n    /// bool deductIncentive is used when sending extra eth beyond amgu\n    modifier amguPayable(bool deductIncentive) {\n        uint preGas = gasleft();\n        _;\n        uint postGas = gasleft();\n\n        uint mlnPerAmgu = IEngine(engine()).getAmguPrice();\n        uint mlnQuantity = mul(\n            mlnPerAmgu,\n            sub(preGas, postGas)\n        );\n        address nativeAsset = Registry(registry()).nativeAsset();\n        uint ethToPay = IPriceSource(priceSource()).convertQuantity(\n            mlnQuantity,\n            mlnToken(),\n            nativeAsset\n        );\n        uint incentiveAmount;\n        if (deductIncentive) {\n            incentiveAmount = Registry(registry()).incentive();\n        } else {\n            incentiveAmount = 0;\n        }\n        require(\n            msg.value >= add(ethToPay, incentiveAmount),\n            \"Insufficent AMGU and/or incentive\"\n        );\n        IEngine(engine()).payAmguInEther.value(ethToPay)();\n\n        require(\n            msg.sender.send(\n                sub(\n                    sub(msg.value, ethToPay),\n                    incentiveAmount\n                )\n            ),\n            \"Refund failed\"\n        );\n        emit AmguPaid(msg.sender, ethToPay, sub(preGas, postGas), incentiveAmount);\n    }\n}\n"
    },
    "./src/engine/Engine.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"../dependencies/DSMath.sol\";\nimport \"../dependencies/token/BurnableToken.sol\";\nimport \"../prices/IPriceSource.sol\";\nimport \"../version/Registry.sol\";\n\n/// @notice Liquidity contract and token sink\ncontract Engine is DSMath {\n\n    event RegistryChange(address registry);\n    event SetAmguPrice(uint amguPrice);\n    event AmguPaid(uint amount);\n    event Thaw(uint amount);\n    event Burn(uint amount);\n\n    uint public constant MLN_DECIMALS = 18;\n\n    Registry public registry;\n    uint public amguPrice;\n    uint public frozenEther;\n    uint public liquidEther;\n    uint public lastThaw;\n    uint public thawingDelay;\n    uint public totalEtherConsumed;\n    uint public totalAmguConsumed;\n    uint public totalMlnBurned;\n\n    constructor(uint _delay, address _registry) public {\n        lastThaw = block.timestamp;\n        thawingDelay = _delay;\n        _setRegistry(_registry);\n    }\n\n    modifier onlyMGM() {\n        require(\n            msg.sender == registry.MGM(),\n            \"Only MGM can call this\"\n        );\n        _;\n    }\n\n    /// @dev Registry owner is MTC\n    modifier onlyMTC() {\n        require(\n            msg.sender == registry.owner(),\n            \"Only MTC can call this\"\n        );\n        _;\n    }\n\n    function _setRegistry(address _registry) internal {\n        registry = Registry(_registry);\n        emit RegistryChange(address(registry));\n    }\n\n    /// @dev only callable by MTC\n    function setRegistry(address _registry)\n        external\n        onlyMTC\n    {\n        _setRegistry(_registry);\n    }\n\n    /// @dev set price of AMGU in MLN (base units)\n    /// @dev only callable by MGM\n    function setAmguPrice(uint _price)\n        external\n        onlyMGM\n    {\n        amguPrice = _price;\n        emit SetAmguPrice(_price);\n    }\n\n    function getAmguPrice() public view returns (uint) { return amguPrice; }\n\n    function premiumPercent() public view returns (uint) {\n        if (liquidEther < 1 ether) {\n            return 0;\n        } else if (liquidEther >= 1 ether && liquidEther < 5 ether) {\n            return 5;\n        } else if (liquidEther >= 5 ether && liquidEther < 10 ether) {\n            return 10;\n        } else if (liquidEther >= 10 ether) {\n            return 15;\n        }\n    }\n\n    function payAmguInEther() external payable {\n        require(\n            registry.isFundFactory(msg.sender) ||\n            registry.isFund(msg.sender),\n            \"Sender must be a fund or the factory\"\n        );\n        uint mlnPerAmgu = getAmguPrice();\n        uint ethPerMln;\n        (ethPerMln,) = priceSource().getPrice(address(mlnToken()));\n        uint amguConsumed;\n        if (mlnPerAmgu > 0 && ethPerMln > 0) {\n            amguConsumed = (mul(msg.value, 10 ** uint(MLN_DECIMALS))) / (mul(ethPerMln, mlnPerAmgu));\n        } else {\n            amguConsumed = 0;\n        }\n        totalEtherConsumed = add(totalEtherConsumed, msg.value);\n        totalAmguConsumed = add(totalAmguConsumed, amguConsumed);\n        frozenEther = add(frozenEther, msg.value);\n        emit AmguPaid(amguConsumed);\n    }\n\n    /// @notice Move frozen ether to liquid pool after delay\n    /// @dev Delay only restarts when this function is called\n    function thaw() external {\n        require(\n            block.timestamp >= add(lastThaw, thawingDelay),\n            \"Thawing delay has not passed\"\n        );\n        require(frozenEther > 0, \"No frozen ether to thaw\");\n        lastThaw = block.timestamp;\n        liquidEther = add(liquidEther, frozenEther);\n        emit Thaw(frozenEther);\n        frozenEther = 0;\n    }\n\n    /// @return ETH per MLN including premium\n    function enginePrice() public view returns (uint) {\n        uint ethPerMln;\n        (ethPerMln, ) = priceSource().getPrice(address(mlnToken()));\n        uint premium = (mul(ethPerMln, premiumPercent()) / 100);\n        return add(ethPerMln, premium);\n    }\n\n    function ethPayoutForMlnAmount(uint mlnAmount) public view returns (uint) {\n        return mul(mlnAmount, enginePrice()) / 10 ** uint(MLN_DECIMALS);\n    }\n\n    /// @notice MLN must be approved first\n    function sellAndBurnMln(uint mlnAmount) external {\n        require(registry.isFund(msg.sender), \"Only funds can use the engine\");\n        require(\n            mlnToken().transferFrom(msg.sender, address(this), mlnAmount),\n            \"MLN transferFrom failed\"\n        );\n        uint ethToSend = ethPayoutForMlnAmount(mlnAmount);\n        require(ethToSend > 0, \"No ether to pay out\");\n        require(liquidEther >= ethToSend, \"Not enough liquid ether to send\");\n        liquidEther = sub(liquidEther, ethToSend);\n        totalMlnBurned = add(totalMlnBurned, mlnAmount);\n        msg.sender.transfer(ethToSend);\n        mlnToken().burn(mlnAmount);\n        emit Burn(mlnAmount);\n    }\n\n    /// @dev Get MLN from the registry\n    function mlnToken()\n        public\n        view\n        returns (BurnableToken)\n    {\n        return BurnableToken(registry.mlnToken());\n    }\n\n    /// @dev Get PriceSource from the registry\n    function priceSource()\n        public\n        view\n        returns (IPriceSource)\n    {\n        return IPriceSource(registry.priceSource());\n    }\n}\n\n"
    },
    "./src/engine/IEngine.sol": {
      "content": "pragma solidity 0.6.1;\n\n\ninterface IEngine {\n    function payAmguInEther() external payable;\n    function getAmguPrice() external view returns (uint256);\n}\n"
    },
    "./src/exchanges/EngineAdapter.sol": {
      "content": "pragma solidity 0.6.1;\npragma experimental ABIEncoderV2;\n\nimport \"../engine/Engine.sol\";\nimport \"../fund/hub/Hub.sol\";\nimport \"../fund/trading/Trading.sol\";\nimport \"../fund/vault/Vault.sol\";\nimport \"../dependencies/DSMath.sol\";\nimport \"../dependencies/WETH.sol\";\nimport \"../dependencies/token/IERC20.sol\";\nimport \"./ExchangeAdapter.sol\";\nimport \"../dependencies/TokenUser.sol\";\n\n/// @notice Trading adapter to Melon Engine\ncontract EngineAdapter is DSMath, TokenUser, ExchangeAdapter {\n\n    /// @notice Buys Ether from the engine, selling MLN\n    /// @param targetExchange Address of the engine\n    /// @param orderValues [0] Min Eth to receive from the engine\n    /// @param orderValues [1] MLN quantity\n    /// @param orderValues [6] Same as orderValues[1]\n    /// @param orderAddresses [2] WETH token\n    /// @param orderAddresses [3] MLN token\n    function takeOrder (\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public override onlyManager notShutDown {\n        Hub hub = getHub();\n\n        address wethAddress = orderAddresses[2];\n        address mlnAddress = orderAddresses[3];\n        uint minEthToReceive = orderValues[0];\n        uint mlnQuantity = orderValues[1];\n\n        require(\n            wethAddress == Registry(hub.registry()).nativeAsset(),\n            \"maker asset doesnt match nativeAsset on registry\"\n        );\n        require(\n            orderValues[1] == orderValues[6],\n            \"fillTakerQuantity must equal takerAssetQuantity\"\n        );\n\n        withdrawAndApproveAsset(mlnAddress, targetExchange, mlnQuantity, \"takerAsset\");\n\n        uint ethToReceive = Engine(targetExchange).ethPayoutForMlnAmount(mlnQuantity);\n\n        require(\n            ethToReceive >= minEthToReceive,\n            \"Expected ETH to receive is less than takerQuantity (minEthToReceive)\"\n        );\n\n        Engine(targetExchange).sellAndBurnMln(mlnQuantity);\n        WETH(payable(wethAddress)).deposit.value(ethToReceive)();\n        safeTransfer(wethAddress, address(Vault(hub.vault())), ethToReceive);\n\n        getAccounting().addAssetToOwnedAssets(wethAddress);\n        getAccounting().updateOwnedAssets();\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(0),\n            Trading.UpdateType.take,\n            [payable(wethAddress), payable(mlnAddress)],\n            [ethToReceive, mlnQuantity, mlnQuantity]\n        );\n    }\n}\n"
    },
    "./src/exchanges/EthfinexAdapter.sol": {
      "content": "pragma solidity 0.6.1;\npragma experimental ABIEncoderV2;\n\nimport \"../dependencies/token/IERC20.sol\";\nimport \"../fund/trading/Trading.sol\";\nimport \"../fund/hub/Hub.sol\";\nimport \"../fund/vault/Vault.sol\";\nimport \"../fund/accounting/Accounting.sol\";\nimport \"../version/Registry.sol\";\nimport \"../dependencies/WETH.sol\";\nimport \"../dependencies/DSMath.sol\";\nimport \"./interfaces/IZeroExV2.sol\";\nimport \"./interfaces/IEthfinex.sol\";\nimport \"./ExchangeAdapter.sol\";\n\n/// @title EthfinexAdapter Contract\n/// @author Melonport AG <team@melonport.com>\n/// @notice Adapter to EthFinex exchange\ncontract EthfinexAdapter is DSMath, ExchangeAdapter {\n    /// @param _orderAddresses [2] Order maker asset\n    /// @param _orderAddresses [3] Order taker asset\n    /// @param _orderData [0] Encoded data specific to maker asset\n    /// @param _orderData [1] Encoded data specific to taker asset\n    modifier orderAddressesMatchOrderData(\n        address[8] memory _orderAddresses,\n        bytes[4] memory _orderData\n    )\n    {\n        require(\n            getAssetAddress(_orderData[0]) == getWrapperToken(_orderAddresses[2]),\n            \"Maker asset data does not match order address in array\"\n        );\n        require(\n            getAssetAddress(_orderData[1]) == _orderAddresses[3],\n            \"Taker asset data does not match order address in array\"\n        );\n        _;\n    }\n\n    //  METHODS\n\n    //  PUBLIC METHODS\n\n    /// @notice Make order by pre-approving signatures\n    function makeOrder(\n        address _targetExchange,\n        address[8] memory _orderAddresses,\n        uint[8] memory _orderValues,\n        bytes[4] memory _orderData,\n        bytes32 _identifier,\n        bytes memory _signature\n    )\n        public\n        override\n        onlyManager\n        notShutDown\n        orderAddressesMatchOrderData(_orderAddresses, _orderData)\n    {\n        ensureCanMakeOrder(_orderAddresses[2]);\n\n        IZeroExV2.Order memory order = constructOrderStruct(_orderAddresses, _orderValues, _orderData);\n        bytes memory wrappedMakerAssetData = _orderData[0];\n        bytes memory takerAssetData = _orderData[1];\n        address makerAsset = _orderAddresses[2];\n        address takerAsset = getAssetAddress(takerAssetData);\n\n        // Order parameter checks\n        getTrading().updateAndGetQuantityBeingTraded(makerAsset);\n        ensureNotInOpenMakeOrder(makerAsset);\n\n        wrapMakerAsset(_targetExchange, makerAsset, wrappedMakerAssetData, order.makerAssetAmount, order.expirationTimeSeconds);\n\n        IZeroExV2.OrderInfo memory orderInfo = IZeroExV2(_targetExchange).getOrderInfo(order);\n        IZeroExV2(_targetExchange).preSign(orderInfo.orderHash, address(this), _signature);\n\n        require(\n            IZeroExV2(_targetExchange).isValidSignature(\n                orderInfo.orderHash,\n                address(this),\n                _signature\n            ),\n            \"INVALID_ORDER_SIGNATURE\"\n        );\n\n        updateStateMakeOrder(_targetExchange, order);\n    }\n\n    /// @notice Cancel the 0x make order\n    function cancelOrder(\n        address _targetExchange,\n        address[8] memory _orderAddresses,\n        uint[8] memory _orderValues,\n        bytes[4] memory _orderData,\n        bytes32 _identifier,\n        bytes memory _signature\n    )\n        public\n        override\n        orderAddressesMatchOrderData(_orderAddresses, _orderData)\n    {\n        IZeroExV2.Order memory order = getTrading().getZeroExV2OrderDetails(_identifier);\n        ensureCancelPermitted(_targetExchange, getAssetAddress(order.makerAssetData));\n        IZeroExV2(_targetExchange).cancelOrder(order);\n\n        updateStateCancelOrder(_targetExchange, order);\n    }\n\n    /// @notice Unwrap (withdraw) tokens, uses _orderAddresses for input list of tokens to be unwrapped\n    /// @dev Call to \"withdraw\" fails if timestamp < `Wrapper.depositLock(tradingComponent)`\n    function withdrawTokens(\n        address _targetExchange,\n        address[8] memory _orderAddresses,\n        uint[8] memory _orderValues,\n        bytes[4] memory _orderData,\n        bytes32 _identifier,\n        bytes memory _signature\n    )\n        public\n    {\n        Hub hub = getHub();\n        address nativeAsset = Accounting(hub.accounting()).NATIVE_ASSET();\n\n        for (uint i = 0; i < _orderAddresses.length; i++) {\n            if (_orderAddresses[i] == address(0)) continue;\n            address wrappedToken = getWrapperToken(_orderAddresses[i]);\n            uint balance = IWrapperLock(wrappedToken).balanceOf(address(this));\n            require(balance > 0, \"Insufficient balance\");\n            IWrapperLock(wrappedToken).withdraw(balance, 0, bytes32(0), bytes32(0), 0);\n            if (_orderAddresses[i] == nativeAsset) {\n                WETH(payable(nativeAsset)).deposit.value(balance)();\n            }\n            getTrading().removeOpenMakeOrder(_targetExchange, _orderAddresses[i]);\n            getTrading().returnAssetToVault(_orderAddresses[i]);\n        }\n    }\n\n     /// @notice Minor: Wrapped tokens directly sent to the fund are not accounted. To be called by Trading spoke\n    function getOrder(address _targetExchange, uint256 _id, address _makerAsset)\n        public\n        view\n        override\n        returns (address, address, uint256, uint256)\n    {\n        uint orderId;\n        uint orderIndex;\n        address takerAsset;\n        uint makerQuantity;\n        uint takerQuantity;\n        (orderId, , orderIndex) = Trading(msg.sender).getOpenOrderInfo(_targetExchange, _makerAsset);\n        (, takerAsset, makerQuantity, takerQuantity) = Trading(msg.sender).getOrderDetails(orderIndex);\n\n        // Check if order has been completely filled\n        uint takerAssetFilledAmount = IZeroExV2(_targetExchange).filled(bytes32(orderId));\n        if (sub(takerQuantity, takerAssetFilledAmount) == 0) {\n            return (_makerAsset, takerAsset, 0, 0);\n        }\n\n        // Check if tokens have been withdrawn (cancelled order may still need to be accounted if there is balance)\n        uint balance = IWrapperLock(getWrapperTokenFromAdapterContext(_makerAsset)).balanceOf(msg.sender);\n        if (balance == 0) {\n            return (_makerAsset, takerAsset, 0, 0);\n        }\n        return (_makerAsset, takerAsset, makerQuantity, sub(takerQuantity, takerAssetFilledAmount));\n    }\n\n    // INTERNAL METHODS\n\n    /// @notice needed to avoid stack too deep error\n    /// @dev deposit time should be greater than 1 hour\n    function wrapMakerAsset(\n        address _targetExchange,\n        address _makerAsset,\n        bytes memory _wrappedMakerAssetData,\n        uint _makerQuantity,\n        uint _orderExpirationTime\n    )\n        internal\n    {\n        Hub hub = getHub();\n\n        // Deposit to rounded up value of time difference of expiration time and current time (in hours)\n        uint depositTime = (\n            sub(_orderExpirationTime, block.timestamp) / 1 hours\n        ) + 1;\n\n        address nativeAsset = Accounting(hub.accounting()).NATIVE_ASSET();\n        address wrappedToken = getWrapperToken(_makerAsset);\n        // Handle case for WETH vs ERC20\n        if (_makerAsset == nativeAsset) {\n            Vault vault = Vault(hub.vault());\n            vault.withdraw(_makerAsset, _makerQuantity);\n            WETH(payable(nativeAsset)).withdraw(_makerQuantity);\n            IWrapperLockEth(wrappedToken).deposit.value(_makerQuantity)(_makerQuantity, depositTime);\n        } else {\n            withdrawAndApproveAsset(\n                _makerAsset,\n                wrappedToken,\n                _makerQuantity,\n                \"makerAsset\"\n            );\n            IWrapperLock(wrappedToken).deposit(_makerQuantity, depositTime);\n        }\n    }\n\n    // @dev avoids stack too deep error\n    function updateStateCancelOrder(address _targetExchange, IZeroExV2.Order memory _order)\n        internal\n    {\n        // Order is not removed from OpenMakeOrder mapping as it's needed for accounting (wrapped tokens)\n        getAccounting().updateOwnedAssets();\n        getTrading().orderUpdateHook(\n            _targetExchange,\n            IZeroExV2(_targetExchange).getOrderInfo(_order).orderHash,\n            Trading.UpdateType.cancel,\n            [address(0), address(0)],\n            [uint(0), uint(0), uint(0)]\n        );\n    }\n\n    // @dev avoids stack too deep error\n    function updateStateMakeOrder(address _targetExchange, IZeroExV2.Order memory _order)\n        internal\n    {\n        address wrapperRegistry = Registry(getTrading().registry()).ethfinexWrapperRegistry();\n        address wrappedMakerAsset = getAssetAddress(_order.makerAssetData);\n        address makerAsset = IWrapperRegistryEFX(\n            wrapperRegistry\n        ).wrapper2TokenLookup(wrappedMakerAsset);\n        address takerAsset = getAssetAddress(_order.takerAssetData);\n        IZeroExV2.OrderInfo memory orderInfo = IZeroExV2(_targetExchange).getOrderInfo(_order);\n\n        getAccounting().addAssetToOwnedAssets(takerAsset);\n        getTrading().orderUpdateHook(\n            _targetExchange,\n            orderInfo.orderHash,\n            Trading.UpdateType.make,\n            [payable(makerAsset), payable(takerAsset)],\n            [_order.makerAssetAmount, _order.takerAssetAmount, uint(0)]\n        );\n        getTrading().addOpenMakeOrder(\n            _targetExchange,\n            makerAsset,\n            takerAsset,\n            uint256(orderInfo.orderHash),\n            _order.expirationTimeSeconds\n        );\n        getTrading().addZeroExV2OrderData(orderInfo.orderHash, _order);\n    }\n\n    // VIEW METHODS\n\n    function constructOrderStruct(\n        address[8] memory _orderAddresses,\n        uint[8] memory _orderValues,\n        bytes[4] memory _orderData\n    )\n        internal\n        view\n        returns (IZeroExV2.Order memory _order)\n    {\n        _order = IZeroExV2.Order({\n            makerAddress: _orderAddresses[0],\n            takerAddress: _orderAddresses[1],\n            feeRecipientAddress: _orderAddresses[4],\n            senderAddress: _orderAddresses[5],\n            makerAssetAmount: _orderValues[0],\n            takerAssetAmount: _orderValues[1],\n            makerFee: _orderValues[2],\n            takerFee: _orderValues[3],\n            expirationTimeSeconds: _orderValues[4],\n            salt: _orderValues[5],\n            makerAssetData: _orderData[0],\n            takerAssetData: _orderData[1]\n        });\n    }\n\n    function getAssetProxy(address _targetExchange, bytes memory _assetData)\n        internal\n        view\n        returns (address assetProxy_)\n    {\n        bytes4 assetProxyId;\n        assembly {\n            assetProxyId := and(mload(\n                add(_assetData, 32)),\n                0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n            )\n        }\n        assetProxy_ = IZeroExV2(_targetExchange).getAssetProxy(assetProxyId);\n    }\n\n    function getAssetAddress(bytes memory _assetData)\n        internal\n        view\n        returns (address assetAddress_)\n    {\n        assembly {\n            assetAddress_ := mload(add(_assetData, 36))\n        }\n    }\n\n    /// @dev Function to be called from Trading spoke context (Delegate call)\n    function getWrapperToken(address _token)\n        internal\n        view\n        returns (address)\n    {\n        address wrapperRegistry = Registry(getTrading().registry()).ethfinexWrapperRegistry();\n        return IWrapperRegistryEFX(wrapperRegistry).token2WrapperLookup(_token);\n    }\n\n    /// @dev Function to be called by Trading spoke without change of context (Non delegate call)\n    function getWrapperTokenFromAdapterContext(address _token)\n        internal\n        view\n        returns (address)\n    {\n        address wrapperRegistry = Registry(Trading(msg.sender).registry()).ethfinexWrapperRegistry();\n        return IWrapperRegistryEFX(wrapperRegistry).token2WrapperLookup(_token);\n    }\n}\n"
    },
    "./src/exchanges/ExchangeAdapter.sol": {
      "content": "pragma solidity 0.6.1;\npragma experimental ABIEncoderV2;\n\nimport \"../dependencies/DSMath.sol\";\nimport \"../dependencies/token/IERC20.sol\";\nimport \"../fund/accounting/Accounting.sol\";\nimport \"../fund/hub/Hub.sol\";\nimport \"../fund/trading/Trading.sol\";\nimport \"../fund/vault/Vault.sol\";\n\n/// @title Exchange Adapter base contract\n/// @author Melonport AG <team@melonport.com>\n/// @notice Override the public methods to implement an adapter\ncontract ExchangeAdapter is DSMath {\n\n    modifier onlyManager() {\n        require(\n            getManager() == msg.sender,\n            \"Manager must be sender\"\n        );\n        _;\n    }\n\n    modifier notShutDown() {\n        require(\n            !hubShutDown(),\n            \"Hub must not be shut down\"\n        );\n        _;\n    }\n\n    /// @dev Either manager sends, fund shut down, or order expired\n    function ensureCancelPermitted(address exchange, address asset) internal {\n        require(\n            getManager() == msg.sender ||\n            hubShutDown() ||\n            getTrading().isOrderExpired(exchange, asset),\n            \"No cancellation condition met\"\n        );\n    }\n\n    function getTrading() internal view returns (Trading) {\n        return Trading(payable(address(this)));\n    }\n\n    function getHub() internal view returns (Hub) {\n        return Hub(getTrading().hub());\n    }\n\n    function getAccounting() internal view returns (Accounting) {\n        return Accounting(getHub().accounting());\n    }\n\n    function hubShutDown() internal view returns (bool) {\n        return getHub().isShutDown();\n    }\n\n    function getManager() internal view returns (address) {\n        return getHub().manager();\n    }\n\n    function ensureNotInOpenMakeOrder(address _asset) internal view {\n        require(\n            !getTrading().isInOpenMakeOrder(_asset),\n            \"This asset is already in an open make order\"\n        );\n    }\n\n    function ensureCanMakeOrder(address _asset) internal view {\n        require(\n            block.timestamp >= getTrading().makerAssetCooldown(_asset),\n            \"Cooldown for the maker asset not reached\"\n        );\n    }\n\n    /// @notice Increment allowance of an asset for some target\n    function withdrawAndApproveAsset(\n        address _asset,\n        address _target,\n        uint256 _amount,\n        string memory _assetType\n    )\n        internal\n    {\n        Hub hub = getHub();\n        Vault vault = Vault(hub.vault());\n\n        require(\n            IERC20(_asset).balanceOf(address(vault)) >= _amount,\n            string(abi.encodePacked(\"Insufficient balance: \", _assetType))\n        );\n\n        vault.withdraw(_asset, _amount);\n        uint256 allowance = IERC20(_asset).allowance(address(this), _target);\n        require(\n            IERC20(_asset).approve(_target, add(allowance, _amount)),\n            string(abi.encodePacked(\"Approval failed: \", _assetType))\n        );\n    }\n\n    /// @notice Reduce allowance of an asset for some target\n    function revokeApproveAsset(\n        address _asset,\n        address _target,\n        uint256 _amount,\n        string memory _assetType\n    )\n        internal\n    {\n        uint256 allowance = IERC20(_asset).allowance(address(this), _target);\n        require(\n            IERC20(_asset).approve(_target, sub(allowance, _amount)),\n            string(abi.encodePacked(\"Revoke approval failed: \", _assetType))\n        );\n    }\n\n    /// @param orderAddresses [0] Order maker\n    /// @param orderAddresses [1] Order taker\n    /// @param orderAddresses [2] Order maker asset\n    /// @param orderAddresses [3] Order taker asset\n    /// @param orderAddresses [4] feeRecipientAddress\n    /// @param orderAddresses [5] senderAddress\n    /// @param orderAddresses [6] maker fee asset\n    /// @param orderAddresses [7] taker fee asset\n    /// @param orderValues [0] makerAssetAmount\n    /// @param orderValues [1] takerAssetAmount\n    /// @param orderValues [2] Maker fee\n    /// @param orderValues [3] Taker fee\n    /// @param orderValues [4] expirationTimeSeconds\n    /// @param orderValues [5] Salt/nonce\n    /// @param orderValues [6] Fill amount: amount of taker token to be traded\n    /// @param orderValues [7] Dexy signature mode\n    /// @param orderData [0] Encoded data specific to maker asset\n    /// @param orderData [1] Encoded data specific to taker asset\n    /// @param orderData [2] Encoded data specific to maker asset fee\n    /// @param orderData [3] Encoded data specific to taker asset fee\n    /// @param identifier Order identifier\n    /// @param signature Signature of order maker\n\n    // Responsibilities of makeOrder are:\n    // - check sender\n    // - check fund not shut down\n    // - check price recent\n    // - check risk management passes\n    // - approve funds to be traded (if necessary)\n    // - make order on the exchange\n    // - check order was made (if possible)\n    // - place asset in ownedAssets if not already tracked\n    function makeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual { revert(\"Unimplemented\"); }\n\n    // Responsibilities of takeOrder are:\n    // - check sender\n    // - check fund not shut down\n    // - check not buying own fund tokens\n    // - check price exists for asset pair\n    // - check price is recent\n    // - check price passes risk management\n    // - approve funds to be traded (if necessary)\n    // - take order from the exchange\n    // - check order was taken (if possible)\n    // - place asset in ownedAssets if not already tracked\n    function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual { revert(\"Unimplemented\"); }\n\n    // responsibilities of cancelOrder are:\n    // - check sender is owner, or that order expired, or that fund shut down\n    // - remove order from tracking array\n    // - cancel order on exchange\n    function cancelOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual { revert(\"Unimplemented\"); }\n\n    // PUBLIC METHODS\n    // PUBLIC VIEW METHODS\n    /*\n    @return {\n        \"makerAsset\": \"Maker asset\",\n        \"takerAsset\": \"Taker asset\",\n        \"makerQuantity\": \"Amount of maker asset\"\n        \"takerQuantity\": \"Amount of taker asset\"\n    }\n    */\n    function getOrder(\n        address onExchange,\n        uint id,\n        address makerAsset\n    ) public view virtual returns (\n        address,\n        address,\n        uint,\n        uint\n    ) { revert(\"Unimplemented\"); }\n}\n"
    },
    "./src/exchanges/interfaces/IEthfinex.sol": {
      "content": "pragma solidity 0.6.1;\n// pragma experimental ABIEncoderV2;\n\n/// @dev Minimal interface for our interactions with EthFinex WrapperLock\ninterface IWrapperLock {\n    function balanceOf(address) external view returns (uint256);\n    function withdraw(uint256, uint8, bytes32, bytes32, uint256) external returns (bool);\n    function deposit(uint256, uint256) external returns (bool);\n}\n\n/// @dev Minimal interface for our interactions with EthFinex WrapperLockEth\ninterface IWrapperLockEth {\n    function balanceOf(address) external view returns (uint256);\n    function deposit(uint256, uint256) external payable returns (bool);\n}\n\n/// @dev Minimal interface for our interactions with EthFinex WrapperRegistryEFX\ninterface IWrapperRegistryEFX {\n    function token2WrapperLookup(address) external view returns (address);\n    function wrapper2TokenLookup(address) external view returns (address);\n}\n"
    },
    "./src/exchanges/interfaces/IKyberNetworkProxy.sol": {
      "content": "pragma solidity 0.6.1;\n\n\n/// @title Kyber Network interface\ninterface IKyberNetworkProxy {\n    function maxGasPrice() external view returns(uint256);\n    function getUserCapInWei(address) external view returns(uint256);\n    function getUserCapInTokenWei(address, address) external view returns(uint256);\n    function enabled() external view returns(bool);\n    function info(bytes32) external view returns(uint256);\n    function swapEtherToToken(address, uint256) external payable returns(uint256);\n    function swapTokenToEther(address, uint256, uint256) external returns(uint256);\n    function swapTokenToToken(address, uint256, address, uint256) external returns(uint);\n    function getExpectedRate(address, address, uint256) external view returns (uint256, uint256);\n    function tradeWithHint(\n        address, uint256, address, address, uint256, uint256, address, bytes calldata\n    ) external payable returns(uint256);\n}\n"
    },
    "./src/exchanges/interfaces/IOasisDex.sol": {
      "content": "pragma solidity 0.6.1;\n\n/// @dev Minimal interface for our interactions with OasisDex MatchingMarket\ninterface IOasisDex {\n    function getFirstUnsortedOffer() external view returns(uint256);\n    function getNextUnsortedOffer(uint256) external view returns(uint256);\n    function getBestOffer(address, address) external view returns(uint256);\n    function getOffer(uint256) external view returns (uint256, address, uint256, address);\n    function getWorseOffer(uint256) external view returns(uint256);\n    function isActive(uint256) external view returns (bool);\n    function buy(uint256, uint256) external returns (bool);\n    function cancel(uint256) external returns (bool);\n    function offer(uint256, address, uint256, address) external returns (uint256);\n}\n"
    },
    "./src/exchanges/interfaces/IUniswapExchange.sol": {
      "content": "pragma solidity 0.6.1;\n\n/// @dev Minimal interface for our interactions with UniswapExchange\ninterface IUniswapExchange {\n    // Trade ETH to ERC20\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient)\n        external\n        payable\n        returns (uint256 tokens_bought);\n    // Trade ERC20 to ETH\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline)\n        external\n        returns (uint256 eth_bought);\n    // Trade ERC20 to ERC20\n    function tokenToTokenTransferInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address recipient,\n        address token_addr\n    )\n        external\n        returns (uint256 tokens_bought);\n\n    /// @dev The following functions are only used in tests\n    // Provide Liquidity\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline)\n        external\n        payable\n        returns (uint256);\n    // Get Prices\n    function getEthToTokenInputPrice(uint256 eth_sold)\n        external\n        view\n        returns (uint256 tokens_bought);\n    function getTokenToEthInputPrice(uint256 tokens_sold)\n        external\n        view\n        returns (uint256 eth_bought);\n}\n"
    },
    "./src/exchanges/interfaces/IUniswapFactory.sol": {
      "content": "pragma solidity 0.6.1;\n\n/// @dev Minimal interface for our interactions with UniswapFactory\ninterface IUniswapFactory {\n    function getExchange(address token) external view returns (address exchange);\n}\n"
    },
    "./src/exchanges/interfaces/IZeroExV2.sol": {
      "content": "pragma solidity 0.6.1;\npragma experimental ABIEncoderV2;\n\n/// @dev Minimal interface for our interactions with the ZeroEx Exchange contract\ninterface IZeroExV2 {\n    struct Order {\n        address makerAddress;\n        address takerAddress;\n        address feeRecipientAddress;\n        address senderAddress;\n        uint256 makerAssetAmount;\n        uint256 takerAssetAmount;\n        uint256 makerFee;\n        uint256 takerFee;\n        uint256 expirationTimeSeconds;\n        uint256 salt;\n        bytes makerAssetData;\n        bytes takerAssetData;\n    }\n\n    struct OrderInfo {\n        uint8 orderStatus;\n        bytes32 orderHash;\n        uint256 orderTakerAssetFilledAmount;\n    }\n\n    struct FillResults {\n        uint256 makerAssetFilledAmount;\n        uint256 takerAssetFilledAmount;\n        uint256 makerFeePaid;\n        uint256 takerFeePaid;\n    }\n\n    function ZRX_ASSET_DATA() external view returns (bytes memory);\n    function filled(bytes32) external view returns (uint256);\n    function cancelled(bytes32) external view returns (bool);\n    function getOrderInfo(Order calldata) external view returns (OrderInfo memory);\n    function getAssetProxy(bytes4) external view returns (address);\n    function isValidSignature(bytes32, address, bytes calldata) external view returns (bool);\n    function preSign(bytes32, address, bytes calldata) external;\n    function cancelOrder(Order calldata) external;\n    function fillOrder(Order calldata, uint256, bytes calldata) external returns (FillResults memory);\n}\n"
    },
    "./src/exchanges/interfaces/IZeroExV3.sol": {
      "content": "pragma solidity 0.6.1;\npragma experimental ABIEncoderV2;\n\n/// @dev Minimal interface for our interactions with the ZeroEx Exchange contract\ninterface IZeroExV3 {\n    struct Order {\n        address makerAddress;\n        address takerAddress;\n        address feeRecipientAddress;\n        address senderAddress;\n        uint256 makerAssetAmount;\n        uint256 takerAssetAmount;\n        uint256 makerFee;\n        uint256 takerFee;\n        uint256 expirationTimeSeconds;\n        uint256 salt;\n        bytes makerAssetData;\n        bytes takerAssetData;\n        bytes makerFeeAssetData;\n        bytes takerFeeAssetData;\n    }\n\n    struct OrderInfo {\n        uint8 orderStatus;\n        bytes32 orderHash;\n        uint256 orderTakerAssetFilledAmount;\n    }\n\n    struct FillResults {\n        uint256 makerAssetFilledAmount;\n        uint256 takerAssetFilledAmount;\n        uint256 makerFeePaid;\n        uint256 takerFeePaid;\n        uint256 protocolFeePaid;\n    }\n\n    function cancelled(bytes32) external view returns (bool);\n    function cancelOrder(Order calldata) external;\n    function filled(bytes32) external view returns (uint256);\n    function fillOrder(Order calldata, uint256, bytes calldata) external payable returns (FillResults memory);\n    function getAssetProxy(bytes4) external view returns (address);\n    function getOrderInfo(Order calldata) external view returns (OrderInfo memory);\n    function isValidOrderSignature(Order calldata, bytes calldata) external view returns (bool);\n    function preSign(bytes32) external;\n    function protocolFeeCollector() external view returns (address);\n    function protocolFeeMultiplier() external view returns (uint256);\n}\n"
    },
    "./src/exchanges/KyberAdapter.sol": {
      "content": "pragma solidity 0.6.1;\npragma experimental ABIEncoderV2;\n\nimport \"../dependencies/WETH.sol\";\nimport \"../dependencies/token/IERC20.sol\";\nimport \"../fund/trading/Trading.sol\";\nimport \"../fund/hub/Hub.sol\";\nimport \"../fund/vault/Vault.sol\";\nimport \"../fund/accounting/Accounting.sol\";\nimport \"../prices/IPriceSource.sol\";\nimport \"./interfaces/IKyberNetworkProxy.sol\";\nimport \"./ExchangeAdapter.sol\";\n\ncontract KyberAdapter is DSMath, ExchangeAdapter {\n    address public constant ETH_TOKEN_ADDRESS = address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n\n    // NON-CONSTANT METHODS\n\n    // Responsibilities of takeOrder (Kybers swapToken) are:\n    // - check price recent\n    // - check risk management passes\n    // - approve funds to be traded (if necessary)\n    // - perform swap order on the exchange\n    // - place asset in ownedAssets if not already tracked\n    /// @notice Swaps srcAmount of srcToken for destAmount of destToken\n    /// @dev Variable naming to be close to Kyber's naming\n    /// @dev For the purpose of PriceTolerance, fillTakerQuantity == takerAssetQuantity = Dest token amount\n    /// @param targetExchange Address of the exchange\n    /// @param orderAddresses [2] Maker asset (Dest token)\n    /// @param orderAddresses [3] Taker asset (Src token)\n    /// @param orderValues [0] Maker asset quantity (Dest token amount)\n    /// @param orderValues [1] Taker asset quantity (Src token amount)\n    function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public override onlyManager notShutDown {\n        Hub hub = getHub();\n\n        require(\n            orderValues[1] == orderValues[6],\n            \"fillTakerQuantity must equal takerAssetQuantity\"\n        );\n\n        address makerAsset = orderAddresses[2];\n        address takerAsset = orderAddresses[3];\n        uint makerAssetAmount = orderValues[0];\n        uint takerAssetAmount = orderValues[1];\n\n        uint minRate = calcMinRate(\n            takerAsset,\n            makerAsset,\n            takerAssetAmount,\n            makerAssetAmount\n        );\n\n        uint actualReceiveAmount = dispatchSwap(\n            targetExchange, takerAsset, takerAssetAmount, makerAsset, minRate\n        );\n        require(\n            actualReceiveAmount >= makerAssetAmount,\n            \"Received less than expected from Kyber swap\"\n        );\n\n        getAccounting().addAssetToOwnedAssets(makerAsset);\n        getAccounting().updateOwnedAssets();\n        getTrading().returnAssetToVault(makerAsset);\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(0),\n            Trading.UpdateType.take,\n            [payable(makerAsset), payable(takerAsset)],\n            [actualReceiveAmount, takerAssetAmount, takerAssetAmount]\n        );\n    }\n\n    // INTERNAL FUNCTIONS\n\n    /// @notice Call different functions based on type of assets supplied\n    function dispatchSwap(\n        address targetExchange,\n        address srcToken,\n        uint srcAmount,\n        address destToken,\n        uint minRate\n    )\n        internal\n        returns (uint actualReceiveAmount)\n    {\n\n        Hub hub = getHub();\n        address nativeAsset = Accounting(hub.accounting()).NATIVE_ASSET();\n\n        if (srcToken == nativeAsset) {\n            actualReceiveAmount = swapNativeAssetToToken(targetExchange, nativeAsset, srcAmount, destToken, minRate);\n        }\n        else if (destToken == nativeAsset) {\n            actualReceiveAmount = swapTokenToNativeAsset(targetExchange, srcToken, srcAmount, nativeAsset, minRate);\n        }\n        else {\n            actualReceiveAmount = swapTokenToToken(targetExchange, srcToken, srcAmount, destToken, minRate);\n        }\n    }\n\n    /// @dev If minRate is not defined, uses expected rate from the network\n    /// @param targetExchange Address of Kyber proxy contract\n    /// @param nativeAsset Native asset address as src token\n    /// @param srcAmount Amount of native asset supplied\n    /// @param destToken Address of dest token\n    /// @param minRate Minimum rate supplied to the Kyber proxy\n    /// @return receivedAmount Actual amount of destToken received from the exchange\n    function swapNativeAssetToToken(\n        address targetExchange,\n        address nativeAsset,\n        uint srcAmount,\n        address destToken,\n        uint minRate\n    )\n        internal\n        returns (uint receivedAmount)\n    {\n        // Convert WETH to ETH\n        Hub hub = getHub();\n        Vault vault = Vault(hub.vault());\n        vault.withdraw(nativeAsset, srcAmount);\n        WETH(payable(nativeAsset)).withdraw(srcAmount);\n        receivedAmount = IKyberNetworkProxy(targetExchange).swapEtherToToken.value(srcAmount)(destToken, minRate);\n    }\n\n    /// @dev If minRate is not defined, uses expected rate from the network\n    /// @param targetExchange Address of Kyber proxy contract\n    /// @param srcToken Address of src token\n    /// @param srcAmount Amount of src token supplied\n    /// @param nativeAsset Native asset address as src token\n    /// @param minRate Minimum rate supplied to the Kyber proxy\n    /// @return receivedAmount Actual amount of destToken received from the exchange\n    function swapTokenToNativeAsset(\n        address targetExchange,\n        address srcToken,\n        uint srcAmount,\n        address nativeAsset,\n        uint minRate\n    )\n        internal\n        returns (uint receivedAmount)\n    {\n        withdrawAndApproveAsset(srcToken, targetExchange, srcAmount, \"takerAsset\");\n        receivedAmount = IKyberNetworkProxy(targetExchange).swapTokenToEther(srcToken, srcAmount, minRate);\n\n        // Convert ETH to WETH\n        WETH(payable(nativeAsset)).deposit.value(receivedAmount)();\n    }\n\n    /// @dev If minRate is not defined, uses expected rate from the network\n    /// @param targetExchange Address of Kyber proxy contract\n    /// @param srcToken Address of src token\n    /// @param srcAmount Amount of src token supplied\n    /// @param destToken Address of dest token\n    /// @param minRate Minimum rate supplied to the Kyber proxy\n    /// @return receivedAmount Actual amount of destToken received from the exchange\n    function swapTokenToToken(\n        address targetExchange,\n        address srcToken,\n        uint srcAmount,\n        address destToken,\n        uint minRate\n    )\n        internal\n        returns (uint receivedAmount)\n    {\n        withdrawAndApproveAsset(srcToken, targetExchange, srcAmount, \"takerAsset\");\n\n        receivedAmount = IKyberNetworkProxy(targetExchange).swapTokenToToken(srcToken, srcAmount, destToken, minRate);\n    }\n\n    /// @param srcToken Address of src token\n    /// @param destToken Address of dest token\n    /// @param srcAmount Amount of src token\n    /// @return minRate Minimum rate to be supplied to the network for some order params\n    function calcMinRate(\n        address srcToken,\n        address destToken,\n        uint srcAmount,\n        uint destAmount\n    )\n        internal\n        view\n        returns (uint minRate)\n    {\n        IPriceSource pricefeed = IPriceSource(getHub().priceSource());\n        minRate = pricefeed.getOrderPriceInfo(\n            srcToken,\n            destToken,\n            srcAmount,\n            destAmount\n        );\n    }\n}\n"
    },
    "./src/exchanges/OasisDexAccessor.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"./interfaces/IOasisDex.sol\";\n\ncontract OasisDexAccessor {\n    function getUnsortedOfferIds(\n        address targetExchange,\n        address sellAsset,\n        address buyAsset\n    )\n    public\n    view\n    returns (uint[] memory)\n    {\n        IOasisDex market = IOasisDex(targetExchange);\n        uint[] memory ids = new uint[](1000);\n        uint count = 0;\n\n        // Iterate over all unsorted offers up to 1000 iterations.\n        uint id = market.getFirstUnsortedOffer();\n        for (uint i = 0; i < 1000; i++) {\n            if (id == 0) {\n                break;\n            }\n\n            if (market.isActive(id)) {\n                address sellGem;\n                address buyGem;\n                (, sellGem, , buyGem) = market.getOffer(id);\n\n                if (sellGem == sellAsset && buyGem == buyAsset) {\n                    ids[count++] = id;\n                }\n            }\n\n            // Get the next offer and repeat.\n            id = market.getNextUnsortedOffer(id);\n        }\n\n        // Create a new array of offers with the correct size.\n        uint[] memory copy = new uint[](count);\n        for (uint i = 0; i < count; i++) {\n            copy[i] = ids[i];\n        }\n\n        return copy;\n    }\n\n    function getSortedOfferIds(\n        address targetExchange,\n        address sellAsset,\n        address buyAsset\n    )\n    public\n    view\n    returns(uint[] memory)\n    {\n        IOasisDex market = IOasisDex(targetExchange);\n        uint[] memory ids = new uint[](1000);\n        uint count = 0;\n\n        // Iterate over all sorted offers.\n        uint id = market.getBestOffer(sellAsset, buyAsset);\n        for (uint i = 0; i < 1000 ; i++ ) {\n            if (id == 0) {\n                break;\n            }\n\n            if (market.isActive(id)) {\n                ids[count++] = id;\n            }\n\n            // Get the next offer and repeat.\n            id = market.getWorseOffer(id);\n        }\n\n        // Create a new array of offers with the correct size.\n        uint[] memory copy = new uint[](count);\n        for (uint i = 0; i < count; i++) {\n            copy[i] = ids[i];\n        }\n\n        return copy;\n    }\n\n    function getOrders(\n        address targetExchange,\n        address sellAsset,\n        address buyAsset\n    )\n    public\n    view\n    returns (uint[] memory, uint[] memory, uint[] memory) {\n        IOasisDex market = IOasisDex(targetExchange);\n        uint[] memory sIds = getSortedOfferIds(targetExchange, sellAsset, buyAsset);\n        uint[] memory uIds = getUnsortedOfferIds(targetExchange, sellAsset, buyAsset);\n        uint[] memory ids = new uint[](uIds.length + sIds.length);\n        uint[] memory sellQtys = new uint[](ids.length);\n        uint[] memory buyQtys = new uint[](ids.length);\n\n        for (uint i = 0; i < sIds.length; i++) {\n            ids[i] = sIds[i];\n        }\n\n        for (uint i = 0; i < uIds.length; i++) {\n            ids[i + sIds.length] = uIds[i];\n        }\n\n        for (uint i = 0; i < ids.length; i++) {\n            uint sellQty;\n            uint buyQty;\n            (sellQty, , buyQty,) = market.getOffer(ids[i]);\n            sellQtys[i] = sellQty;\n            buyQtys[i] = buyQty;\n        }\n\n        return (ids, sellQtys, buyQtys);\n    }\n}\n"
    },
    "./src/exchanges/OasisDexAdapter.sol": {
      "content": "pragma solidity 0.6.1;\npragma experimental ABIEncoderV2;\n\nimport \"../fund/hub/Hub.sol\";\nimport \"../fund/trading/Trading.sol\";\nimport \"../fund/vault/Vault.sol\";\nimport \"../fund/accounting/Accounting.sol\";\nimport \"../dependencies/DSMath.sol\";\nimport \"./interfaces/IOasisDex.sol\";\nimport \"./ExchangeAdapter.sol\";\n\n/// @title OasisDexAdapter Contract\n/// @author Melonport AG <team@melonport.com>\n/// @notice Adapter between Melon and OasisDex Matching Market\ncontract OasisDexAdapter is DSMath, ExchangeAdapter {\n\n    event OrderCreated(uint256 id);\n\n    //  METHODS\n\n    //  PUBLIC METHODS\n\n    // Responsibilities of makeOrder are:\n    // - check sender\n    // - check fund not shut down\n    // - check price recent\n    // - check risk management passes\n    // - approve funds to be traded (if necessary)\n    // - make order on the exchange\n    // - check order was made (if possible)\n    // - place asset in ownedAssets if not already tracked\n    /// @notice Makes an order on the selected exchange\n    /// @dev These orders are not expected to settle immediately\n    /// @param targetExchange Address of the exchange\n    /// @param orderAddresses [2] Order maker asset\n    /// @param orderAddresses [3] Order taker asset\n    /// @param orderValues [0] Maker token quantity\n    /// @param orderValues [1] Taker token quantity\n    function makeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public override onlyManager notShutDown {\n        ensureCanMakeOrder(orderAddresses[2]);\n        address makerAsset = orderAddresses[2];\n        address takerAsset = orderAddresses[3];\n        uint256 makerQuantity = orderValues[0];\n        uint256 takerQuantity = orderValues[1];\n\n        // Order parameter checks\n        getTrading().updateAndGetQuantityBeingTraded(makerAsset);\n        ensureNotInOpenMakeOrder(makerAsset);\n\n        withdrawAndApproveAsset(makerAsset, targetExchange, makerQuantity, \"makerAsset\");\n\n        uint256 orderId = IOasisDex(targetExchange).offer(makerQuantity, makerAsset, takerQuantity, takerAsset);\n\n        // defines success in MatchingMarket\n        require(orderId != 0, \"Order ID should not be zero\");\n\n        getAccounting().addAssetToOwnedAssets(takerAsset);\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(orderId),\n            Trading.UpdateType.make,\n            [payable(makerAsset), payable(takerAsset)],\n            [makerQuantity, takerQuantity, uint256(0)]\n        );\n        getTrading().addOpenMakeOrder(targetExchange, makerAsset, takerAsset, orderId, orderValues[4]);\n        emit OrderCreated(orderId);\n    }\n\n    // Responsibilities of takeOrder are:\n    // - check sender\n    // - check fund not shut down\n    // - check not buying own fund tokens\n    // - check price exists for asset pair\n    // - check price is recent\n    // - check price passes risk management\n    // - approve funds to be traded (if necessary)\n    // - take order from the exchange\n    // - check order was taken (if possible)\n    // - place asset in ownedAssets if not already tracked\n    /// @notice Takes an active order on the selected exchange\n    /// @dev These orders are expected to settle immediately\n    /// @param targetExchange Address of the exchange\n    /// @param orderValues [6] Fill amount : amount of taker token to fill\n    /// @param identifier Active order id\n    function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public override onlyManager notShutDown {\n        Hub hub = getHub();\n        uint256 fillTakerQuantity = orderValues[6];\n        uint256 maxMakerQuantity;\n        address makerAsset;\n        uint256 maxTakerQuantity;\n        address takerAsset;\n        (\n            maxMakerQuantity,\n            makerAsset,\n            maxTakerQuantity,\n            takerAsset\n        ) = IOasisDex(targetExchange).getOffer(uint256(identifier));\n        uint256 fillMakerQuantity = mul(fillTakerQuantity, maxMakerQuantity) / maxTakerQuantity;\n\n        require(\n            makerAsset == orderAddresses[2] && takerAsset == orderAddresses[3],\n            \"Maker and taker assets do not match the order addresses\"\n        );\n        require(\n            makerAsset != takerAsset,\n            \"Maker and taker assets cannot be the same\"\n        );\n        require(fillMakerQuantity <= maxMakerQuantity, \"Maker amount to fill above max\");\n        require(fillTakerQuantity <= maxTakerQuantity, \"Taker amount to fill above max\");\n\n        withdrawAndApproveAsset(takerAsset, targetExchange, fillTakerQuantity, \"takerAsset\");\n\n        require(\n            IOasisDex(targetExchange).buy(uint256(identifier), fillMakerQuantity),\n            \"Buy on matching market failed\"\n        );\n\n        getAccounting().addAssetToOwnedAssets(makerAsset);\n        getAccounting().updateOwnedAssets();\n        getTrading().returnAssetToVault(makerAsset);\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(identifier),\n            Trading.UpdateType.take,\n            [payable(makerAsset), payable(takerAsset)],\n            [maxMakerQuantity, maxTakerQuantity, fillTakerQuantity]\n        );\n    }\n\n    // responsibilities of cancelOrder are:\n    // - check sender is owner, or that order expired, or that fund shut down\n    // - remove order from tracking array\n    // - cancel order on exchange\n    /// @notice Cancels orders that were not expected to settle immediately\n    /// @param targetExchange Address of the exchange\n    /// @param orderAddresses [2] Order maker asset\n    /// @param identifier Order ID on the exchange\n    function cancelOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public override {\n        require(uint256(identifier) != 0, \"ID cannot be zero\");\n\n        address makerAsset;\n        (, makerAsset, ,) = IOasisDex(targetExchange).getOffer(uint256(identifier));\n        ensureCancelPermitted(targetExchange, makerAsset);\n\n        require(\n            address(makerAsset) == orderAddresses[2],\n            \"Retrieved and passed assets do not match\"\n        );\n\n        getTrading().removeOpenMakeOrder(targetExchange, makerAsset);\n        IOasisDex(targetExchange).cancel(\n            uint256(identifier)\n        );\n        getTrading().returnAssetToVault(makerAsset);\n        getAccounting().updateOwnedAssets();\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(identifier),\n            Trading.UpdateType.cancel,\n            [address(0), address(0)],\n            [uint256(0), uint256(0), uint256(0)]\n        );\n    }\n\n    // VIEW METHODS\n\n    function getOrder(address targetExchange, uint256 id, address makerAsset)\n        public\n        view\n        override\n        returns (address, address, uint256, uint256)\n    {\n        uint256 sellQuantity;\n        address sellAsset;\n        uint256 buyQuantity;\n        address buyAsset;\n        (\n            sellQuantity,\n            sellAsset,\n            buyQuantity,\n            buyAsset\n        ) = IOasisDex(targetExchange).getOffer(id);\n        return (\n            sellAsset,\n            buyAsset,\n            sellQuantity,\n            buyQuantity\n        );\n    }\n}\n"
    },
    "./src/exchanges/UniswapAdapter.sol": {
      "content": "pragma solidity 0.6.1;\npragma experimental ABIEncoderV2;\n\nimport \"../dependencies/token/IERC20.sol\";\nimport \"../dependencies/WETH.sol\";\nimport \"../fund/accounting/Accounting.sol\";\nimport \"../fund/hub/Hub.sol\";\nimport \"../fund/trading/Trading.sol\";\nimport \"../fund/vault/Vault.sol\";\nimport \"./interfaces/IUniswapFactory.sol\";\nimport \"./interfaces/IUniswapExchange.sol\";\nimport \"./ExchangeAdapter.sol\";\n\ncontract UniswapAdapter is DSMath, ExchangeAdapter {\n    /// @notice Take order that uses a user-defined src token amount to trade for a dest token amount\n    /// @dev For the purpose of PriceTolerance, _orderValues [1] == _orderValues [6] = Dest token amount\n    /// @param _targetExchange Address of Uniswap factory contract\n    /// @param _orderAddresses [2] Maker asset (Dest token)\n    /// @param _orderAddresses [3] Taker asset (Src token)\n    /// @param _orderValues [0] Maker asset quantity (Dest token amount)\n    /// @param _orderValues [1] Taker asset quantity (Src token amount)\n    /// @param _orderValues [6] Taker asset fill amount\n    function takeOrder(\n        address _targetExchange,\n        address[8] memory _orderAddresses,\n        uint[8] memory _orderValues,\n        bytes[4] memory _orderData,\n        bytes32 _identifier,\n        bytes memory _signature\n    )\n        public\n        override\n        onlyManager\n        notShutDown\n    {\n        require(\n            _orderValues[1] == _orderValues[6],\n            \"Taker asset amount must equal taker asset fill amount\"\n        );\n\n        address makerAsset = _orderAddresses[2];\n        address takerAsset = _orderAddresses[3];\n        uint makerAssetAmount = _orderValues[0];\n        uint takerAssetAmount = _orderValues[1];\n\n        uint actualReceiveAmount = dispatchSwap(\n            _targetExchange, takerAsset, takerAssetAmount, makerAsset, makerAssetAmount\n        );\n        require(\n            actualReceiveAmount >= makerAssetAmount,\n            \"Received less than expected from Uniswap exchange\"\n        );\n\n        updateStateTakeOrder(\n            _targetExchange,\n            makerAsset,\n            takerAsset,\n            takerAssetAmount,\n            actualReceiveAmount\n        );\n    }\n\n    // INTERNAL FUNCTIONS\n\n    /// @notice Call different functions based on type of assets supplied\n    /// @param _targetExchange Address of Uniswap factory contract\n    /// @param _srcToken Address of src token\n    /// @param _srcAmount Amount of src token supplied\n    /// @param _destToken Address of dest token\n    /// @param _minDestAmount Minimum amount of dest token to receive\n    /// @return actualReceiveAmount_ Actual amount of _destToken received\n    function dispatchSwap(\n        address _targetExchange,\n        address _srcToken,\n        uint _srcAmount,\n        address _destToken,\n        uint _minDestAmount\n    )\n        internal\n        returns (uint actualReceiveAmount_)\n    {\n        require(\n            _srcToken != _destToken,\n            \"Src token cannot be the same as dest token\"\n        );\n\n        Hub hub = getHub();\n        address nativeAsset = Accounting(hub.accounting()).NATIVE_ASSET();\n\n        if (_srcToken == nativeAsset) {\n            actualReceiveAmount_ = swapNativeAssetToToken(\n                _targetExchange,\n                nativeAsset,\n                _srcAmount,\n                _destToken,\n                _minDestAmount\n            );\n        } else if (_destToken == nativeAsset) {\n            actualReceiveAmount_ = swapTokenToNativeAsset(\n                _targetExchange,\n                _srcToken,\n                _srcAmount,\n                nativeAsset,\n                _minDestAmount\n            );\n        } else {\n            actualReceiveAmount_ = swapTokenToToken(\n                _targetExchange,\n                _srcToken,\n                _srcAmount,\n                _destToken,\n                _minDestAmount\n            );\n        }\n    }\n\n    /// @param _targetExchange Address of Uniswap factory contract\n    /// @param _nativeAsset Native asset address as src token\n    /// @param _srcAmount Amount of native asset supplied\n    /// @param _destToken Address of dest token\n    /// @param _minDestAmount Minimum amount of dest token to get back\n    /// @return actualReceiveAmount_ Actual amount of _destToken received\n    function swapNativeAssetToToken(\n        address _targetExchange,\n        address _nativeAsset,\n        uint _srcAmount,\n        address _destToken,\n        uint _minDestAmount\n    )\n        internal\n        returns (uint actualReceiveAmount_)\n    {\n        // Convert WETH to ETH\n        Hub hub = getHub();\n        Vault vault = Vault(hub.vault());\n        vault.withdraw(_nativeAsset, _srcAmount);\n        WETH(payable(_nativeAsset)).withdraw(_srcAmount);\n\n        address tokenExchange = IUniswapFactory(_targetExchange).getExchange(_destToken);\n        actualReceiveAmount_ = IUniswapExchange(tokenExchange).ethToTokenTransferInput.value(\n            _srcAmount\n        )\n        (\n            _minDestAmount,\n            add(block.timestamp, 1),\n            address(vault)\n        );\n    }\n\n    /// @param _targetExchange Address of Uniswap factory contract\n    /// @param _srcToken Address of src token\n    /// @param _srcAmount Amount of src token supplied\n    /// @param _nativeAsset Native asset address as dest token\n    /// @param _minDestAmount Minimum amount of dest token to get back\n    /// @return actualReceiveAmount_ Actual amount of _destToken received\n    function swapTokenToNativeAsset(\n        address _targetExchange,\n        address _srcToken,\n        uint _srcAmount,\n        address _nativeAsset,\n        uint _minDestAmount\n    )\n        internal\n        returns (uint actualReceiveAmount_)\n    {\n        address tokenExchange = IUniswapFactory(_targetExchange).getExchange(_srcToken);\n        withdrawAndApproveAsset(_srcToken, tokenExchange, _srcAmount, \"takerAsset\");\n        actualReceiveAmount_ = IUniswapExchange(tokenExchange).tokenToEthSwapInput(\n            _srcAmount,\n            _minDestAmount,\n            add(block.timestamp, 1)\n        );\n\n        // Convert ETH to WETH and move to Vault\n        WETH(payable(_nativeAsset)).deposit.value(actualReceiveAmount_)();\n        getTrading().returnAssetToVault(_nativeAsset);\n    }\n\n    /// @param _targetExchange Address of Uniswap factory contract\n    /// @param _srcToken Address of src token\n    /// @param _srcAmount Amount of src token supplied\n    /// @param _destToken Address of dest token\n    /// @param _minDestAmount Minimum amount of dest token to get back\n    /// @return actualReceiveAmount_ Actual amount of _destToken received\n    function swapTokenToToken(\n        address _targetExchange,\n        address _srcToken,\n        uint _srcAmount,\n        address _destToken,\n        uint _minDestAmount\n    )\n        internal\n        returns (uint actualReceiveAmount_)\n    {\n        Hub hub = getHub();\n        address tokenExchange = IUniswapFactory(_targetExchange).getExchange(_srcToken);\n        withdrawAndApproveAsset(_srcToken, tokenExchange, _srcAmount, \"takerAsset\");\n        actualReceiveAmount_ = IUniswapExchange(tokenExchange).tokenToTokenTransferInput(\n            _srcAmount,\n            _minDestAmount,\n            1,\n            add(block.timestamp, 1),\n            address(Vault(hub.vault())),\n            _destToken\n        );\n    }\n\n    function updateStateTakeOrder(\n        address _targetExchange,\n        address _makerAsset,\n        address _takerAsset,\n        uint256 _takerAssetAmount,\n        uint256 _actualReceiveAmount\n    )\n        internal\n    {\n        getAccounting().addAssetToOwnedAssets(_makerAsset);\n        getAccounting().updateOwnedAssets();\n        getTrading().orderUpdateHook(\n            _targetExchange,\n            bytes32(0),\n            Trading.UpdateType.take,\n            [payable(_makerAsset), payable(_takerAsset)],\n            [_actualReceiveAmount, _takerAssetAmount, _takerAssetAmount]\n        );\n    }\n}\n"
    },
    "./src/exchanges/ZeroExV2Adapter.sol": {
      "content": "pragma solidity 0.6.1;\npragma experimental ABIEncoderV2;\n\nimport \"../dependencies/token/IERC20.sol\";\nimport \"../fund/trading/Trading.sol\";\nimport \"../fund/hub/Hub.sol\";\nimport \"../fund/vault/Vault.sol\";\nimport \"../fund/accounting/Accounting.sol\";\nimport \"../dependencies/DSMath.sol\";\nimport \"./interfaces/IZeroExV2.sol\";\nimport \"./ExchangeAdapter.sol\";\n\n/// @title ZeroExV2Adapter Contract\n/// @author Melonport AG <team@melonport.com>\n/// @notice Adapter to 0xV2 Exchange Contract\ncontract ZeroExV2Adapter is DSMath, ExchangeAdapter {\n    /// @param orderAddresses [2] Order maker asset\n    /// @param orderAddresses [3] Order taker asset\n    /// @param orderData [0] Order maker asset data\n    /// @param orderData [1] Order taker asset data\n    modifier orderAddressesMatchOrderData(\n        address[8] memory orderAddresses,\n        bytes[4] memory orderData\n    )\n    {\n        require(\n            getAssetAddress(orderData[0]) == orderAddresses[2],\n            \"Maker asset data does not match order address in array\"\n        );\n        require(\n            getAssetAddress(orderData[1]) == orderAddresses[3],\n            \"Taker asset data does not match order address in array\"\n        );\n        _;\n    }\n\n    //  METHODS\n\n    //  PUBLIC METHODS\n\n    /// @notice Make order by pre-approving signatures\n    function makeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    )\n        public\n        override\n        onlyManager\n        notShutDown\n        orderAddressesMatchOrderData(orderAddresses, orderData)\n    {\n        ensureCanMakeOrder(orderAddresses[2]);\n\n        IZeroExV2.Order memory order = constructOrderStruct(orderAddresses, orderValues, orderData);\n        address makerAsset = getAssetAddress(orderData[0]);\n        address takerAsset = getAssetAddress(orderData[1]);\n\n        // Order parameter checks\n        getTrading().updateAndGetQuantityBeingTraded(makerAsset);\n        ensureNotInOpenMakeOrder(makerAsset);\n\n        approveAssetsMakeOrder(targetExchange, order);\n\n        IZeroExV2.OrderInfo memory orderInfo = IZeroExV2(targetExchange).getOrderInfo(order);\n        IZeroExV2(targetExchange).preSign(orderInfo.orderHash, address(this), signature);\n\n        require(\n            IZeroExV2(targetExchange).isValidSignature(\n                orderInfo.orderHash,\n                address(this),\n                signature\n            ),\n            \"INVALID_ORDER_SIGNATURE\"\n        );\n\n        updateStateMakeOrder(targetExchange, order);\n    }\n\n    // Responsibilities of takeOrder are:\n    // - check sender\n    // - check fund not shut down\n    // - check not buying own fund tokens\n    // - check price exists for asset pair\n    // - check price is recent\n    // - check price passes risk management\n    // - approve funds to be traded (if necessary)\n    // - take order from the exchange\n    // - check order was taken (if possible)\n    // - place asset in ownedAssets if not already tracked\n    /// @notice Takes an active order on the selected exchange\n    /// @dev These orders are expected to settle immediately\n    /// @param targetExchange Address of the exchange\n    /// @param orderAddresses [0] Order maker\n    /// @param orderAddresses [1] Order taker\n    /// @param orderAddresses [2] Order maker asset\n    /// @param orderAddresses [3] Order taker asset\n    /// @param orderAddresses [4] feeRecipientAddress\n    /// @param orderAddresses [5] senderAddress\n    /// @param orderValues [0] makerAssetAmount\n    /// @param orderValues [1] takerAssetAmount\n    /// @param orderValues [2] Maker fee\n    /// @param orderValues [3] Taker fee\n    /// @param orderValues [4] expirationTimeSeconds\n    /// @param orderValues [5] Salt/nonce\n    /// @param orderValues [6] Fill amount: amount of taker token to be traded\n    /// @param orderValues [7] Dexy signature mode\n    /// @param orderData [0] Encoded data specific to maker asset\n    /// @param orderData [1] Encoded data specific to taker asset\n    /// @param orderData [2] Encoded data specific to maker asset fee\n    /// @param orderData [3] Encoded data specific to taker asset fee\n    /// @param identifier Order identifier\n    /// @param signature Signature of the order.\n    function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    )\n        public\n        override\n        onlyManager\n        notShutDown\n        orderAddressesMatchOrderData(orderAddresses, orderData)\n    {\n        IZeroExV2.Order memory order = constructOrderStruct(orderAddresses, orderValues, orderData);\n\n        uint fillTakerQuantity = orderValues[6];\n\n        approveAssetsTakeOrder(targetExchange, order);\n\n        uint takerAssetFilledAmount = executeFill(targetExchange, order, fillTakerQuantity, signature);\n        require(\n            takerAssetFilledAmount == fillTakerQuantity,\n            \"Filled amount does not match desired fill amount\"\n        );\n\n        updateStateTakeOrder(targetExchange, order, fillTakerQuantity);\n    }\n\n    /// @notice Cancel the 0x make order\n    function cancelOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    )\n        public\n        override\n        orderAddressesMatchOrderData(orderAddresses, orderData)\n    {\n        IZeroExV2.Order memory order = getTrading().getZeroExV2OrderDetails(identifier);\n        ensureCancelPermitted(targetExchange, getAssetAddress(order.makerAssetData));\n\n        if (order.expirationTimeSeconds > block.timestamp) {\n            IZeroExV2(targetExchange).cancelOrder(order);\n        }\n\n        revokeApproveAssetsCancelOrder(targetExchange, order);\n\n        updateStateCancelOrder(targetExchange, order);\n    }\n\n    /// @dev Get order details\n    function getOrder(address targetExchange, uint256 id, address makerAsset)\n        public\n        view\n        override\n        returns (address, address, uint256, uint256)\n    {\n        uint orderId;\n        uint orderIndex;\n        address takerAsset;\n        uint makerQuantity;\n        uint takerQuantity;\n        (orderId, , orderIndex) = Trading(msg.sender).getOpenOrderInfo(targetExchange, makerAsset);\n        (, takerAsset, makerQuantity, takerQuantity) = Trading(msg.sender).getOrderDetails(orderIndex);\n        uint takerAssetFilledAmount = IZeroExV2(targetExchange).filled(bytes32(orderId));\n        uint makerAssetFilledAmount = mul(takerAssetFilledAmount, makerQuantity) / takerQuantity;\n        if (IZeroExV2(targetExchange).cancelled(bytes32(orderId)) || sub(takerQuantity, takerAssetFilledAmount) == 0) {\n            return (makerAsset, takerAsset, 0, 0);\n        }\n        return (\n            makerAsset,\n            takerAsset,\n            sub(makerQuantity, makerAssetFilledAmount),\n            sub(takerQuantity, takerAssetFilledAmount)\n        );\n    }\n\n    // INTERNAL METHODS\n\n    /// @notice Approves makerAsset, makerFee\n    function approveAssetsMakeOrder(address _targetExchange, IZeroExV2.Order memory _order)\n        internal\n    {\n        withdrawAndApproveAsset(\n            getAssetAddress(_order.makerAssetData),\n            getAssetProxy(_targetExchange, _order.makerAssetData),\n            _order.makerAssetAmount,\n            \"makerAsset\"\n        );\n        if (_order.makerFee > 0) {\n            bytes memory zrxAssetData = IZeroExV2(_targetExchange).ZRX_ASSET_DATA();\n            withdrawAndApproveAsset(\n                getAssetAddress(zrxAssetData),\n                getAssetProxy(_targetExchange, zrxAssetData),\n                _order.makerFee,\n                \"makerFeeAsset\"\n            );\n        }\n    }\n\n    /// @notice Approves takerAsset, takerFee\n    function approveAssetsTakeOrder(address _targetExchange, IZeroExV2.Order memory _order)\n        internal\n    {\n        withdrawAndApproveAsset(\n            getAssetAddress(_order.takerAssetData),\n            getAssetProxy(_targetExchange, _order.takerAssetData),\n            _order.takerAssetAmount,\n            \"takerAsset\"\n        );\n        if (_order.takerFee > 0) {\n            bytes memory zrxAssetData = IZeroExV2(_targetExchange).ZRX_ASSET_DATA();\n            withdrawAndApproveAsset(\n                getAssetAddress(zrxAssetData),\n                getAssetProxy(_targetExchange, zrxAssetData),\n                _order.takerFee,\n                \"takerFeeAsset\"\n            );\n        }\n    }\n\n    /// @dev Needed to avoid stack too deep error\n    function executeFill(\n        address targetExchange,\n        IZeroExV2.Order memory order,\n        uint256 takerAssetFillAmount,\n        bytes memory signature\n    )\n        internal\n        returns (uint256)\n    {\n        address makerAsset = getAssetAddress(order.makerAssetData);\n        uint preMakerAssetBalance = IERC20(makerAsset).balanceOf(address(this));\n\n        IZeroExV2.FillResults memory fillResults = IZeroExV2(targetExchange).fillOrder(\n            order,\n            takerAssetFillAmount,\n            signature\n        );\n\n        uint256 postMakerAssetBalance = IERC20(makerAsset).balanceOf(address(this));\n\n        // Account for case where makerAsset is ZRX (same as takerFee)\n        uint256 makerAssetFeesTotal;\n        if (makerAsset == getAssetAddress(IZeroExV2(targetExchange).ZRX_ASSET_DATA())) {\n            makerAssetFeesTotal = add(makerAssetFeesTotal, order.takerFee);\n        }\n\n        require(\n            postMakerAssetBalance == sub(\n                add(preMakerAssetBalance, fillResults.makerAssetFilledAmount),\n                makerAssetFeesTotal\n            ),\n            \"Maker asset balance different than expected\"\n        );\n\n        return fillResults.takerAssetFilledAmount;\n    }\n\n    /// @notice Revoke asset approvals and return assets to vault\n    function revokeApproveAssetsCancelOrder(\n        address _targetExchange,\n        IZeroExV2.Order memory _order\n    )\n        internal\n    {\n        address makerAsset = getAssetAddress(_order.makerAssetData);\n        bytes memory makerFeeAssetData = IZeroExV2(_targetExchange).ZRX_ASSET_DATA();\n        address makerFeeAsset = getAssetAddress(makerFeeAssetData);\n\n        revokeApproveAsset(\n            makerAsset,\n            getAssetProxy(_targetExchange, _order.makerAssetData),\n            _order.makerAssetAmount,\n            \"makerAsset\"\n        );\n        getTrading().returnAssetToVault(makerAsset);\n\n        if (_order.makerFee > 0) {\n            revokeApproveAsset(\n                makerFeeAsset,\n                getAssetProxy(_targetExchange, makerFeeAssetData),\n                _order.makerFee,\n                \"makerFeeAsset\"\n            );\n            if (makerFeeAsset != makerAsset) getTrading().returnAssetToVault(makerFeeAsset);\n        }\n    }\n\n    /// @dev Avoids stack too deep error\n    function updateStateCancelOrder(address targetExchange, IZeroExV2.Order memory order)\n        internal\n    {\n        address makerAsset = getAssetAddress(order.makerAssetData);\n\n        getTrading().removeOpenMakeOrder(targetExchange, makerAsset);\n        getAccounting().updateOwnedAssets();\n        getTrading().orderUpdateHook(\n            targetExchange,\n            IZeroExV2(targetExchange).getOrderInfo(order).orderHash,\n            Trading.UpdateType.cancel,\n            [address(0), address(0)],\n            [uint(0), uint(0), uint(0)]\n        );\n    }\n\n    /// @dev Avoids stack too deep error\n    function updateStateMakeOrder(address targetExchange, IZeroExV2.Order memory order)\n        internal\n    {\n        address makerAsset = getAssetAddress(order.makerAssetData);\n        address takerAsset = getAssetAddress(order.takerAssetData);\n        IZeroExV2.OrderInfo memory orderInfo = IZeroExV2(targetExchange).getOrderInfo(order);\n\n        getAccounting().addAssetToOwnedAssets(takerAsset);\n        getTrading().orderUpdateHook(\n            targetExchange,\n            orderInfo.orderHash,\n            Trading.UpdateType.make,\n            [payable(makerAsset), payable(takerAsset)],\n            [order.makerAssetAmount, order.takerAssetAmount, uint(0)]\n        );\n        getTrading().addOpenMakeOrder(\n            targetExchange,\n            makerAsset,\n            takerAsset,\n            uint256(orderInfo.orderHash),\n            order.expirationTimeSeconds\n        );\n        getTrading().addZeroExV2OrderData(orderInfo.orderHash, order);\n    }\n\n    /// @dev avoids stack too deep error\n    function updateStateTakeOrder(\n        address targetExchange,\n        IZeroExV2.Order memory order,\n        uint256 fillTakerQuantity\n    )\n        internal\n    {\n        address makerAsset = getAssetAddress(order.makerAssetData);\n        address takerAsset = getAssetAddress(order.takerAssetData);\n\n        getAccounting().addAssetToOwnedAssets(makerAsset);\n        getAccounting().updateOwnedAssets();\n        getTrading().returnAssetToVault(makerAsset);\n        getTrading().orderUpdateHook(\n            targetExchange,\n            IZeroExV2(targetExchange).getOrderInfo(order).orderHash,\n            Trading.UpdateType.take,\n            [payable(makerAsset), payable(takerAsset)],\n            [order.makerAssetAmount, order.takerAssetAmount, fillTakerQuantity]\n        );\n    }\n\n    // VIEW METHODS\n\n    function constructOrderStruct(\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData\n    )\n        internal\n        view\n        returns (IZeroExV2.Order memory order)\n    {\n        order = IZeroExV2.Order({\n            makerAddress: orderAddresses[0],\n            takerAddress: orderAddresses[1],\n            feeRecipientAddress: orderAddresses[4],\n            senderAddress: orderAddresses[5],\n            makerAssetAmount: orderValues[0],\n            takerAssetAmount: orderValues[1],\n            makerFee: orderValues[2],\n            takerFee: orderValues[3],\n            expirationTimeSeconds: orderValues[4],\n            salt: orderValues[5],\n            makerAssetData: orderData[0],\n            takerAssetData: orderData[1]\n        });\n    }\n\n    function getAssetProxy(address targetExchange, bytes memory assetData)\n        internal\n        view\n        returns (address assetProxy)\n    {\n        bytes4 assetProxyId;\n        assembly {\n            assetProxyId := and(mload(\n                add(assetData, 32)),\n                0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n            )\n        }\n        assetProxy = IZeroExV2(targetExchange).getAssetProxy(assetProxyId);\n    }\n\n    function getAssetAddress(bytes memory assetData)\n        internal\n        view\n        returns (address assetAddress)\n    {\n        assembly {\n            assetAddress := mload(add(assetData, 36))\n        }\n    }\n}\n"
    },
    "./src/exchanges/ZeroExV3Adapter.sol": {
      "content": "pragma solidity 0.6.1;\npragma experimental ABIEncoderV2;\n\nimport \"../dependencies/token/IERC20.sol\";\nimport \"../fund/trading/Trading.sol\";\nimport \"../fund/hub/Hub.sol\";\nimport \"../fund/vault/Vault.sol\";\nimport \"../fund/accounting/Accounting.sol\";\nimport \"../dependencies/DSMath.sol\";\nimport \"./interfaces/IZeroExV3.sol\";\nimport \"./ExchangeAdapter.sol\";\n\n/// @title ZeroExV3Adapter Contract\n/// @author Melonport AG <team@melonport.com>\n/// @notice Adapter to 0xV3 Exchange Contract\ncontract ZeroExV3Adapter is DSMath, ExchangeAdapter {\n\n    /// @param _orderAddresses [2] Order maker asset\n    /// @param _orderAddresses [3] Order taker asset\n    /// @param _orderAddresses [6] Order maker fee asset\n    /// @param _orderAddresses [7] Order taker fee asset\n    /// @param _orderValues [2] Order maker fee amount\n    /// @param _orderValues [3] Order taker fee amount\n    modifier orderAddressesMatchOrderData(\n        address[8] memory _orderAddresses,\n        uint[8] memory _orderValues,\n        bytes[4] memory _orderData\n    )\n    {\n        require(\n            getAssetAddress(_orderData[0]) == _orderAddresses[2],\n            \"Maker asset data does not match order address in array\"\n        );\n        require(\n            getAssetAddress(_orderData[1]) == _orderAddresses[3],\n            \"Taker asset data does not match order address in array\"\n        );\n        if (_orderValues[2] > 0) {\n            require(\n                getAssetAddress(_orderData[2]) == _orderAddresses[6],\n                \"Maker fee asset data does not match order address in array\"\n            );\n        }\n        if (_orderValues[3] > 0) {\n            require(\n                getAssetAddress(_orderData[3]) == _orderAddresses[7],\n                \"Taker fee asset data does not match order address in array\"\n            );\n        }\n        _;\n    }\n\n    //  METHODS\n\n    //  PUBLIC METHODS\n\n    /// @notice Make order by pre-approving signatures\n    /// @param _targetExchange Address of the exchange\n    /// @param _orderAddresses [2] Maker asset (Dest token)\n    /// @param _orderAddresses [3] Taker asset (Src token)\n    /// @param _orderData [0] Encoded data specific to maker asset\n    /// @param _orderData [1] Encoded data specific to taker asset\n    /// @param _signature _signature of the order.\n    function makeOrder(\n        address _targetExchange,\n        address[8] memory _orderAddresses,\n        uint[8] memory _orderValues,\n        bytes[4] memory _orderData,\n        bytes32 _identifier,\n        bytes memory _signature\n    )\n        public\n        override\n        onlyManager\n        notShutDown\n        orderAddressesMatchOrderData(_orderAddresses, _orderValues, _orderData)\n    {\n        ensureCanMakeOrder(_orderAddresses[2]);\n        Hub hub = getHub();\n\n        IZeroExV3.Order memory order = constructOrderStruct(_orderAddresses, _orderValues, _orderData);\n        address makerAsset = getAssetAddress(_orderData[0]);\n        address takerAsset = getAssetAddress(_orderData[1]);\n\n        // Order parameter checks\n        getTrading().updateAndGetQuantityBeingTraded(makerAsset);\n        ensureNotInOpenMakeOrder(makerAsset);\n\n        approveAssetsMakeOrder(_targetExchange, order);\n\n        IZeroExV3.OrderInfo memory orderInfo = IZeroExV3(_targetExchange).getOrderInfo(order);\n        IZeroExV3(_targetExchange).preSign(orderInfo.orderHash);\n\n        require(\n            IZeroExV3(_targetExchange).isValidOrderSignature(order, _signature),\n            \"INVALID_ORDER_SIGNATURE\"\n        );\n\n        updateStateMakeOrder(_targetExchange, order);\n    }\n\n    /// @notice Takes an active order on the selected exchange\n    /// @dev These orders are expected to settle immediately\n    /// @param _targetExchange Address of the exchange\n    /// @param _orderAddresses [2] Order maker asset\n    /// @param _orderAddresses [3] Order taker asset\n    /// @param _orderValues [6] Fill amount: amount of taker token to be traded\n    /// @param _signature _signature of the order.\n    function takeOrder(\n        address _targetExchange,\n        address[8] memory _orderAddresses,\n        uint[8] memory _orderValues,\n        bytes[4] memory _orderData,\n        bytes32 _identifier,\n        bytes memory _signature\n    )\n        public\n        override\n        onlyManager\n        notShutDown\n        orderAddressesMatchOrderData(_orderAddresses, _orderValues, _orderData)\n    {\n        IZeroExV3.Order memory order = constructOrderStruct(_orderAddresses, _orderValues, _orderData);\n        require(IZeroExV3(_targetExchange).isValidOrderSignature(order, _signature), \"Order _signature is invalid\");\n\n        uint256 fillTakerQuantity = _orderValues[6];\n\n        approveAssetsTakeOrder(_targetExchange, order);\n\n        uint256 takerAssetFilledAmount = executeFill(_targetExchange, order, fillTakerQuantity, _signature);\n        require(\n            takerAssetFilledAmount == fillTakerQuantity,\n            \"Filled amount does not match desired fill amount\"\n        );\n\n        updateStateTakeOrder(_targetExchange, order, fillTakerQuantity);\n    }\n\n    /// @notice Cancel the 0x make order\n    /// @param _targetExchange Address of the exchange\n    /// @param _orderAddresses [2] Order maker asset\n    /// @param _identifier Order _identifier\n    function cancelOrder(\n        address _targetExchange,\n        address[8] memory _orderAddresses,\n        uint[8] memory _orderValues,\n        bytes[4] memory _orderData,\n        bytes32 _identifier,\n        bytes memory _signature\n    )\n        public\n        override\n        orderAddressesMatchOrderData(_orderAddresses, _orderValues, _orderData)\n    {\n        IZeroExV3.Order memory order = getTrading().getZeroExV3OrderDetails(_identifier);\n        ensureCancelPermitted(_targetExchange, getAssetAddress(order.makerAssetData));\n\n        if (order.expirationTimeSeconds > block.timestamp) {\n            IZeroExV3(_targetExchange).cancelOrder(order);\n        }\n\n        revokeApproveAssetsCancelOrder(_targetExchange, order);\n\n        updateStateCancelOrder(_targetExchange, order);\n    }\n\n    /// @dev Get order details\n    function getOrder(address _targetExchange, uint256 _id, address _makerAsset)\n        public\n        view\n        override\n        returns (address, address, uint256, uint256)\n    {\n        uint orderId;\n        uint orderIndex;\n        address takerAsset;\n        uint makerQuantity;\n        uint takerQuantity;\n        (orderId, , orderIndex) = Trading(msg.sender).getOpenOrderInfo(_targetExchange, _makerAsset);\n        (, takerAsset, makerQuantity, takerQuantity) = Trading(msg.sender).getOrderDetails(orderIndex);\n        uint takerAssetFilledAmount = IZeroExV3(_targetExchange).filled(bytes32(orderId));\n        uint makerAssetFilledAmount = mul(takerAssetFilledAmount, makerQuantity) / takerQuantity;\n        if (IZeroExV3(_targetExchange).cancelled(bytes32(orderId)) || sub(takerQuantity, takerAssetFilledAmount) == 0) {\n            return (_makerAsset, takerAsset, 0, 0);\n        }\n        return (\n            _makerAsset,\n            takerAsset,\n            sub(makerQuantity, makerAssetFilledAmount),\n            sub(takerQuantity, takerAssetFilledAmount)\n        );\n    }\n\n    // INTERNAL METHODS\n\n    /// @notice Approves makerAsset, makerFeeAsset\n    function approveAssetsMakeOrder(address _targetExchange, IZeroExV3.Order memory _order)\n        internal\n    {\n        withdrawAndApproveAsset(\n            getAssetAddress(_order.makerAssetData),\n            getAssetProxy(_targetExchange, _order.makerAssetData),\n            _order.makerAssetAmount,\n            \"makerAsset\"\n        );\n        if (_order.makerFee > 0) {\n            withdrawAndApproveAsset(\n                getAssetAddress(_order.makerFeeAssetData),\n                getAssetProxy(_targetExchange, _order.makerFeeAssetData),\n                _order.makerFee,\n                \"makerFeeAsset\"\n            );\n        }\n    }\n\n    /// @notice Approves takerAsset, takerFeeAsset, protocolFee\n    function approveAssetsTakeOrder(address _targetExchange, IZeroExV3.Order memory _order)\n        internal\n    {\n        approveProtocolFeeAsset(_targetExchange);\n        withdrawAndApproveAsset(\n            getAssetAddress(_order.takerAssetData),\n            getAssetProxy(_targetExchange, _order.takerAssetData),\n            _order.takerAssetAmount,\n            \"takerAsset\"\n        );\n        if (_order.takerFee > 0) {\n            withdrawAndApproveAsset(\n                getAssetAddress(_order.takerFeeAssetData),\n                getAssetProxy(_targetExchange, _order.takerFeeAssetData),\n                _order.takerFee,\n                \"takerFeeAsset\"\n            );\n        }\n    }\n\n    function approveProtocolFeeAsset(address _targetExchange) internal {\n        address protocolFeeCollector = IZeroExV3(_targetExchange).protocolFeeCollector();\n        uint256 protocolFeeAmount = calcProtocolFeeAmount(_targetExchange);\n        if (protocolFeeCollector == address(0) || protocolFeeAmount == 0) return;\n\n        Hub hub = getHub();\n        address nativeAsset = Accounting(hub.accounting()).NATIVE_ASSET();\n\n        withdrawAndApproveAsset(nativeAsset, protocolFeeCollector, protocolFeeAmount, \"protocolFee\");\n    }\n\n    /// @dev Needed to avoid stack too deep error\n    function executeFill(\n        address _targetExchange,\n        IZeroExV3.Order memory _order,\n        uint256 _takerAssetFillAmount,\n        bytes memory _signature\n    )\n        internal\n        returns (uint256)\n    {\n        Hub hub = getHub();\n        address makerAsset = getAssetAddress(_order.makerAssetData);\n        uint preMakerAssetBalance = IERC20(makerAsset).balanceOf(address(this));\n\n        IZeroExV3.FillResults memory fillResults = IZeroExV3(_targetExchange).fillOrder(\n            _order,\n            _takerAssetFillAmount,\n            _signature\n        );\n\n        uint256 postMakerAssetBalance = IERC20(makerAsset).balanceOf(address(this));\n\n        // Account for case where makerAsset, takerFee, protocolFee are the same\n        uint256 makerAssetFeesTotal;\n        if (\n            makerAsset == Accounting(hub.accounting()).NATIVE_ASSET() &&\n            IZeroExV3(_targetExchange).protocolFeeCollector() != address(0)\n        )\n        {\n            makerAssetFeesTotal = calcProtocolFeeAmount(_targetExchange);\n        }\n        if (makerAsset == getAssetAddress(_order.takerFeeAssetData)) {\n            makerAssetFeesTotal = add(makerAssetFeesTotal, _order.takerFee);\n        }\n\n        require(\n            postMakerAssetBalance == sub(\n                add(preMakerAssetBalance, fillResults.makerAssetFilledAmount),\n                makerAssetFeesTotal\n            ),\n            \"Maker asset balance different than expected\"\n        );\n\n        return fillResults.takerAssetFilledAmount;\n    }\n\n    /// @notice Revoke asset approvals and return assets to vault\n    function revokeApproveAssetsCancelOrder(\n        address _targetExchange,\n        IZeroExV3.Order memory _order\n    )\n        internal\n    {\n        address makerAsset = getAssetAddress(_order.makerAssetData);\n        address makerFeeAsset = getAssetAddress(_order.makerFeeAssetData);\n\n        revokeApproveAsset(\n            makerAsset,\n            getAssetProxy(_targetExchange, _order.makerAssetData),\n            _order.makerAssetAmount,\n            \"makerAsset\"\n        );\n        getTrading().returnAssetToVault(makerAsset);\n\n        if (_order.makerFee > 0) {\n            revokeApproveAsset(\n                makerFeeAsset,\n                getAssetProxy(_targetExchange, _order.makerFeeAssetData),\n                _order.makerFee,\n                \"makerFeeAsset\"\n            );\n            if (makerFeeAsset != makerAsset) getTrading().returnAssetToVault(makerFeeAsset);\n        }\n    }\n\n    function updateStateCancelOrder(address _targetExchange, IZeroExV3.Order memory _order)\n        internal\n    {\n        address makerAsset = getAssetAddress(_order.makerAssetData);\n\n        getTrading().removeOpenMakeOrder(_targetExchange, makerAsset);\n        getAccounting().updateOwnedAssets();\n        getTrading().orderUpdateHook(\n            _targetExchange,\n            IZeroExV3(_targetExchange).getOrderInfo(_order).orderHash,\n            Trading.UpdateType.cancel,\n            [address(0), address(0)],\n            [uint(0), uint(0), uint(0)]\n        );\n    }\n\n    function updateStateMakeOrder(address _targetExchange, IZeroExV3.Order memory _order)\n        internal\n    {\n        address makerAsset = getAssetAddress(_order.makerAssetData);\n        address takerAsset = getAssetAddress(_order.takerAssetData);\n        IZeroExV3.OrderInfo memory orderInfo = IZeroExV3(_targetExchange).getOrderInfo(_order);\n\n        getAccounting().addAssetToOwnedAssets(takerAsset);\n        getTrading().orderUpdateHook(\n            _targetExchange,\n            orderInfo.orderHash,\n            Trading.UpdateType.make,\n            [payable(makerAsset), payable(takerAsset)],\n            [_order.makerAssetAmount, _order.takerAssetAmount, uint(0)]\n        );\n        getTrading().addOpenMakeOrder(\n            _targetExchange,\n            makerAsset,\n            takerAsset,\n            uint256(orderInfo.orderHash),\n            _order.expirationTimeSeconds\n        );\n        getTrading().addZeroExV3OrderData(orderInfo.orderHash, _order);\n    }\n\n    /// @dev Avoids stack too deep error\n    function updateStateTakeOrder(\n        address _targetExchange,\n        IZeroExV3.Order memory _order,\n        uint256 _fillTakerQuantity\n    )\n        internal\n    {\n        address makerAsset = getAssetAddress(_order.makerAssetData);\n        address takerAsset = getAssetAddress(_order.takerAssetData);\n\n        getAccounting().addAssetToOwnedAssets(makerAsset);\n        getAccounting().updateOwnedAssets();\n        getTrading().returnAssetToVault(makerAsset);\n        getTrading().orderUpdateHook(\n            _targetExchange,\n            IZeroExV3(_targetExchange).getOrderInfo(_order).orderHash,\n            Trading.UpdateType.take,\n            [payable(makerAsset), payable(takerAsset)],\n            [_order.makerAssetAmount, _order.takerAssetAmount, _fillTakerQuantity]\n        );\n    }\n\n    // VIEW METHODS\n    function calcProtocolFeeAmount(address _targetExchange) internal view returns (uint256) {\n        return mul(IZeroExV3(_targetExchange).protocolFeeMultiplier(), tx.gasprice);\n    }\n\n    function constructOrderStruct(\n        address[8] memory _orderAddresses,\n        uint[8] memory _orderValues,\n        bytes[4] memory _orderData\n    )\n        internal\n        view\n        returns (IZeroExV3.Order memory order_)\n    {\n        order_ = IZeroExV3.Order({\n            makerAddress: _orderAddresses[0],\n            takerAddress: _orderAddresses[1],\n            feeRecipientAddress: _orderAddresses[4],\n            senderAddress: _orderAddresses[5],\n            makerAssetAmount: _orderValues[0],\n            takerAssetAmount: _orderValues[1],\n            makerFee: _orderValues[2],\n            takerFee: _orderValues[3],\n            expirationTimeSeconds: _orderValues[4],\n            salt: _orderValues[5],\n            makerAssetData: _orderData[0],\n            takerAssetData: _orderData[1],\n            makerFeeAssetData: _orderData[2],\n            takerFeeAssetData: _orderData[3]\n        });\n    }\n\n    function getAssetProxy(address _targetExchange, bytes memory _assetData)\n        internal\n        view\n        returns (address assetProxy_)\n    {\n        bytes4 assetProxyId;\n        assembly {\n            assetProxyId := and(mload(\n                add(_assetData, 32)),\n                0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n            )\n        }\n        assetProxy_ = IZeroExV3(_targetExchange).getAssetProxy(assetProxyId);\n    }\n\n    function getAssetAddress(bytes memory _assetData)\n        internal\n        view\n        returns (address assetAddress_)\n    {\n        assembly {\n            assetAddress_ := mload(add(_assetData, 36))\n        }\n    }\n}\n"
    },
    "./src/factory/Factory.sol": {
      "content": "pragma solidity 0.6.1;\n\n\ncontract Factory {\n    mapping (address => bool) public childExists;\n\n    event NewInstance(\n        address indexed hub,\n        address indexed instance\n    );\n\n    function isInstance(address _child) public view returns (bool) {\n        return childExists[_child];\n    }\n}\n"
    },
    "./src/factory/FundFactory.sol": {
      "content": "pragma solidity 0.6.1;\npragma experimental ABIEncoderV2;\n\nimport \"../fund/accounting/IAccounting.sol\";\nimport \"../fund/fees/IFeeManager.sol\";\nimport \"../fund/hub/Hub.sol\";\nimport \"../fund/policies/IPolicyManager.sol\";\nimport \"../fund/participation/IParticipation.sol\";\nimport \"../fund/shares/IShares.sol\";\nimport \"../fund/trading/ITrading.sol\";\nimport \"../fund/vault/IVault.sol\";\nimport \"../version/IVersion.sol\";\nimport \"../engine/AmguConsumer.sol\";\nimport \"./Factory.sol\";\n\n/// @notice Creates fund routes and links them together\ncontract FundFactory is AmguConsumer, Factory {\n\n    event NewFund(\n        address indexed manager,\n        address indexed hub,\n        address[11] routes\n    );\n\n    IVersion public version;\n    Registry public associatedRegistry;\n    IAccountingFactory public accountingFactory;\n    IFeeManagerFactory public feeManagerFactory;\n    IParticipationFactory public participationFactory;\n    IPolicyManagerFactory public policyManagerFactory;\n    ISharesFactory public sharesFactory;\n    ITradingFactory public tradingFactory;\n    IVaultFactory public vaultFactory;\n\n    address[] public funds;\n    mapping (address => address) public managersToHubs;\n    mapping (address => Hub.Routes) public managersToRoutes;\n    mapping (address => Settings) public managersToSettings;\n\n    /// @dev Parameters stored when beginning setup\n    struct Settings {\n        string name;\n        address[] exchanges;\n        address[] adapters;\n        address denominationAsset;\n        address[] defaultInvestmentAssets;\n        address[] fees;\n        uint[] feeRates;\n        uint[] feePeriods;\n    }\n\n    constructor(\n        address _accountingFactory,\n        address _feeManagerFactory,\n        address _participationFactory,\n        address _sharesFactory,\n        address _tradingFactory,\n        address _vaultFactory,\n        address _policyManagerFactory,\n        address _version\n    )\n        public\n    {\n        accountingFactory = IAccountingFactory(_accountingFactory);\n        feeManagerFactory = IFeeManagerFactory(_feeManagerFactory);\n        participationFactory = IParticipationFactory(_participationFactory);\n        sharesFactory = ISharesFactory(_sharesFactory);\n        tradingFactory = ITradingFactory(_tradingFactory);\n        vaultFactory = IVaultFactory(_vaultFactory);\n        policyManagerFactory = IPolicyManagerFactory(_policyManagerFactory);\n        version = IVersion(_version);\n    }\n\n    function componentExists(address _component) internal pure returns (bool) {\n        return _component != address(0);\n    }\n\n    function ensureComponentNotSet(address _component) internal {\n        require(\n            !componentExists(_component),\n            \"This step has already been run\"\n        );\n    }\n\n    function ensureComponentSet(address _component) internal {\n        require(\n            componentExists(_component),\n            \"Component preprequisites not met\"\n        );\n    }\n\n    function beginSetup(\n        string memory _name,\n        address[] memory _fees,\n        uint[] memory _feeRates,\n        uint[] memory _feePeriods,\n        address[] memory _exchanges,\n        address[] memory _adapters,\n        address _denominationAsset,\n        address[] memory _defaultInvestmentAssets\n    )\n        public\n    {\n        ensureComponentNotSet(managersToHubs[msg.sender]);\n        associatedRegistry.reserveFundName(\n            msg.sender,\n            _name\n        );\n        require(\n            associatedRegistry.assetIsRegistered(_denominationAsset),\n            \"Denomination asset must be registered\"\n        );\n\n        managersToHubs[msg.sender] = address(new Hub(msg.sender, _name));\n        managersToSettings[msg.sender] = Settings(\n            _name,\n            _exchanges,\n            _adapters,\n            _denominationAsset,\n            _defaultInvestmentAssets,\n            _fees,\n            _feeRates,\n            _feePeriods\n        );\n        managersToRoutes[msg.sender].registry = address(associatedRegistry);\n        managersToRoutes[msg.sender].version = address(version);\n        managersToRoutes[msg.sender].engine = engine();\n        managersToRoutes[msg.sender].mlnToken = mlnToken();\n    }\n\n    function _createAccountingFor(address _manager)\n        internal\n    {\n        ensureComponentSet(managersToHubs[_manager]);\n        ensureComponentNotSet(managersToRoutes[_manager].accounting);\n        managersToRoutes[_manager].accounting = accountingFactory.createInstance(\n            managersToHubs[_manager],\n            managersToSettings[_manager].denominationAsset,\n            associatedRegistry.nativeAsset()\n        );\n    }\n\n    function createAccountingFor(address _manager) external amguPayable(false) payable { _createAccountingFor(_manager); }\n    function createAccounting() external amguPayable(false) payable { _createAccountingFor(msg.sender); }\n\n    function _createFeeManagerFor(address _manager)\n        internal\n    {\n        ensureComponentSet(managersToHubs[_manager]);\n        ensureComponentNotSet(managersToRoutes[_manager].feeManager);\n        managersToRoutes[_manager].feeManager = feeManagerFactory.createInstance(\n            managersToHubs[_manager],\n            managersToSettings[_manager].denominationAsset,\n            managersToSettings[_manager].fees,\n            managersToSettings[_manager].feeRates,\n            managersToSettings[_manager].feePeriods,\n            managersToRoutes[_manager].registry\n        );\n    }\n\n    function createFeeManagerFor(address _manager) external amguPayable(false) payable { _createFeeManagerFor(_manager); }\n    function createFeeManager() external amguPayable(false) payable { _createFeeManagerFor(msg.sender); }\n\n    function _createParticipationFor(address _manager)\n        internal\n    {\n        ensureComponentSet(managersToHubs[_manager]);\n        ensureComponentNotSet(managersToRoutes[_manager].participation);\n        managersToRoutes[_manager].participation = participationFactory.createInstance(\n            managersToHubs[_manager],\n            managersToSettings[_manager].defaultInvestmentAssets,\n            managersToRoutes[_manager].registry\n        );\n    }\n\n    function createParticipationFor(address _manager) external amguPayable(false) payable { _createParticipationFor(_manager); }\n    function createParticipation() external amguPayable(false) payable { _createParticipationFor(msg.sender); }\n\n    function _createPolicyManagerFor(address _manager)\n        internal\n    {\n        ensureComponentSet(managersToHubs[_manager]);\n        ensureComponentNotSet(managersToRoutes[_manager].policyManager);\n        managersToRoutes[_manager].policyManager = policyManagerFactory.createInstance(\n            managersToHubs[_manager]\n        );\n    }\n\n    function createPolicyManagerFor(address _manager) external amguPayable(false) payable { _createPolicyManagerFor(_manager); }\n    function createPolicyManager() external amguPayable(false) payable { _createPolicyManagerFor(msg.sender); }\n\n    function _createSharesFor(address _manager)\n        internal\n    {\n        ensureComponentSet(managersToHubs[_manager]);\n        ensureComponentNotSet(managersToRoutes[_manager].shares);\n        managersToRoutes[_manager].shares = sharesFactory.createInstance(\n            managersToHubs[_manager]\n        );\n    }\n\n    function createSharesFor(address _manager) external amguPayable(false) payable { _createSharesFor(_manager); }\n    function createShares() external amguPayable(false) payable { _createSharesFor(msg.sender); }\n\n    function _createTradingFor(address _manager)\n        internal\n    {\n        ensureComponentSet(managersToHubs[_manager]);\n        ensureComponentNotSet(managersToRoutes[_manager].trading);\n        managersToRoutes[_manager].trading = tradingFactory.createInstance(\n            managersToHubs[_manager],\n            managersToSettings[_manager].exchanges,\n            managersToSettings[_manager].adapters,\n            managersToRoutes[_manager].registry\n        );\n    }\n\n    function createTradingFor(address _manager) external amguPayable(false) payable { _createTradingFor(_manager); }\n    function createTrading() external amguPayable(false) payable { _createTradingFor(msg.sender); }\n\n    function _createVaultFor(address _manager)\n        internal\n    {\n        ensureComponentSet(managersToHubs[_manager]);\n        ensureComponentNotSet(managersToRoutes[_manager].vault);\n        managersToRoutes[_manager].vault = vaultFactory.createInstance(\n            managersToHubs[_manager]\n        );\n    }\n\n    function createVaultFor(address _manager) external amguPayable(false) payable { _createVaultFor(_manager); }\n    function createVault() external amguPayable(false) payable { _createVaultFor(msg.sender); }\n\n    function _completeSetupFor(address _manager) internal {\n        Hub.Routes memory routes = managersToRoutes[_manager];\n        Hub hub = Hub(managersToHubs[_manager]);\n        require(!childExists[address(hub)], \"Setup already complete\");\n        require(\n            componentExists(address(hub)) &&\n            componentExists(routes.accounting) &&\n            componentExists(routes.feeManager) &&\n            componentExists(routes.participation) &&\n            componentExists(routes.policyManager) &&\n            componentExists(routes.shares) &&\n            componentExists(routes.trading) &&\n            componentExists(routes.vault),\n            \"Components must be set before completing setup\"\n        );\n        childExists[address(hub)] = true;\n        hub.setSpokes([\n            routes.accounting,\n            routes.feeManager,\n            routes.participation,\n            routes.policyManager,\n            routes.shares,\n            routes.trading,\n            routes.vault,\n            routes.registry,\n            routes.version,\n            routes.engine,\n            routes.mlnToken\n        ]);\n        hub.setRouting();\n        hub.setPermissions();\n        funds.push(address(hub));\n        associatedRegistry.registerFund(\n            address(hub),\n            _manager,\n            managersToSettings[_manager].name\n        );\n\n        emit NewFund(\n            msg.sender,\n            address(hub),\n            [\n                routes.accounting,\n                routes.feeManager,\n                routes.participation,\n                routes.policyManager,\n                routes.shares,\n                routes.trading,\n                routes.vault,\n                routes.registry,\n                routes.version,\n                routes.engine,\n                routes.mlnToken\n            ]\n        );\n    }\n\n    function completeSetupFor(address _manager) external amguPayable(false) payable { _completeSetupFor(_manager); }\n    function completeSetup() external amguPayable(false) payable { _completeSetupFor(msg.sender); }\n\n    function getFundById(uint withId) external view returns (address) { return funds[withId]; }\n    function getLastFundId() external view returns (uint) { return funds.length - 1; }\n\n    function mlnToken() public view override returns (address) {\n        return address(associatedRegistry.mlnToken());\n    }\n    function engine() public view override returns (address) {\n        return address(associatedRegistry.engine());\n    }\n    function priceSource() public view override returns (address) {\n        return address(associatedRegistry.priceSource());\n    }\n    function registry() public view override returns (address) { return address(associatedRegistry); }\n    function getExchangesInfo(address user) public view returns (address[] memory) {\n        return (managersToSettings[user].exchanges);\n    }\n}\n"
    },
    "./src/fund/accounting/Accounting.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"../../dependencies/token/StandardToken.sol\";\nimport \"../../factory/Factory.sol\";\nimport \"../../prices/IPriceSource.sol\";\nimport \"../fees/FeeManager.sol\";\nimport \"../hub/Spoke.sol\";\nimport \"../shares/Shares.sol\";\nimport \"../trading/ITrading.sol\";\nimport \"../vault/Vault.sol\";\nimport \"../../engine/AmguConsumer.sol\";\n\ncontract Accounting is AmguConsumer, Spoke {\n\n    event AssetAddition(address indexed asset);\n    event AssetRemoval(address indexed asset);\n\n    struct Calculations {\n        uint gav;\n        uint nav;\n        uint allocatedFees;\n        uint totalSupply;\n        uint timestamp;\n    }\n\n    uint constant public MAX_OWNED_ASSETS = 20;\n    address[] public ownedAssets;\n    mapping (address => bool) public isInAssetList;\n    uint public constant SHARES_DECIMALS = 18;\n    address public NATIVE_ASSET;\n    address public DENOMINATION_ASSET;\n    uint public DENOMINATION_ASSET_DECIMALS;\n    uint public DEFAULT_SHARE_PRICE;\n    Calculations public atLastAllocation;\n\n    constructor(address _hub, address _denominationAsset, address _nativeAsset)\n        public\n        Spoke(_hub)\n    {\n        DENOMINATION_ASSET = _denominationAsset;\n        NATIVE_ASSET = _nativeAsset;\n        DENOMINATION_ASSET_DECIMALS = ERC20WithFields(DENOMINATION_ASSET).decimals();\n        DEFAULT_SHARE_PRICE = 10 ** uint(DENOMINATION_ASSET_DECIMALS);\n    }\n\n    function getOwnedAssetsLength() external view returns (uint) {\n        return ownedAssets.length;\n    }\n\n    function assetHoldings(address _asset) public returns (uint256) {\n        return add(\n            uint256(ERC20WithFields(_asset).balanceOf(routes.vault)),\n            ITrading(routes.trading).updateAndGetQuantityBeingTraded(_asset)\n        );\n    }\n\n    /// @dev Returns sparse array\n    function getFundHoldings() external returns (uint[] memory, address[] memory) {\n        uint[] memory _quantities = new uint[](ownedAssets.length);\n        address[] memory _assets = new address[](ownedAssets.length);\n        for (uint i = 0; i < ownedAssets.length; i++) {\n            address ofAsset = ownedAssets[i];\n            // assetHoldings formatting: mul(exchangeHoldings, 10 ** assetDecimal)\n            uint quantityHeld = assetHoldings(ofAsset);\n            _assets[i] = ofAsset;\n            _quantities[i] = quantityHeld;\n        }\n        return (_quantities, _assets);\n    }\n\n    function calcAssetGAV(address _queryAsset) external returns (uint) {\n        uint queryAssetQuantityHeld = assetHoldings(_queryAsset);\n        return IPriceSource(priceSource()).convertQuantity(\n            queryAssetQuantityHeld, _queryAsset, DENOMINATION_ASSET\n        );\n    }\n\n    // prices are quoted in DENOMINATION_ASSET so they use denominationDecimals\n    function calcGav() public returns (uint gav) {\n        for (uint i = 0; i < ownedAssets.length; ++i) {\n            address asset = ownedAssets[i];\n            // assetHoldings formatting: mul(exchangeHoldings, 10 ** assetDecimals)\n            uint quantityHeld = assetHoldings(asset);\n            // Dont bother with the calculations if the balance of the asset is 0\n            if (quantityHeld == 0) {\n                continue;\n            }\n            // gav as sum of mul(assetHoldings, assetPrice) with formatting: mul(mul(exchangeHoldings, exchangePrice), 10 ** shareDecimals)\n            gav = add(\n                gav,\n                IPriceSource(priceSource()).convertQuantity(\n                    quantityHeld, asset, DENOMINATION_ASSET\n                )\n            );\n        }\n        return gav;\n    }\n\n    function calcNav(uint gav, uint unclaimedFeesInDenominationAsset) public pure returns (uint) {\n        return sub(gav, unclaimedFeesInDenominationAsset);\n    }\n\n    function valuePerShare(uint totalValue, uint numShares) public pure returns (uint) {\n        require(numShares > 0, \"No shares to calculate value for\");\n        return (totalValue * 10 ** uint(SHARES_DECIMALS)) / numShares;\n    }\n\n    function performCalculations()\n        public\n        returns (\n            uint gav,\n            uint feesInDenominationAsset,  // unclaimed amount\n            uint feesInShares,             // unclaimed amount\n            uint nav,\n            uint sharePrice,\n            uint gavPerShareNetManagementFee\n        )\n    {\n        gav = calcGav();\n        uint totalSupply = Shares(routes.shares).totalSupply();\n        feesInShares = FeeManager(routes.feeManager).totalFeeAmount();\n        feesInDenominationAsset = (totalSupply == 0) ?\n            0 :\n            mul(feesInShares, gav) / add(totalSupply, feesInShares);\n        nav = calcNav(gav, feesInDenominationAsset);\n\n        // The total share supply including the value of feesInDenominationAsset, measured in shares of this fund\n        uint totalSupplyAccountingForFees = add(totalSupply, feesInShares);\n        sharePrice = (totalSupply > 0) ?\n            valuePerShare(gav, totalSupplyAccountingForFees) :\n            DEFAULT_SHARE_PRICE;\n        gavPerShareNetManagementFee = (totalSupply > 0) ?\n            valuePerShare(gav, add(totalSupply, FeeManager(routes.feeManager).managementFeeAmount())) :\n            DEFAULT_SHARE_PRICE;\n        return (gav, feesInDenominationAsset, feesInShares, nav, sharePrice, gavPerShareNetManagementFee);\n    }\n\n    function calcSharePrice() external returns (uint sharePrice) {\n        (,,,,sharePrice,) = performCalculations();\n        return sharePrice;\n    }\n\n    function calcGavPerShareNetManagementFee()\n        public\n        returns (uint gavPerShareNetManagementFee)\n    {\n        (,,,,,gavPerShareNetManagementFee) = performCalculations();\n        return gavPerShareNetManagementFee;\n    }\n\n    function getShareCostInAsset(uint _numShares, address _altAsset)\n        external\n        returns (uint)\n    {\n        uint denominationAssetQuantity = mul(\n            _numShares,\n            calcGavPerShareNetManagementFee()\n        ) / 10 ** uint(SHARES_DECIMALS);\n        return IPriceSource(priceSource()).convertQuantity(\n            denominationAssetQuantity, DENOMINATION_ASSET, _altAsset\n        );\n    }\n\n    /// @notice Reward all fees and perform some updates\n    /// @dev Anyone can call this\n    function triggerRewardAllFees()\n        external\n        amguPayable(false)\n        payable\n    {\n        updateOwnedAssets();\n        uint256 gav;\n        uint256 feesInDenomination;\n        uint256 feesInShares;\n        uint256 nav;\n        (gav, feesInDenomination, feesInShares, nav,,) = performCalculations();\n        uint256 totalSupply = Shares(routes.shares).totalSupply();\n        FeeManager(routes.feeManager).rewardAllFees();\n        atLastAllocation = Calculations({\n            gav: gav,\n            nav: nav,\n            allocatedFees: feesInDenomination,\n            totalSupply: totalSupply,\n            timestamp: block.timestamp\n        });\n    }\n\n    /// @dev Check holdings for all assets, and adjust list\n    function updateOwnedAssets() public {\n        for (uint i = 0; i < ownedAssets.length; i++) {\n            address asset = ownedAssets[i];\n            if (\n                assetHoldings(asset) == 0 &&\n                !(asset == address(DENOMINATION_ASSET)) &&\n                ITrading(routes.trading).getOpenMakeOrdersAgainstAsset(asset) == 0\n            ) {\n                _removeFromOwnedAssets(asset);\n            }\n        }\n    }\n\n    function addAssetToOwnedAssets(address _asset) external auth {\n        _addAssetToOwnedAssets(_asset);\n    }\n\n    function removeFromOwnedAssets(address _asset) external auth {\n        _removeFromOwnedAssets(_asset);\n    }\n\n    /// @dev Just pass if asset already in list\n    function _addAssetToOwnedAssets(address _asset) internal {\n        if (isInAssetList[_asset]) { return; }\n\n        require(\n            ownedAssets.length < MAX_OWNED_ASSETS,\n            \"Max owned asset limit reached\"\n        );\n        isInAssetList[_asset] = true;\n        ownedAssets.push(_asset);\n        emit AssetAddition(_asset);\n    }\n\n    /// @dev Just pass if asset not in list\n    function _removeFromOwnedAssets(address _asset) internal {\n        if (!isInAssetList[_asset]) { return; }\n\n        isInAssetList[_asset] = false;\n        for (uint i; i < ownedAssets.length; i++) {\n            if (ownedAssets[i] == _asset) {\n                ownedAssets[i] = ownedAssets[ownedAssets.length - 1];\n                ownedAssets.pop();\n                break;\n            }\n        }\n        emit AssetRemoval(_asset);\n    }\n\n    function engine() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.engine(); }\n    function mlnToken() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.mlnToken(); }\n    function priceSource() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.priceSource(); }\n    function registry() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.registry(); }\n}\n\ncontract AccountingFactory is Factory {\n    event NewInstance(\n        address indexed hub,\n        address indexed instance,\n        address denominationAsset,\n        address nativeAsset\n    );\n\n    function createInstance(address _hub, address _denominationAsset, address _nativeAsset) external returns (address) {\n        address accounting = address(new Accounting(_hub, _denominationAsset, _nativeAsset));\n        childExists[accounting] = true;\n        emit NewInstance(_hub, accounting, _denominationAsset, _nativeAsset);\n        return accounting;\n    }\n}\n\n"
    },
    "./src/fund/accounting/IAccounting.sol": {
      "content": "pragma solidity 0.6.1;\n\n/// @notice Gives metrics about a Fund\ninterface IAccounting {\n    function getOwnedAssetsLength() external view returns (uint);\n    function getFundHoldings() external returns (uint[] memory, address[] memory);\n    function calcAssetGAV(address ofAsset) external returns (uint);\n    function calcGav() external returns (uint gav);\n    function calcNav(uint gav, uint unclaimedFees) external pure returns (uint);\n    function valuePerShare(uint totalValue, uint numShares) external view returns (uint);\n    function performCalculations() external returns (\n        uint gav,\n        uint unclaimedFees,\n        uint feesInShares,\n        uint nav,\n        uint sharePrice,\n        uint gavPerShareNetManagementFee\n    );\n    function calcSharePrice() external returns (uint);\n    function calcGavPerShareNetManagementFee() external returns (uint);\n}\n\ninterface IAccountingFactory {\n    function createInstance(address _hub, address _denominationAsset, address _nativeAsset) external returns (address);\n}\n"
    },
    "./src/fund/fees/FeeManager.sol": {
      "content": "pragma solidity 0.6.1;\npragma experimental ABIEncoderV2;\n\nimport \"./IFee.sol\";\nimport \"../hub/Spoke.sol\";\nimport \"../shares/Shares.sol\";\nimport \"../../factory/Factory.sol\";\nimport \"../../version/Registry.sol\";\nimport \"../../dependencies/DSMath.sol\";\nimport \"./IFeeManager.sol\";\n\n/// @notice Manages and allocates fees for a particular fund\ncontract FeeManager is DSMath, Spoke {\n\n    event FeeReward(uint shareQuantity);\n    event FeeRegistration(address fee);\n\n    struct FeeInfo {\n        address feeAddress;\n        uint feeRate;\n        uint feePeriod;\n    }\n\n    IFee[] public fees;\n    mapping (address => bool) public feeIsRegistered;\n\n    constructor(address _hub, address _denominationAsset, address[] memory _fees, uint[] memory _rates, uint[] memory _periods, address _registry) Spoke(_hub) public {\n        for (uint i = 0; i < _fees.length; i++) {\n            require(\n                Registry(_registry).isFeeRegistered(_fees[i]),\n                \"Fee must be known to Registry\"\n            );\n            register(_fees[i], _rates[i], _periods[i], _denominationAsset);\n        }\n        if (fees.length > 0) {\n            require(\n                fees[0].identifier() == 0,\n                \"Management fee must be at 0 index\"\n            );\n        }\n        if (fees.length > 1) {\n            require(\n                fees[1].identifier() == 1,\n                \"Performance fee must be at 1 index\"\n            );\n        }\n    }\n\n    function register(address feeAddress, uint feeRate, uint feePeriod, address denominationAsset) internal {\n        require(!feeIsRegistered[feeAddress], \"Fee already registered\");\n        feeIsRegistered[feeAddress] = true;\n        fees.push(IFee(feeAddress));\n        IFee(feeAddress).initializeForUser(feeRate, feePeriod, denominationAsset);  // initialize state\n        emit FeeRegistration(feeAddress);\n    }\n\n    function totalFeeAmount() external returns (uint total) {\n        for (uint i = 0; i < fees.length; i++) {\n            total = add(total, fees[i].feeAmount());\n        }\n        return total;\n    }\n\n    /// @dev Shares to be inflated after update state\n    function _rewardFee(IFee fee) internal {\n        require(feeIsRegistered[address(fee)], \"Fee is not registered\");\n        uint rewardShares = fee.feeAmount();\n        fee.updateState();\n        Shares(routes.shares).createFor(hub.manager(), rewardShares);\n        emit FeeReward(rewardShares);\n    }\n\n    function _rewardAllFees() internal {\n        for (uint i = 0; i < fees.length; i++) {\n            _rewardFee(fees[i]);\n        }\n    }\n\n    /// @dev Used when calling from other components\n    function rewardAllFees() public auth { _rewardAllFees(); }\n\n    /// @dev Convenience function; anyone can reward management fee any time\n    /// @dev Convention that management fee is 0\n    function rewardManagementFee() public {\n        if (fees.length >= 1) _rewardFee(fees[0]);\n    }\n\n    /// @dev Convenience function\n    /// @dev Convention that management fee is 0\n    function managementFeeAmount() external returns (uint) {\n        if (fees.length < 1) return 0;\n        return fees[0].feeAmount();\n    }\n\n    /// @dev Convenience function\n    /// @dev Convention that performace fee is 1\n    function performanceFeeAmount() external returns (uint) {\n        if (fees.length < 2) return 0;\n        return fees[1].feeAmount();\n    }\n}\n\ncontract FeeManagerFactory is Factory {\n    function createInstance(\n        address _hub,\n        address _denominationAsset,\n        address[] memory _fees,\n        uint[] memory _feeRates,\n        uint[] memory _feePeriods,\n        address _registry\n    ) public returns (address) {\n        address feeManager = address(\n            new FeeManager(_hub, _denominationAsset, _fees, _feeRates, _feePeriods, _registry)\n        );\n        childExists[feeManager] = true;\n        emit NewInstance(_hub, feeManager);\n        return feeManager;\n    }\n}\n"
    },
    "./src/fund/fees/IFee.sol": {
      "content": "pragma solidity 0.6.1;\n\n/// @dev Exposes \"feeAmount\", which maps fund state and fee state to uint\n/// @dev Notice that \"feeAmount\" *may* change contract state\n/// @dev Also exposes \"updateState\", which changes fee's internal state\ninterface IFee {\n    function initializeForUser(uint feeRate, uint feePeriod, address denominationAsset) external;\n    function feeAmount() external returns (uint);\n    function updateState() external;\n\n    /// @notice Used to enforce a convention\n    function identifier() external view returns (uint);\n}\n\n"
    },
    "./src/fund/fees/IFeeManager.sol": {
      "content": "pragma solidity 0.6.1;\n\ninterface IFeeManagerFactory {\n    function createInstance(\n        address _hub,\n        address _denominationAsset,\n        address[] calldata _fees,\n        uint[] calldata _feeRates,\n        uint[] calldata _feePeriods,\n        address _registry\n    ) external returns (address);\n}\n"
    },
    "./src/fund/fees/ManagementFee.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"./FeeManager.sol\";\nimport \"../hub/Hub.sol\";\nimport \"../shares/Shares.sol\";\nimport \"../../dependencies/DSMath.sol\";\n\ncontract ManagementFee is DSMath {\n\n    uint public DIVISOR = 10 ** 18;\n\n    mapping (address => uint) public managementFeeRate;\n    mapping (address => uint) public lastPayoutTime;\n\n    function feeAmount() external view returns (uint feeInShares) {\n        Hub hub = FeeManager(msg.sender).hub();\n        Shares shares = Shares(hub.shares());\n        if (shares.totalSupply() == 0 || managementFeeRate[msg.sender] == 0) {\n            feeInShares = 0;\n        } else {\n            uint timePassed = sub(block.timestamp, lastPayoutTime[msg.sender]);\n            uint preDilutionFeeShares = mul(mul(shares.totalSupply(), managementFeeRate[msg.sender]) / DIVISOR, timePassed) / 365 days;\n            feeInShares =\n                mul(preDilutionFeeShares, shares.totalSupply()) /\n                sub(shares.totalSupply(), preDilutionFeeShares);\n        }\n        return feeInShares;\n    }\n\n    function initializeForUser(uint feeRate, uint feePeriod, address denominationAsset) external {\n        require(lastPayoutTime[msg.sender] == 0);\n        managementFeeRate[msg.sender] = feeRate;\n        lastPayoutTime[msg.sender] = block.timestamp;\n    }\n\n    function updateState() external {\n        lastPayoutTime[msg.sender] = block.timestamp;\n    }\n\n    function identifier() external pure returns (uint) {\n        return 0;\n    }\n}\n\n"
    },
    "./src/fund/fees/PerformanceFee.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"./FeeManager.sol\";\nimport \"../accounting/Accounting.sol\";\nimport \"../hub/Hub.sol\";\nimport \"../shares/Shares.sol\";\nimport \"../../dependencies/DSMath.sol\";\n\ncontract PerformanceFee is DSMath {\n\n    event HighWaterMarkUpdate(address indexed feeManager, uint indexed hwm);\n\n    uint public constant DIVISOR = 10 ** 18;\n    uint public constant REDEEM_WINDOW = 1 weeks;\n\n    mapping(address => uint) public highWaterMark;\n    mapping(address => uint) public lastPayoutTime;\n    mapping(address => uint) public initializeTime;\n    mapping(address => uint) public performanceFeeRate;\n    mapping(address => uint) public performanceFeePeriod;\n\n    /// @notice Sets initial state of the fee for a user\n    function initializeForUser(uint feeRate, uint feePeriod, address denominationAsset) external {\n        require(lastPayoutTime[msg.sender] == 0, \"Already initialized\");\n        performanceFeeRate[msg.sender] = feeRate;\n        performanceFeePeriod[msg.sender] = feePeriod;\n        highWaterMark[msg.sender] = 10 ** uint(ERC20WithFields(denominationAsset).decimals());\n        lastPayoutTime[msg.sender] = block.timestamp;\n        initializeTime[msg.sender] = block.timestamp;\n    }\n\n    /// @notice Assumes management fee is zero\n    function feeAmount() external returns (uint feeInShares) {\n        Hub hub = FeeManager(msg.sender).hub();\n        Accounting accounting = Accounting(hub.accounting());\n        Shares shares = Shares(hub.shares());\n        uint gav = accounting.calcGav();\n        uint gavPerShare = shares.totalSupply() > 0 ?\n            accounting.valuePerShare(gav, shares.totalSupply())\n            : accounting.DEFAULT_SHARE_PRICE();\n        if (\n            gavPerShare > highWaterMark[msg.sender] &&\n            shares.totalSupply() != 0 &&\n            gav != 0\n        ) {\n            uint sharePriceGain = sub(gavPerShare, highWaterMark[msg.sender]);\n            uint totalGain = mul(sharePriceGain, shares.totalSupply()) / DIVISOR;\n            uint feeInAsset = mul(totalGain, performanceFeeRate[msg.sender]) / DIVISOR;\n            uint preDilutionFee = mul(shares.totalSupply(), feeInAsset) / gav;\n            feeInShares =\n                mul(preDilutionFee, shares.totalSupply()) /\n                sub(shares.totalSupply(), preDilutionFee);\n        }\n        else {\n            feeInShares = 0;\n        }\n        return feeInShares;\n    }\n\n    function canUpdate(address _who) public view returns (bool) {\n        uint timeSinceInit = sub(\n            block.timestamp,\n            initializeTime[_who]\n        );\n        uint secondsSinceLastPeriod = timeSinceInit % performanceFeePeriod[_who];\n        uint lastPeriodEnd = sub(block.timestamp, secondsSinceLastPeriod);\n        return (\n            secondsSinceLastPeriod <= REDEEM_WINDOW &&\n            lastPayoutTime[_who] < lastPeriodEnd\n        );\n    }\n\n    /// @notice Assumes management fee is zero\n    function updateState() external {\n        require(lastPayoutTime[msg.sender] != 0, \"Not initialized\");\n        require(\n            canUpdate(msg.sender),\n            \"Not within a update window or already updated this period\"\n        );\n        Hub hub = FeeManager(msg.sender).hub();\n        Accounting accounting = Accounting(hub.accounting());\n        Shares shares = Shares(hub.shares());\n        uint gav = accounting.calcGav();\n        uint currentGavPerShare = accounting.valuePerShare(gav, shares.totalSupply());\n        require(\n            currentGavPerShare > highWaterMark[msg.sender],\n            \"Current share price does not pass high water mark\"\n        );\n        lastPayoutTime[msg.sender] = block.timestamp;\n        highWaterMark[msg.sender] = currentGavPerShare;\n        emit HighWaterMarkUpdate(msg.sender, currentGavPerShare);\n    }\n\n    function identifier() external pure returns (uint) {\n        return 1;\n    }\n}\n"
    },
    "./src/fund/hub/Hub.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"../../dependencies/DSGuard.sol\";\nimport \"./Spoke.sol\";\nimport \"../../version/Registry.sol\";\n\n/// @notice Router for communication between components\n/// @notice Has one or more Spokes\ncontract Hub is DSGuard {\n\n    event FundShutDown();\n\n    struct Routes {\n        address accounting;\n        address feeManager;\n        address participation;\n        address policyManager;\n        address shares;\n        address trading;\n        address vault;\n        address registry;\n        address version;\n        address engine;\n        address mlnToken;\n    }\n\n    Routes public routes;\n    address public manager;\n    address public creator;\n    string public name;\n    bool public isShutDown;\n    bool public spokesSet;\n    bool public routingSet;\n    bool public permissionsSet;\n    uint public creationTime;\n    mapping (address => bool) public isSpoke;\n\n    constructor(address _manager, string memory _name) public {\n        creator = msg.sender;\n        manager = _manager;\n        name = _name;\n        creationTime = block.timestamp;\n    }\n\n    modifier onlyCreator() {\n        require(msg.sender == creator, \"Only creator can do this\");\n        _;\n    }\n\n    function shutDownFund() external {\n        require(msg.sender == routes.version);\n        isShutDown = true;\n        emit FundShutDown();\n    }\n\n    function setSpokes(address[11] calldata _spokes) external onlyCreator {\n        require(!spokesSet, \"Spokes already set\");\n        for (uint i = 0; i < _spokes.length; i++) {\n            isSpoke[_spokes[i]] = true;\n        }\n        routes.accounting = _spokes[0];\n        routes.feeManager = _spokes[1];\n        routes.participation = _spokes[2];\n        routes.policyManager = _spokes[3];\n        routes.shares = _spokes[4];\n        routes.trading = _spokes[5];\n        routes.vault = _spokes[6];\n        routes.registry = _spokes[7];\n        routes.version = _spokes[8];\n        routes.engine = _spokes[9];\n        routes.mlnToken = _spokes[10];\n        spokesSet = true;\n    }\n\n    function setRouting() external onlyCreator {\n        require(spokesSet, \"Spokes must be set\");\n        require(!routingSet, \"Routing already set\");\n        address[11] memory spokes = [\n            routes.accounting, routes.feeManager, routes.participation,\n            routes.policyManager, routes.shares, routes.trading,\n            routes.vault, routes.registry,\n            routes.version, routes.engine, routes.mlnToken\n        ];\n        Spoke(routes.accounting).initialize(spokes);\n        Spoke(routes.feeManager).initialize(spokes);\n        Spoke(routes.participation).initialize(spokes);\n        Spoke(routes.policyManager).initialize(spokes);\n        Spoke(routes.shares).initialize(spokes);\n        Spoke(routes.trading).initialize(spokes);\n        Spoke(routes.vault).initialize(spokes);\n        routingSet = true;\n    }\n\n    function setPermissions() external onlyCreator {\n        require(spokesSet, \"Spokes must be set\");\n        require(routingSet, \"Routing must be set\");\n        require(!permissionsSet, \"Permissioning already set\");\n        permit(routes.participation, routes.vault, bytes4(keccak256('withdraw(address,uint256)')));\n        permit(routes.trading, routes.vault, bytes4(keccak256('withdraw(address,uint256)')));\n        permit(routes.participation, routes.shares, bytes4(keccak256('createFor(address,uint256)')));\n        permit(routes.participation, routes.shares, bytes4(keccak256('destroyFor(address,uint256)')));\n        permit(routes.feeManager, routes.shares, bytes4(keccak256('createFor(address,uint256)')));\n        permit(routes.participation, routes.accounting, bytes4(keccak256('addAssetToOwnedAssets(address)')));\n        permit(routes.trading, routes.accounting, bytes4(keccak256('addAssetToOwnedAssets(address)')));\n        permit(routes.trading, routes.accounting, bytes4(keccak256('removeFromOwnedAssets(address)')));\n        permit(routes.accounting, routes.feeManager, bytes4(keccak256('rewardAllFees()')));\n        permit(manager, routes.policyManager, bytes4(keccak256('register(bytes4,address)')));\n        permit(manager, routes.policyManager, bytes4(keccak256('batchRegister(bytes4[],address[])')));\n        permit(manager, routes.participation, bytes4(keccak256('enableInvestment(address[])')));\n        permit(manager, routes.participation, bytes4(keccak256('disableInvestment(address[])')));\n        permit(manager, routes.trading, bytes4(keccak256('addExchange(address,address)')));\n        permissionsSet = true;\n    }\n\n    function vault() external view returns (address) { return routes.vault; }\n    function accounting() external view returns (address) { return routes.accounting; }\n    function priceSource() external view returns (address) { return Registry(routes.registry).priceSource(); }\n    function participation() external view returns (address) { return routes.participation; }\n    function trading() external view returns (address) { return routes.trading; }\n    function shares() external view returns (address) { return routes.shares; }\n    function registry() external view returns (address) { return routes.registry; }\n    function version() external view returns (address) { return routes.version; }\n    function policyManager() external view returns (address) { return routes.policyManager; }\n}\n\n"
    },
    "./src/fund/hub/Spoke.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"./Hub.sol\";\nimport \"../../dependencies/DSAuth.sol\";\n\n/// @notice Has one Hub\ncontract Spoke is DSAuth {\n    Hub public hub;\n    Hub.Routes public routes;\n    bool public initialized;\n\n    modifier onlyInitialized() {\n        require(initialized, \"Component not yet initialized\");\n        _;\n    }\n\n    modifier notShutDown() {\n        require(!hub.isShutDown(), \"Hub is shut down\");\n        _;\n    }\n\n    constructor(address _hub) public {\n        hub = Hub(_hub);\n        setAuthority(hub);\n        setOwner(address(hub)); // temporary, to allow initialization\n    }\n\n    function initialize(address[11] calldata _spokes) external auth {\n        require(msg.sender == address(hub));\n        require(!initialized, \"Already initialized\");\n        routes = Hub.Routes(\n            _spokes[0],\n            _spokes[1],\n            _spokes[2],\n            _spokes[3],\n            _spokes[4],\n            _spokes[5],\n            _spokes[6],\n            _spokes[7],\n            _spokes[8],\n            _spokes[9],\n            _spokes[10]\n        );\n        initialized = true;\n        setOwner(address(0));\n    }\n\n    function engine() public view virtual returns (address) { return routes.engine; }\n    function mlnToken() public view virtual returns (address) { return routes.mlnToken; }\n    function priceSource() public view virtual returns (address) { return hub.priceSource(); }\n    function version() public view virtual returns (address) { return routes.version; }\n    function registry() public view virtual returns (address) { return routes.registry; }\n}\n\n"
    },
    "./src/fund/participation/IParticipation.sol": {
      "content": "pragma solidity 0.6.1;\n\n/// @notice Investor Fund interactions\n/// @notice Handles redemptions and requests for investment\ninterface IParticipation {\n    function requestInvestment(\n        uint requestedShares,\n        uint investmentAmount,\n        address investmentAsset\n    ) external payable;\n    function hasRequest(address) external view returns (bool);\n    function cancelRequest() external payable;\n    function executeRequestFor(address requestOwner) external payable;\n    function redeem() external;\n    function redeemWithConstraints(uint shareQuantity, address[] calldata requestedAssets) external;\n}\n\ninterface IParticipationFactory {\n    function createInstance(address _hub, address[] calldata _defaultAssets, address _registry) external returns (address);\n}\n"
    },
    "./src/fund/participation/Participation.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"../vault/Vault.sol\";\nimport \"../shares/Shares.sol\";\nimport \"../policies/PolicyManager.sol\";\nimport \"../hub/Spoke.sol\";\nimport \"../accounting/Accounting.sol\";\nimport \"../../prices/IPriceSource.sol\";\nimport \"../../factory/Factory.sol\";\nimport \"../../engine/AmguConsumer.sol\";\nimport \"../../dependencies/token/IERC20.sol\";\nimport \"../../dependencies/DSMath.sol\";\nimport \"../../dependencies/TokenUser.sol\";\n\n/// @notice Entry and exit point for investors\ncontract Participation is TokenUser, AmguConsumer, Spoke {\n    event EnableInvestment (address[] asset);\n    event DisableInvestment (address[] assets);\n\n    event InvestmentRequest (\n        address indexed requestOwner,\n        address indexed investmentAsset,\n        uint requestedShares,\n        uint investmentAmount\n    );\n\n    event RequestExecution (\n        address indexed requestOwner,\n        address indexed executor,\n        address indexed investmentAsset,\n        uint investmentAmount,\n        uint requestedShares\n    );\n\n    event CancelRequest (\n        address indexed requestOwner\n    );\n\n    event Redemption (\n        address indexed redeemer,\n        address[] assets,\n        uint[] assetQuantities,\n        uint redeemedShares\n    );\n\n    struct Request {\n        address investmentAsset;\n        uint investmentAmount;\n        uint requestedShares;\n        uint timestamp;\n    }\n\n    uint constant public SHARES_DECIMALS = 18;\n    uint constant public REQUEST_LIFESPAN = 1 days;\n\n    mapping (address => Request) public requests;\n    mapping (address => bool) public investAllowed;\n    mapping (address => bool) public hasInvested; // for information purposes only (read)\n\n    address[] public historicalInvestors; // for information purposes only (read)\n\n    constructor(address _hub, address[] memory _defaultAssets, address _registry)\n        public\n        Spoke(_hub)\n    {\n        routes.registry = _registry;\n        _enableInvestment(_defaultAssets);\n    }\n\n    receive() external payable {}\n\n    function _enableInvestment(address[] memory _assets) internal {\n        for (uint i = 0; i < _assets.length; i++) {\n            require(\n                Registry(routes.registry).assetIsRegistered(_assets[i]),\n                \"Asset not registered\"\n            );\n            investAllowed[_assets[i]] = true;\n        }\n        emit EnableInvestment(_assets);\n    }\n\n    function enableInvestment(address[] calldata _assets) external auth {\n        _enableInvestment(_assets);\n    }\n\n    function disableInvestment(address[] calldata _assets) external auth {\n        for (uint i = 0; i < _assets.length; i++) {\n            investAllowed[_assets[i]] = false;\n        }\n        emit DisableInvestment(_assets);\n    }\n\n    function hasRequest(address _who) public view returns (bool) {\n        return requests[_who].timestamp > 0;\n    }\n\n    function hasExpiredRequest(address _who) public view returns (bool) {\n        return block.timestamp > add(requests[_who].timestamp, REQUEST_LIFESPAN);\n    }\n\n    /// @notice Whether request is OK and invest delay is being respected\n    /// @dev Request valid if price update happened since request and not expired\n    /// @dev If no shares exist and not expired, request can be executed immediately\n    function hasValidRequest(address _who) public view returns (bool) {\n        IPriceSource priceSource = IPriceSource(priceSource());\n        bool delayRespectedOrNoShares = requests[_who].timestamp < priceSource.getLastUpdate() ||\n            Shares(routes.shares).totalSupply() == 0;\n\n        return hasRequest(_who) &&\n            delayRespectedOrNoShares &&\n            !hasExpiredRequest(_who) &&\n            requests[_who].investmentAmount > 0 &&\n            requests[_who].requestedShares > 0;\n    }\n\n    function requestInvestment(\n        uint requestedShares,\n        uint investmentAmount,\n        address investmentAsset\n    )\n        external\n        notShutDown\n        payable\n        amguPayable(true)\n        onlyInitialized\n    {\n        PolicyManager(routes.policyManager).preValidate(\n            bytes4(keccak256(\"requestInvestment(uint256,uint256,address)\")),\n            [msg.sender, address(0), address(0), investmentAsset, address(0)],\n            [uint(0), uint(0), uint(0)],\n            bytes32(0)\n        );\n        require(\n            investAllowed[investmentAsset],\n            \"Investment not allowed in this asset\"\n        );\n        safeTransferFrom(\n            investmentAsset, msg.sender, address(this), investmentAmount\n        );\n        require(\n            requests[msg.sender].timestamp == 0,\n            \"Only one request can exist at a time\"\n        );\n        requests[msg.sender] = Request({\n            investmentAsset: investmentAsset,\n            investmentAmount: investmentAmount,\n            requestedShares: requestedShares,\n            timestamp: block.timestamp\n        });\n        PolicyManager(routes.policyManager).postValidate(\n            bytes4(keccak256(\"requestInvestment(uint256,uint256,address)\")),\n            [msg.sender, address(0), address(0), investmentAsset, address(0)],\n            [uint(0), uint(0), uint(0)],\n            bytes32(0)\n        );\n\n        emit InvestmentRequest(\n            msg.sender,\n            investmentAsset,\n            requestedShares,\n            investmentAmount\n        );\n    }\n\n    function _cancelRequestFor(address requestOwner) internal {\n        require(hasRequest(requestOwner), \"No request to cancel\");\n        IPriceSource priceSource = IPriceSource(priceSource());\n        Request memory request = requests[requestOwner];\n        require(\n            !priceSource.hasValidPrice(request.investmentAsset) ||\n            hasExpiredRequest(requestOwner) ||\n            hub.isShutDown(),\n            \"No cancellation condition was met\"\n        );\n        IERC20 investmentAsset = IERC20(request.investmentAsset);\n        uint investmentAmount = request.investmentAmount;\n        delete requests[requestOwner];\n        msg.sender.transfer(Registry(routes.registry).incentive());\n        safeTransfer(address(investmentAsset), requestOwner, investmentAmount);\n\n        emit CancelRequest(requestOwner);\n    }\n\n    /// @notice Can only cancel when no price, request expired or fund shut down\n    /// @dev Only request owner can cancel their request\n    function cancelRequest() external payable amguPayable(false) {\n        _cancelRequestFor(msg.sender);\n    }\n\n    function cancelRequestFor(address requestOwner)\n        external\n        payable\n        amguPayable(false)\n    {\n        _cancelRequestFor(requestOwner);\n    }\n\n    function executeRequestFor(address requestOwner)\n        external\n        notShutDown\n        amguPayable(false)\n        payable\n    {\n        Request memory request = requests[requestOwner];\n        require(\n            hasValidRequest(requestOwner),\n            \"No valid request for this address\"\n        );\n        require(\n            IPriceSource(priceSource()).hasValidPrice(request.investmentAsset),\n            \"Price not valid\"\n        );\n\n        FeeManager(routes.feeManager).rewardManagementFee();\n\n        uint totalShareCostInInvestmentAsset = Accounting(routes.accounting)\n            .getShareCostInAsset(\n                request.requestedShares,\n                request.investmentAsset\n            );\n\n        require(\n            totalShareCostInInvestmentAsset <= request.investmentAmount,\n            \"Invested amount too low\"\n        );\n        // send necessary amount of investmentAsset to vault\n        safeTransfer(\n            request.investmentAsset,\n            routes.vault,\n            totalShareCostInInvestmentAsset\n        );\n\n        uint investmentAssetChange = sub(\n            request.investmentAmount,\n            totalShareCostInInvestmentAsset\n        );\n\n        // return investmentAsset change to request owner\n        if (investmentAssetChange > 0) {\n            safeTransfer(\n                request.investmentAsset,\n                requestOwner,\n                investmentAssetChange\n            );\n        }\n\n        msg.sender.transfer(Registry(routes.registry).incentive());\n\n        Shares(routes.shares).createFor(requestOwner, request.requestedShares);\n        Accounting(routes.accounting).addAssetToOwnedAssets(request.investmentAsset);\n\n        if (!hasInvested[requestOwner]) {\n            hasInvested[requestOwner] = true;\n            historicalInvestors.push(requestOwner);\n        }\n\n        emit RequestExecution(\n            requestOwner,\n            msg.sender,\n            request.investmentAsset,\n            request.investmentAmount,\n            request.requestedShares\n        );\n        delete requests[requestOwner];\n    }\n\n    function getOwedPerformanceFees(uint shareQuantity)\n        public\n        returns (uint remainingShareQuantity)\n    {\n        Shares shares = Shares(routes.shares);\n\n        if (msg.sender == hub.manager()) {\n            return 0;\n        }\n\n        uint totalPerformanceFee = FeeManager(routes.feeManager).performanceFeeAmount();\n        // The denominator is augmented because performanceFeeAmount() accounts for inflation\n        // Since shares are directly transferred, we don't need to account for inflation in this case\n        uint performanceFeePortion = mul(\n            totalPerformanceFee,\n            shareQuantity\n        ) / add(shares.totalSupply(), totalPerformanceFee);\n        return performanceFeePortion;\n    }\n\n    /// @dev \"Happy path\" (no asset throws & quantity available)\n    /// @notice Redeem all shares and across all assets\n    function redeem() external {\n        uint ownedShares = Shares(routes.shares).balanceOf(msg.sender);\n        redeemQuantity(ownedShares);\n    }\n\n    /// @notice Redeem shareQuantity across all assets\n    function redeemQuantity(uint shareQuantity) public {\n        address[] memory assetList;\n        (, assetList) = Accounting(routes.accounting).getFundHoldings();\n        redeemWithConstraints(shareQuantity, assetList);\n    }\n\n    // TODO: reconsider the scenario where the user has enough funds to force shutdown on a large trade (any way around this?)\n    /// @dev Redeem only selected assets (used only when an asset throws)\n    function redeemWithConstraints(uint shareQuantity, address[] memory requestedAssets) public {\n        Shares shares = Shares(routes.shares);\n        require(\n            shares.balanceOf(msg.sender) >= shareQuantity &&\n            shares.balanceOf(msg.sender) > 0,\n            \"Sender does not have enough shares to fulfill request\"\n        );\n\n        uint owedPerformanceFees = 0;\n        if (\n            IPriceSource(priceSource()).hasValidPrices(requestedAssets) &&\n            msg.sender != hub.manager()\n        ) {\n            FeeManager(routes.feeManager).rewardManagementFee();\n            owedPerformanceFees = getOwedPerformanceFees(shareQuantity);\n            shares.destroyFor(msg.sender, owedPerformanceFees);\n            shares.createFor(hub.manager(), owedPerformanceFees);\n        }\n        uint remainingShareQuantity = sub(shareQuantity, owedPerformanceFees);\n\n        address ofAsset;\n        uint[] memory ownershipQuantities = new uint[](requestedAssets.length);\n        address[] memory redeemedAssets = new address[](requestedAssets.length);\n        // Check whether enough assets held by fund\n        Accounting accounting = Accounting(routes.accounting);\n        for (uint i = 0; i < requestedAssets.length; ++i) {\n            ofAsset = requestedAssets[i];\n            if (ofAsset == address(0)) continue;\n            require(\n                accounting.isInAssetList(ofAsset),\n                \"Requested asset not in asset list\"\n            );\n            for (uint j = 0; j < redeemedAssets.length; j++) {\n                require(\n                    ofAsset != redeemedAssets[j],\n                    \"Asset can only be redeemed once\"\n                );\n            }\n            redeemedAssets[i] = ofAsset;\n            uint quantityHeld = accounting.assetHoldings(ofAsset);\n            if (quantityHeld == 0) continue;\n\n            // participant's ownership percentage of asset holdings\n            ownershipQuantities[i] = mul(quantityHeld, remainingShareQuantity) / shares.totalSupply();\n        }\n\n        shares.destroyFor(msg.sender, remainingShareQuantity);\n\n        // Transfer owned assets\n        for (uint k = 0; k < requestedAssets.length; ++k) {\n            ofAsset = requestedAssets[k];\n            if (ownershipQuantities[k] == 0) {\n                continue;\n            } else {\n                Vault(routes.vault).withdraw(ofAsset, ownershipQuantities[k]);\n                safeTransfer(ofAsset, msg.sender, ownershipQuantities[k]);\n            }\n        }\n        emit Redemption(\n            msg.sender,\n            requestedAssets,\n            ownershipQuantities,\n            remainingShareQuantity\n        );\n    }\n\n    function getHistoricalInvestors() external view returns (address[] memory) {\n        return historicalInvestors;\n    }\n\n    function engine() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.engine(); }\n    function mlnToken() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.mlnToken(); }\n    function priceSource() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.priceSource(); }\n    function registry() public view override(AmguConsumer, Spoke) returns (address) { return Spoke.registry(); }\n}\n\ncontract ParticipationFactory is Factory {\n    event NewInstance(\n        address indexed hub,\n        address indexed instance,\n        address[] defaultAssets,\n        address registry\n    );\n\n    function createInstance(address _hub, address[] calldata _defaultAssets, address _registry)\n        external\n        returns (address)\n    {\n        address participation = address(\n            new Participation(_hub, _defaultAssets, _registry)\n        );\n        childExists[participation] = true;\n        emit NewInstance(_hub, participation, _defaultAssets, _registry);\n        return participation;\n    }\n}\n\n"
    },
    "./src/fund/policies/AddressList.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"../../dependencies/DSAuth.sol\";\n\n/// @notice Generic AddressList\ncontract AddressList is DSAuth {\n\n    event ListAddition(address[] ones);\n\n    mapping(address => bool) internal list;\n    address[] internal mirror;\n\n    constructor(address[] memory _assets) public {\n        for (uint i = 0; i < _assets.length; i++) {\n            if (!isMember(_assets[i])) { // filter duplicates in _assets\n                list[_assets[i]] = true;\n                mirror.push(_assets[i]);\n            }\n        }\n        emit ListAddition(_assets);\n    }\n\n    /// @return whether an asset is in the list\n    function isMember(address _asset) public view returns (bool) {\n        return list[_asset];\n    }\n\n    /// @return number of assets specified in the list\n    function getMemberCount() external view returns (uint) {\n        return mirror.length;\n    }\n\n    /// @return array of all listed asset addresses\n    function getMembers() external view returns (address[] memory) { return mirror; }\n}\n"
    },
    "./src/fund/policies/compliance/UserWhitelist.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"../../../dependencies/DSAuth.sol\";\n\ncontract UserWhitelist is DSAuth {\n    enum Applied { pre, post }\n\n    event ListAddition(address indexed who);\n    event ListRemoval(address indexed who);\n\n    mapping (address => bool) public whitelisted;\n\n    constructor(address[] memory _preApproved) public {\n        batchAddToWhitelist(_preApproved);\n    }\n\n    function addToWhitelist(address _who) public auth {\n        whitelisted[_who] = true;\n        emit ListAddition(_who);\n    }\n\n    function removeFromWhitelist(address _who) public auth {\n        whitelisted[_who] = false;\n        emit ListRemoval(_who);\n    }\n\n    function batchAddToWhitelist(address[] memory _members) public auth {\n        for (uint i = 0; i < _members.length; i++) {\n            addToWhitelist(_members[i]);\n        }\n    }\n\n    function batchRemoveFromWhitelist(address[] memory _members) public auth {\n        for (uint i = 0; i < _members.length; i++) {\n            removeFromWhitelist(_members[i]);\n        }\n    }\n\n    function rule(bytes4 sig, address[5] calldata addresses, uint[3] calldata values, bytes32 identifier) external returns (bool) {\n        return whitelisted[addresses[0]];\n    }\n\n    function position() external pure returns (Applied) { return Applied.pre; }\n    function identifier() external pure returns (string memory) { return 'UserWhitelist'; }\n}\n"
    },
    "./src/fund/policies/IPolicy.sol": {
      "content": "pragma solidity 0.6.1;\n\ninterface IPolicy {\n    enum Applied { pre, post }\n\n    // In Trading context:\n    // addresses: Order maker, Order taker, Order maker asset, Order taker asset, Exchange address\n    // values: Maker token quantity, Taker token quantity, Fill Taker Quantity\n\n    // In Participation context:\n    // address[0]: Investor address, address[3]: Investment asset\n    function rule(bytes4 sig, address[5] calldata addresses, uint[3] calldata values, bytes32 identifier) external returns (bool);\n\n    function position() external view returns (Applied);\n    function identifier() external view returns (string memory);\n}\n"
    },
    "./src/fund/policies/IPolicyManager.sol": {
      "content": "pragma solidity 0.6.1;\n\n\ninterface IPolicyManagerFactory {\n    function createInstance(address _hub) external returns (address);\n}\n\n"
    },
    "./src/fund/policies/PolicyManager.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"../../factory/Factory.sol\";\nimport \"../hub/Spoke.sol\";\nimport \"./IPolicy.sol\";\n\ncontract PolicyManager is Spoke {\n\n    event Registration(\n        bytes4 indexed sig,\n        IPolicy.Applied position,\n        address indexed policy\n    );\n\n    struct Entry {\n        IPolicy[] pre;\n        IPolicy[] post;\n    }\n\n    mapping(bytes4 => Entry) policies;\n\n    constructor (address _hub) public Spoke(_hub) {}\n\n    function register(bytes4 sig, address _policy) public auth {\n        IPolicy.Applied position = IPolicy(_policy).position();\n        if (position == IPolicy.Applied.pre) {\n            policies[sig].pre.push(IPolicy(_policy));\n        } else if (position == IPolicy.Applied.post) {\n            policies[sig].post.push(IPolicy(_policy));\n        } else {\n            revert(\"Only pre and post allowed\");\n        }\n        emit Registration(sig, position, _policy);\n    }\n\n    function batchRegister(bytes4[] memory sig, address[] memory _policies) public auth {\n        require(sig.length == _policies.length, \"Arrays lengths unequal\");\n        for (uint i = 0; i < sig.length; i++) {\n            register(sig[i], _policies[i]);\n        }\n    }\n\n    function PoliciesToAddresses(IPolicy[] storage _policies) internal view returns (address[] memory) {\n        address[] memory res = new address[](_policies.length);\n        for(uint i = 0; i < _policies.length; i++) {\n            res[i] = address(_policies[i]);\n        }\n        return res;\n    }\n\n    function getPoliciesBySig(bytes4 sig) public view returns (address[] memory, address[] memory) {\n        return (PoliciesToAddresses(policies[sig].pre), PoliciesToAddresses(policies[sig].post));\n    }\n\n    modifier isValidPolicyBySig(bytes4 sig, address[5] memory addresses, uint[3] memory values, bytes32 identifier) {\n        preValidate(sig, addresses, values, identifier);\n        _;\n        postValidate(sig, addresses, values, identifier);\n    }\n\n    modifier isValidPolicy(address[5] memory addresses, uint[3] memory values, bytes32 identifier) {\n        preValidate(msg.sig, addresses, values, identifier);\n        _;\n        postValidate(msg.sig, addresses, values, identifier);\n    }\n\n    function preValidate(bytes4 sig, address[5] memory addresses, uint[3] memory values, bytes32 identifier) public {\n        validate(policies[sig].pre, sig, addresses, values, identifier);\n    }\n\n    function postValidate(bytes4 sig, address[5] memory addresses, uint[3] memory values, bytes32 identifier) public {\n        validate(policies[sig].post, sig, addresses, values, identifier);\n    }\n\n    function validate(IPolicy[] storage aux, bytes4 sig, address[5] memory addresses, uint[3] memory values, bytes32 identifier) internal {\n        for(uint i = 0; i < aux.length; i++) {\n            require(\n                aux[i].rule(sig, addresses, values, identifier),\n                string(abi.encodePacked(\"Rule evaluated to false: \", aux[i].identifier()))\n            );\n        }\n    }\n}\n\ncontract PolicyManagerFactory is Factory {\n    function createInstance(address _hub) external returns (address) {\n        address policyManager = address(new PolicyManager(_hub));\n        childExists[policyManager] = true;\n        emit NewInstance(_hub, policyManager);\n        return policyManager;\n    }\n}\n"
    },
    "./src/fund/policies/risk-management/AssetBlacklist.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"../AddressList.sol\";\nimport \"../TradingSignatures.sol\";\n\n/// @notice Assets can be added but not removed from blacklist\ncontract AssetBlacklist is TradingSignatures, AddressList {\n    enum Applied { pre, post }\n\n    // bytes4 constant public MAKE_ORDER = 0x79705be7; // makeOrderSignature\n    // bytes4 constant public TAKE_ORDER = 0xe51be6e8; // takeOrderSignature\n\n    constructor(address[] memory _assets) AddressList(_assets) public {}\n\n    function addToBlacklist(address _asset) external auth {\n        require(!isMember(_asset), \"Asset already in blacklist\");\n        list[_asset] = true;\n        mirror.push(_asset);\n    }\n\n    function rule(bytes4 sig, address[5] calldata addresses, uint[3] calldata values, bytes32 identifier) external returns (bool) {\n        address incomingToken = (sig == TAKE_ORDER) ? addresses[2] : addresses[3];\n        return !isMember(incomingToken);\n    }\n\n    function position() external pure returns (Applied) { return Applied.pre; }\n    function identifier() external pure returns (string memory) { return 'AssetBlacklist'; }\n}\n"
    },
    "./src/fund/policies/risk-management/AssetWhitelist.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"../AddressList.sol\";\nimport \"../TradingSignatures.sol\";\n\n/// @notice Assets can be removed from but not added to whitelist\ncontract AssetWhitelist is TradingSignatures, AddressList {\n    enum Applied { pre, post }\n\n    constructor(address[] memory _assets) public AddressList(_assets) {}\n\n    function removeFromWhitelist(address _asset) external auth {\n        require(isMember(_asset), \"Asset not in whitelist\");\n        delete list[_asset];\n        uint i = getAssetIndex(_asset);\n        for (i; i < mirror.length-1; i++){\n            mirror[i] = mirror[i+1];\n        }\n        mirror.pop();\n    }\n\n    function getAssetIndex(address _asset) public view returns (uint) {\n        for (uint i = 0; i < mirror.length; i++) {\n            if (mirror[i] == _asset) { return i; }\n        }\n    }\n\n    function rule(bytes4 sig, address[5] calldata addresses, uint[3] calldata values, bytes32 identifier) external returns (bool) {\n        address incomingToken = (sig == TAKE_ORDER) ? addresses[2] : addresses[3];\n        return isMember(incomingToken);\n    }\n\n    function position() external pure returns (Applied) { return Applied.pre; }\n    function identifier() external pure returns (string memory) { return 'AssetWhitelist'; }\n}\n"
    },
    "./src/fund/policies/risk-management/MaxConcentration.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"../../../dependencies/DSMath.sol\";\nimport \"../../../prices/IPriceSource.sol\";\nimport \"../../accounting/Accounting.sol\";\nimport \"../../trading/Trading.sol\";\nimport \"../TradingSignatures.sol\";\nimport \"../../../prices/IPriceSource.sol\";\n\ncontract MaxConcentration is TradingSignatures, DSMath {\n    enum Applied { pre, post }\n\n    uint internal constant ONE_HUNDRED_PERCENT = 10 ** 18;  // 100%\n    uint public maxConcentration;\n\n    constructor(uint _maxConcentration) public {\n        require(\n            _maxConcentration <= ONE_HUNDRED_PERCENT,\n            \"Max concentration cannot exceed 100%\"\n        );\n        maxConcentration = _maxConcentration;\n    }\n\n    function rule(bytes4 sig, address[5] calldata addresses, uint[3] calldata values, bytes32 identifier)\n        external\n        returns (bool)\n    {\n        Accounting accounting = Accounting(Hub(Trading(msg.sender).hub()).accounting());\n        address denominationAsset = accounting.DENOMINATION_ASSET();\n        // Max concentration is only checked for non-quote assets\n        address takerToken = (sig == TAKE_ORDER) ? addresses[2] : addresses[3];\n        if (denominationAsset == takerToken) { return true; }\n\n        uint concentration;\n        uint totalGav = accounting.calcGav();\n        if (sig == MAKE_ORDER) {\n            IPriceSource priceSource = IPriceSource(Hub(Trading(msg.sender).hub()).priceSource());\n            address makerToken = addresses[2];\n            uint makerQuantiyBeingTraded = values[0];\n            uint takerQuantityBeingTraded = values[1];\n\n            uint takerTokenGavBeingTraded = priceSource.convertQuantity(\n                takerQuantityBeingTraded, takerToken, denominationAsset\n            );\n\n            uint makerTokenGavBeingTraded;\n            if (makerToken == denominationAsset) {\n                makerTokenGavBeingTraded = makerQuantiyBeingTraded;\n            }\n            else {\n                makerTokenGavBeingTraded = priceSource.convertQuantity(\n                    makerQuantiyBeingTraded, makerToken, denominationAsset\n                );\n            }\n            concentration = _calcConcentration(\n                add(accounting.calcAssetGAV(takerToken), takerTokenGavBeingTraded),\n                add(takerTokenGavBeingTraded, sub(totalGav, makerTokenGavBeingTraded))\n            );\n        }\n        else {\n            concentration = _calcConcentration(\n                accounting.calcAssetGAV(takerToken),\n                totalGav\n            );\n        }\n        return concentration <= maxConcentration;\n    }\n\n    function position() external pure returns (Applied) { return Applied.post; }\n    function identifier() external pure returns (string memory) { return 'MaxConcentration'; }\n\n    function _calcConcentration(uint assetGav, uint totalGav) internal returns (uint) {\n        return mul(assetGav, ONE_HUNDRED_PERCENT) / totalGav;\n    }\n}\n"
    },
    "./src/fund/policies/risk-management/MaxPositions.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"../../../prices/IPriceSource.sol\";\nimport \"../../accounting/Accounting.sol\";\nimport \"../../trading/Trading.sol\";\nimport \"../TradingSignatures.sol\";\n\ncontract MaxPositions is TradingSignatures {\n    enum Applied { pre, post }\n\n    uint public maxPositions;\n\n    /// @dev _maxPositions = 10 means max 10 different asset tokens\n    /// @dev _maxPositions = 0 means no asset tokens are investable\n    constructor(uint _maxPositions) public { maxPositions = _maxPositions; }\n\n    function rule(bytes4 sig, address[5] calldata addresses, uint[3] calldata values, bytes32 identifier)\n        external\n        returns (bool)\n    {\n        Accounting accounting = Accounting(Hub(Trading(msg.sender).hub()).accounting());\n        address denominationAsset = accounting.DENOMINATION_ASSET();\n        // Always allow a trade INTO the quote asset\n        address incomingToken = (sig == TAKE_ORDER) ? addresses[2] : addresses[3];\n        if (denominationAsset == incomingToken) { return true; }\n        return accounting.getOwnedAssetsLength() <= maxPositions;\n    }\n\n    function position() external pure returns (Applied) { return Applied.post; }\n    function identifier() external pure returns (string memory) { return 'MaxPositions'; }\n}\n"
    },
    "./src/fund/policies/risk-management/PriceTolerance.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"../../hub/Hub.sol\";\nimport \"../../../prices/IPriceSource.sol\";\nimport \"../TradingSignatures.sol\";\nimport \"../../../dependencies/DSMath.sol\";\nimport \"../../trading/Trading.sol\";\nimport \"../../../exchanges/interfaces/IOasisDex.sol\";\n\ncontract PriceTolerance is TradingSignatures, DSMath {\n    enum Applied { pre, post }\n\n    uint public tolerance;\n\n    uint constant MULTIPLIER = 10 ** 16; // to give effect of a percentage\n    uint constant DIVISOR = 10 ** 18;\n\n    // _tolerance: 10 equals to 10% of tolerance\n    constructor(uint _tolerancePercent) public {\n        require(_tolerancePercent <= 100, \"Tolerance range is 0% - 100%\");\n        tolerance = mul(_tolerancePercent, MULTIPLIER);\n    }\n\n    /// @notice Taken from OpenZeppelin (https://git.io/fhQqo)\n   function signedSafeSub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\n\n        return c;\n    }\n\n    function takeOasisDex(\n        address ofExchange,\n        bytes32 identifier,\n        uint fillTakerQuantity\n    ) public view returns (bool) {\n        uint maxMakerQuantity;\n        address makerAsset;\n        uint maxTakerQuantity;\n        address takerAsset;\n        (\n            maxMakerQuantity,\n            makerAsset,\n            maxTakerQuantity,\n            takerAsset\n        ) = IOasisDex(ofExchange).getOffer(uint(identifier));\n\n        uint fillMakerQuantity = mul(fillTakerQuantity, maxMakerQuantity) / maxTakerQuantity;\n\n        IPriceSource pricefeed = IPriceSource(Hub(Trading(msg.sender).hub()).priceSource());\n        uint referencePrice;\n        (referencePrice,) = pricefeed.getReferencePriceInfo(takerAsset, makerAsset);\n\n        uint orderPrice = pricefeed.getOrderPriceInfo(\n            takerAsset,\n            makerAsset,\n            fillTakerQuantity,\n            fillMakerQuantity\n        );\n\n        return orderPrice >= sub(\n            referencePrice,\n            mul(tolerance, referencePrice) / DIVISOR\n        );\n    }\n\n    function takeGenericOrder(\n        address makerAsset,\n        address takerAsset,\n        uint[3] memory values\n    ) public view returns (bool) {\n        uint fillTakerQuantity = values[2];\n        uint fillMakerQuantity = mul(fillTakerQuantity, values[0]) / values[1];\n\n        IPriceSource pricefeed = IPriceSource(Hub(Trading(msg.sender).hub()).priceSource());\n        uint referencePrice;\n        (referencePrice, ) = pricefeed.getReferencePriceInfo(takerAsset, makerAsset);\n\n        uint orderPrice = pricefeed.getOrderPriceInfo(\n            takerAsset,\n            makerAsset,\n            fillTakerQuantity,\n            fillMakerQuantity\n        );\n\n        return orderPrice >= sub(\n            referencePrice,\n            mul(tolerance, referencePrice) / DIVISOR\n        );\n    }\n\n    function takeOrder(\n        address[5] memory addresses,\n        uint[3] memory values,\n        bytes32 identifier\n    ) public view returns (bool) {\n        if (identifier == 0x0) {\n            return takeGenericOrder(addresses[2], addresses[3], values);\n        } else {\n            return takeOasisDex(addresses[4], identifier, values[2]);\n        }\n    }\n\n    function makeOrder(\n        address[5] memory addresses,\n        uint[3] memory values,\n        bytes32 identifier\n    ) public view returns (bool) {\n        IPriceSource pricefeed = IPriceSource(Hub(Trading(msg.sender).hub()).priceSource());\n\n        uint ratio;\n        (ratio,) = IPriceSource(pricefeed).getReferencePriceInfo(addresses[2], addresses[3]);\n        uint _value = IPriceSource(pricefeed).getOrderPriceInfo(addresses[2], addresses[3], values[0], values[1]);\n\n        int res = signedSafeSub(int(ratio), int(_value));\n        if (res < 0) {\n            return true;\n        } else {\n            return wdiv(uint(res), ratio) <= tolerance;\n        }\n    }\n\n    function rule(\n        bytes4 sig,\n        address[5] calldata addresses,\n        uint[3] calldata values,\n        bytes32 identifier\n    ) external returns (bool) {\n        if (sig == MAKE_ORDER) {\n            return makeOrder(addresses, values, identifier);\n        } else if (sig == TAKE_ORDER) {\n            return takeOrder(addresses, values, identifier);\n        }\n        revert(\"Signature was neither MakeOrder nor TakeOrder\");\n    }\n\n    function position() external pure returns (Applied) { return Applied.pre; }\n    function identifier() external pure returns (string memory) { return 'PriceTolerance'; }\n}\n"
    },
    "./src/fund/policies/TradingSignatures.sol": {
      "content": "pragma solidity 0.6.1;\n\ncontract TradingSignatures {\n    bytes4 constant public MAKE_ORDER = 0x5f08e909; // makeOrderSignature\n    bytes4 constant public TAKE_ORDER = 0x63b24ef1; // takeOrderSignature\n}\n"
    },
    "./src/fund/shares/IShares.sol": {
      "content": "pragma solidity 0.6.1;\n\n/// @notice Token representing ownership of the Fund\ninterface IShares {\n    function createFor(address who, uint amount) external;\n    function destroyFor(address who, uint amount) external;\n}\n\ninterface ISharesFactory {\n    function createInstance(address _hub) external returns (address);\n}\n\n"
    },
    "./src/fund/shares/Shares.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"../hub/Spoke.sol\";\nimport \"../../dependencies/token/StandardToken.sol\";\nimport \"../../factory/Factory.sol\";\n\ncontract Shares is Spoke, StandardToken {\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n\n    constructor(address _hub) public Spoke(_hub) {\n        name = hub.name();\n        symbol = \"MLNF\";\n        decimals = 18;\n    }\n\n    function createFor(address who, uint amount) public auth {\n        _mint(who, amount);\n    }\n\n    function destroyFor(address who, uint amount) public auth {\n        _burn(who, amount);\n    }\n\n    function transfer(address to, uint amount) public override returns (bool) {\n        revert(\"Unimplemented\");\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint amount\n    )\n        public\n        override\n        returns (bool)\n    {\n        revert(\"Unimplemented\");\n    }\n\n    function approve(address spender, uint amount) public override returns (bool) {\n        revert(\"Unimplemented\");\n    }\n\n    function increaseApproval(\n        address spender,\n        uint amount\n    )\n        public\n        override\n        returns (bool)\n    {\n        revert(\"Unimplemented\");\n    }\n\n    function decreaseApproval(\n        address spender,\n        uint amount\n    )\n        public\n        override\n        returns (bool)\n    {\n        revert(\"Unimplemented\");\n    }\n}\n\ncontract SharesFactory is Factory {\n    function createInstance(address _hub) external returns (address) {\n        address shares = address(new Shares(_hub));\n        childExists[shares] = true;\n        emit NewInstance(_hub, shares);\n        return shares;\n    }\n}\n\n"
    },
    "./src/fund/trading/ITrading.sol": {
      "content": "pragma solidity 0.6.1;\n\npragma experimental ABIEncoderV2;\n\n// TODO: Restore indexed params\n\n/// @notice Mediation between a Fund and exchanges\ninterface ITrading {\n    function callOnExchange(\n        uint exchangeIndex,\n        string calldata methodSignature,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) external;\n\n    function addOpenMakeOrder(\n        address ofExchange,\n        address ofSellAsset,\n        address ofBuyAsset,\n        uint orderId,\n        uint expiryTime\n    ) external;\n\n    function removeOpenMakeOrder(\n        address ofExchange,\n        address ofSellAsset\n    ) external;\n\n    function updateAndGetQuantityBeingTraded(address _asset) external returns (uint256);\n    function getOpenMakeOrdersAgainstAsset(address _asset) external view returns (uint256);\n}\n\ninterface ITradingFactory {\n     function createInstance(\n        address _hub,\n        address[] calldata _exchanges,\n        address[] calldata _adapters,\n        address _registry\n    ) external returns (address);\n}\n"
    },
    "./src/fund/trading/Trading.sol": {
      "content": "pragma solidity 0.6.1;\npragma experimental ABIEncoderV2;\n\nimport \"../hub/Spoke.sol\";\nimport \"../vault/Vault.sol\";\nimport \"../policies/PolicyManager.sol\";\nimport \"../policies/TradingSignatures.sol\";\nimport \"../../factory/Factory.sol\";\nimport \"../../dependencies/DSMath.sol\";\nimport \"../../exchanges/ExchangeAdapter.sol\";\nimport \"../../exchanges/interfaces/IZeroExV2.sol\";\nimport \"../../exchanges/interfaces/IZeroExV3.sol\";\nimport \"../../version/Registry.sol\";\nimport \"../../dependencies/TokenUser.sol\";\n\ncontract Trading is DSMath, TokenUser, Spoke, TradingSignatures {\n    event ExchangeMethodCall(\n        address indexed exchangeAddress,\n        string indexed methodSignature,\n        address[8] orderAddresses,\n        uint[8] orderValues,\n        bytes[4] orderData,\n        bytes32 identifier,\n        bytes signature\n    );\n\n    struct Exchange {\n        address exchange;\n        address adapter;\n        bool takesCustody;\n    }\n\n    enum UpdateType { make, take, cancel }\n\n    struct Order {\n        address exchangeAddress;\n        bytes32 orderId;\n        UpdateType updateType;\n        address makerAsset;\n        address takerAsset;\n        uint makerQuantity;\n        uint takerQuantity;\n        uint timestamp;\n        uint fillTakerQuantity;\n    }\n\n    struct OpenMakeOrder {\n        uint id; // Order Id from exchange\n        uint expiresAt; // Timestamp when the order expires\n        uint orderIndex; // Index of the order in the orders array\n        address buyAsset; // Address of the buy asset in the order\n    }\n\n    Exchange[] public exchanges;\n    Order[] public orders;\n    mapping (address => bool) public adapterIsAdded;\n    mapping (address => mapping(address => OpenMakeOrder)) public exchangesToOpenMakeOrders;\n    mapping (address => uint) public openMakeOrdersAgainstAsset;\n    mapping (address => bool) public isInOpenMakeOrder;\n    mapping (address => uint) public makerAssetCooldown;\n    mapping (bytes32 => IZeroExV2.Order) internal orderIdToZeroExV2Order;\n    mapping (bytes32 => IZeroExV3.Order) internal orderIdToZeroExV3Order;\n\n    uint public constant ORDER_LIFESPAN = 1 days;\n    uint public constant MAKE_ORDER_COOLDOWN = 30 minutes;\n\n    modifier delegateInternal() {\n        require(msg.sender == address(this), \"Sender is not this contract\");\n        _;\n    }\n\n    constructor(\n        address _hub,\n        address[] memory _exchanges,\n        address[] memory _adapters,\n        address _registry\n    )\n        public\n        Spoke(_hub)\n    {\n        routes.registry = _registry;\n        require(_exchanges.length == _adapters.length, \"Array lengths unequal\");\n        for (uint i = 0; i < _exchanges.length; i++) {\n            _addExchange(_exchanges[i], _adapters[i]);\n        }\n    }\n\n    /// @notice Receive ether function (used to receive ETH from WETH)\n    receive() external payable {}\n\n    function addExchange(address _exchange, address _adapter) external auth {\n        _addExchange(_exchange, _adapter);\n    }\n\n    function _addExchange(\n        address _exchange,\n        address _adapter\n    ) internal {\n        require(!adapterIsAdded[_adapter], \"Adapter already added\");\n        adapterIsAdded[_adapter] = true;\n        Registry registry = Registry(routes.registry);\n        require(\n            registry.exchangeAdapterIsRegistered(_adapter),\n            \"Adapter is not registered\"\n        );\n\n        address registeredExchange;\n        bool takesCustody;\n        (registeredExchange, takesCustody) = registry.getExchangeInformation(_adapter);\n\n        require(\n            registeredExchange == _exchange,\n            \"Exchange and adapter do not match\"\n        );\n        exchanges.push(Exchange(_exchange, _adapter, takesCustody));\n    }\n\n    /// @notice Universal method for calling exchange functions through adapters\n    /// @notice See adapter contracts for parameters needed for each exchange\n    /// @param exchangeIndex Index of the exchange in the \"exchanges\" array\n    /// @param orderAddresses [0] Order maker\n    /// @param orderAddresses [1] Order taker\n    /// @param orderAddresses [2] Order maker asset\n    /// @param orderAddresses [3] Order taker asset\n    /// @param orderAddresses [4] feeRecipientAddress\n    /// @param orderAddresses [5] senderAddress\n    /// @param orderAddresses [6] maker fee asset\n    /// @param orderAddresses [7] taker fee asset\n    /// @param orderValues [0] makerAssetAmount\n    /// @param orderValues [1] takerAssetAmount\n    /// @param orderValues [2] Maker fee\n    /// @param orderValues [3] Taker fee\n    /// @param orderValues [4] expirationTimeSeconds\n    /// @param orderValues [5] Salt/nonce\n    /// @param orderValues [6] Fill amount: amount of taker token to be traded\n    /// @param orderValues [7] Dexy signature mode\n    /// @param orderData [0] Encoded data specific to maker asset\n    /// @param orderData [1] Encoded data specific to taker asset\n    /// @param orderData [2] Encoded data specific to maker asset fee\n    /// @param orderData [3] Encoded data specific to taker asset fee\n    /// @param identifier Order identifier\n    /// @param signature Signature of order maker\n    function callOnExchange(\n        uint exchangeIndex,\n        string memory methodSignature,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    )\n        public\n        onlyInitialized\n    {\n        bytes4 methodSelector = bytes4(keccak256(bytes(methodSignature)));\n        require(\n            Registry(routes.registry).adapterMethodIsAllowed(\n                exchanges[exchangeIndex].adapter,\n                methodSelector\n            ),\n            \"Adapter method not allowed\"\n        );\n        PolicyManager(routes.policyManager).preValidate(methodSelector, [orderAddresses[0], orderAddresses[1], orderAddresses[2], orderAddresses[3], exchanges[exchangeIndex].exchange], [orderValues[0], orderValues[1], orderValues[6]], identifier);\n        if (\n            methodSelector == MAKE_ORDER ||\n            methodSelector == TAKE_ORDER\n        ) {\n            require(Registry(routes.registry).assetIsRegistered(\n                orderAddresses[2]), 'Maker asset not registered'\n            );\n            require(Registry(routes.registry).assetIsRegistered(\n                orderAddresses[3]), 'Taker asset not registered'\n            );\n            if (orderAddresses[6] != address(0) && methodSelector == MAKE_ORDER) {\n                require(\n                    Registry(routes.registry).assetIsRegistered(orderAddresses[6]),\n                    'Maker fee asset not registered'\n                );\n            }\n            if (orderAddresses[7] != address(0) && methodSelector == TAKE_ORDER) {\n                require(\n                    Registry(routes.registry).assetIsRegistered(orderAddresses[7]),\n                    'Taker fee asset not registered'\n                );\n            }\n        }\n        (bool success, bytes memory returnData) = exchanges[exchangeIndex].adapter.delegatecall(\n            abi.encodeWithSignature(\n                methodSignature,\n                exchanges[exchangeIndex].exchange,\n                orderAddresses,\n                orderValues,\n                orderData,\n                identifier,\n                signature\n            )\n        );\n        require(success, string(returnData));\n        PolicyManager(routes.policyManager).postValidate(methodSelector, [orderAddresses[0], orderAddresses[1], orderAddresses[2], orderAddresses[3], exchanges[exchangeIndex].exchange], [orderValues[0], orderValues[1], orderValues[6]], identifier);\n        emit ExchangeMethodCall(\n            exchanges[exchangeIndex].exchange,\n            methodSignature,\n            orderAddresses,\n            orderValues,\n            orderData,\n            identifier,\n            signature\n        );\n    }\n\n    /// @dev Make sure this is called after orderUpdateHook in adapters\n    function addOpenMakeOrder(\n        address ofExchange,\n        address sellAsset,\n        address buyAsset,\n        uint orderId,\n        uint expirationTime\n    ) public delegateInternal {\n        require(!isInOpenMakeOrder[sellAsset], \"Asset already in open order\");\n        require(orders.length > 0, \"No orders in array\");\n\n        // If expirationTime is 0, actualExpirationTime is set to ORDER_LIFESPAN from now\n        uint actualExpirationTime = (expirationTime == 0) ? add(block.timestamp, ORDER_LIFESPAN) : expirationTime;\n\n        require(\n            actualExpirationTime <= add(block.timestamp, ORDER_LIFESPAN) &&\n            actualExpirationTime > block.timestamp,\n            \"Expiry time greater than max order lifespan or has already passed\"\n        );\n        isInOpenMakeOrder[sellAsset] = true;\n        makerAssetCooldown[sellAsset] = add(actualExpirationTime, MAKE_ORDER_COOLDOWN);\n        openMakeOrdersAgainstAsset[buyAsset] = add(openMakeOrdersAgainstAsset[buyAsset], 1);\n        exchangesToOpenMakeOrders[ofExchange][sellAsset].id = orderId;\n        exchangesToOpenMakeOrders[ofExchange][sellAsset].expiresAt = actualExpirationTime;\n        exchangesToOpenMakeOrders[ofExchange][sellAsset].orderIndex = sub(orders.length, 1);\n        exchangesToOpenMakeOrders[ofExchange][sellAsset].buyAsset = buyAsset;\n\n    }\n\n    function _removeOpenMakeOrder(\n        address exchange,\n        address sellAsset\n    ) internal {\n        if (isInOpenMakeOrder[sellAsset]) {\n\n            makerAssetCooldown[sellAsset] = add(block.timestamp, MAKE_ORDER_COOLDOWN);\n            address buyAsset = exchangesToOpenMakeOrders[exchange][sellAsset].buyAsset;\n            delete exchangesToOpenMakeOrders[exchange][sellAsset];\n            openMakeOrdersAgainstAsset[buyAsset] = sub(openMakeOrdersAgainstAsset[buyAsset], 1);\n        }\n    }\n\n    function removeOpenMakeOrder(\n        address exchange,\n        address sellAsset\n    ) public delegateInternal {\n        _removeOpenMakeOrder(exchange, sellAsset);\n    }\n\n    /// @dev Bit of Redundancy for now\n    function addZeroExV2OrderData(\n        bytes32 orderId,\n        IZeroExV2.Order memory zeroExOrderData\n    ) public delegateInternal {\n        orderIdToZeroExV2Order[orderId] = zeroExOrderData;\n    }\n    function addZeroExV3OrderData(\n        bytes32 orderId,\n        IZeroExV3.Order memory zeroExOrderData\n    ) public delegateInternal {\n        orderIdToZeroExV3Order[orderId] = zeroExOrderData;\n    }\n\n    function orderUpdateHook(\n        address ofExchange,\n        bytes32 orderId,\n        UpdateType updateType,\n        address payable[2] memory orderAddresses,\n        uint[3] memory orderValues\n    ) public delegateInternal {\n        // only save make/take\n        if (updateType == UpdateType.make || updateType == UpdateType.take) {\n            orders.push(Order({\n                exchangeAddress: ofExchange,\n                orderId: orderId,\n                updateType: updateType,\n                makerAsset: orderAddresses[0],\n                takerAsset: orderAddresses[1],\n                makerQuantity: orderValues[0],\n                takerQuantity: orderValues[1],\n                timestamp: block.timestamp,\n                fillTakerQuantity: orderValues[2]\n            }));\n        }\n    }\n\n    function updateAndGetQuantityBeingTraded(address _asset) external returns (uint) {\n        uint quantityHere = IERC20(_asset).balanceOf(address(this));\n        return add(updateAndGetQuantityHeldInExchange(_asset), quantityHere);\n    }\n\n    function updateAndGetQuantityHeldInExchange(address ofAsset) public returns (uint) {\n        uint totalSellQuantity; // quantity in custody across exchanges\n        uint totalSellQuantityInApprove; // quantity of asset in approve (allowance) but not custody of exchange\n        for (uint i; i < exchanges.length; i++) {\n            if (exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset].id == 0) {\n                continue;\n            }\n            address sellAsset;\n            uint remainingSellQuantity;\n            (sellAsset, , remainingSellQuantity, ) =\n                ExchangeAdapter(exchanges[i].adapter)\n                .getOrder(\n                    exchanges[i].exchange,\n                    exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset].id,\n                    ofAsset\n                );\n            if (remainingSellQuantity == 0) {    // remove id if remaining sell quantity zero (closed)\n                _removeOpenMakeOrder(exchanges[i].exchange, ofAsset);\n            }\n            totalSellQuantity = add(totalSellQuantity, remainingSellQuantity);\n            if (!exchanges[i].takesCustody) {\n                totalSellQuantityInApprove += remainingSellQuantity;\n            }\n        }\n        if (totalSellQuantity == 0) {\n            isInOpenMakeOrder[ofAsset] = false;\n        }\n        return sub(totalSellQuantity, totalSellQuantityInApprove); // Since quantity in approve is not actually in custody\n    }\n\n    function returnBatchToVault(address[] memory _tokens) public {\n        for (uint i = 0; i < _tokens.length; i++) {\n            returnAssetToVault(_tokens[i]);\n        }\n    }\n\n    function returnAssetToVault(address _token) public {\n        require(\n            msg.sender == address(this) || msg.sender == hub.manager() || hub.isShutDown(),\n            \"Sender is not this contract or manager\"\n        );\n        safeTransfer(_token, routes.vault, IERC20(_token).balanceOf(address(this)));\n    }\n\n    function getExchangeInfo() public view returns (address[] memory, address[] memory, bool[] memory) {\n        address[] memory ofExchanges = new address[](exchanges.length);\n        address[] memory ofAdapters = new address[](exchanges.length);\n        bool[] memory takesCustody = new bool[](exchanges.length);\n        for (uint i = 0; i < exchanges.length; i++) {\n            ofExchanges[i] = exchanges[i].exchange;\n            ofAdapters[i] = exchanges[i].adapter;\n            takesCustody[i] = exchanges[i].takesCustody;\n        }\n        return (ofExchanges, ofAdapters, takesCustody);\n    }\n\n    function getOpenOrderInfo(address ofExchange, address ofAsset) public view returns (uint, uint, uint) {\n        OpenMakeOrder memory order = exchangesToOpenMakeOrders[ofExchange][ofAsset];\n        return (order.id, order.expiresAt, order.orderIndex);\n    }\n\n    function isOrderExpired(address exchange, address asset) public view returns(bool) {\n        return (\n            exchangesToOpenMakeOrders[exchange][asset].expiresAt <= block.timestamp &&\n            exchangesToOpenMakeOrders[exchange][asset].expiresAt > 0\n        );\n    }\n\n    function getOrderDetails(uint orderIndex) public view returns (address, address, uint, uint) {\n        Order memory order = orders[orderIndex];\n        return (order.makerAsset, order.takerAsset, order.makerQuantity, order.takerQuantity);\n    }\n\n    function getZeroExV2OrderDetails(bytes32 orderId) public view returns (IZeroExV2.Order memory) {\n        return orderIdToZeroExV2Order[orderId];\n    }\n\n    function getZeroExV3OrderDetails(bytes32 orderId) public view returns (IZeroExV3.Order memory) {\n        return orderIdToZeroExV3Order[orderId];\n    }\n\n    function getOpenMakeOrdersAgainstAsset(address _asset) external view returns (uint256) {\n        return openMakeOrdersAgainstAsset[_asset];\n    }\n}\n\ncontract TradingFactory is Factory {\n    event NewInstance(\n        address indexed hub,\n        address indexed instance,\n        address[] exchanges,\n        address[] adapters,\n        address registry\n    );\n\n    function createInstance(\n        address _hub,\n        address[] memory _exchanges,\n        address[] memory _adapters,\n        address _registry\n    ) public returns (address) {\n        address trading = address(new Trading(_hub, _exchanges, _adapters, _registry));\n        childExists[trading] = true;\n        emit NewInstance(\n            _hub,\n            trading,\n            _exchanges,\n            _adapters,\n            _registry\n        );\n        return trading;\n    }\n}\n"
    },
    "./src/fund/vault/IVault.sol": {
      "content": "pragma solidity 0.6.1;\n\n/// @notice Custody component\ninterface IVault {\n    function withdraw(address token, uint amount) external;\n}\n\ninterface IVaultFactory {\n    function createInstance(address _hub) external returns (address);\n}\n"
    },
    "./src/fund/vault/Vault.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"../hub/Spoke.sol\";\nimport \"../../factory/Factory.sol\";\nimport \"../../dependencies/TokenUser.sol\";\n\n/// @notice Dumb custody component\ncontract Vault is TokenUser, Spoke {\n\n    constructor(address _hub) public Spoke(_hub) {}\n\n    function withdraw(address token, uint amount) external auth {\n        safeTransfer(token, msg.sender, amount);\n    }\n}\n\ncontract VaultFactory is Factory {\n    function createInstance(address _hub) external returns (address) {\n        address vault = address(new Vault(_hub));\n        childExists[vault] = true;\n        emit NewInstance(_hub, vault);\n        return vault;\n    }\n}\n\n"
    },
    "./src/prices/IPriceSource.sol": {
      "content": "pragma solidity 0.6.1;\n\n/// @notice Must return a value for an asset\ninterface IPriceSource {\n    function getQuoteAsset() external view returns (address);\n    function getLastUpdate() external view returns (uint);\n\n    /// @notice Returns false if asset not applicable, or price not recent\n    function hasValidPrice(address) external view returns (bool);\n    function hasValidPrices(address[] calldata) external view returns (bool);\n\n    /// @notice Return the last known price, and when it was issued\n    function getPrice(address _asset) external view returns (uint price, uint timestamp);\n    function getPrices(address[] calldata _assets) external view returns (uint[] memory prices, uint[] memory timestamps);\n\n    /// @notice Get price info, and revert if not valid\n    function getPriceInfo(address _asset) external view returns (uint price, uint decimals);\n    function getInvertedPriceInfo(address ofAsset) external view returns (uint price, uint decimals);\n\n    function getReferencePriceInfo(address _base, address _quote) external view returns (uint referencePrice, uint decimal);\n    function getOrderPriceInfo(address sellAsset, address buyAsset, uint sellQuantity, uint buyQuantity) external view returns (uint orderPrice);\n    function existsPriceOnAssetPair(address sellAsset, address buyAsset) external view returns (bool isExistent);\n    function convertQuantity(\n        uint fromAssetQuantity,\n        address fromAsset,\n        address toAsset\n    ) external view returns (uint);\n}\n"
    },
    "./src/prices/KyberPriceFeed.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"../dependencies/token/IERC20.sol\";\nimport \"../dependencies/DSMath.sol\";\nimport \"../dependencies/DSAuth.sol\"; // TODO: remove? this may not be used at all\nimport \"../exchanges/interfaces/IKyberNetworkProxy.sol\";\nimport \"../version/Registry.sol\";\n\n/// @title Price Feed Template\n/// @author Melonport AG <team@melonport.com>\n/// @notice Routes external data to smart contracts\n/// @notice Where external data includes sharePrice of Melon funds\n/// @notice PriceFeed operator could be staked and sharePrice input validated on chain\ncontract KyberPriceFeed is DSMath, DSAuth {\n    event PriceUpdate(address[] token, uint[] price);\n\n    address public KYBER_NETWORK_PROXY;\n    address public QUOTE_ASSET;\n    address public UPDATER;\n    Registry public REGISTRY;\n    uint public MAX_SPREAD;\n    address public constant KYBER_ETH_TOKEN = address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n    uint public constant KYBER_PRECISION = 18;\n    uint public constant VALIDITY_INTERVAL = 2 days;\n    uint public lastUpdate;\n\n    // FIELDS\n\n    mapping (address => uint) public prices;\n\n    // METHODS\n\n    // CONSTRUCTOR\n\n    /// @dev Define and register a quote asset against which all prices are measured/based against\n    constructor(\n        address ofRegistry,\n        address ofKyberNetworkProxy,\n        uint ofMaxSpread,\n        address ofQuoteAsset,\n        address initialUpdater\n    )\n        public\n    {\n        KYBER_NETWORK_PROXY = ofKyberNetworkProxy;\n        MAX_SPREAD = ofMaxSpread;\n        QUOTE_ASSET = ofQuoteAsset;\n        REGISTRY = Registry(ofRegistry);\n        UPDATER = initialUpdater;\n    }\n\n    /// @dev Stores zero as a convention for invalid price\n    function update() external {\n        require(\n            msg.sender == REGISTRY.owner() || msg.sender == UPDATER,\n            \"Only registry owner or updater can call\"\n        );\n        address[] memory assets = REGISTRY.getRegisteredAssets();\n        uint[] memory newPrices = new uint[](assets.length);\n        for (uint i; i < assets.length; i++) {\n            bool isValid;\n            uint price;\n            if (assets[i] == QUOTE_ASSET) {\n                isValid = true;\n                price = 1 ether;\n            } else {\n                (isValid, price) = getKyberPrice(assets[i], QUOTE_ASSET);\n            }\n            newPrices[i] = isValid ? price : 0;\n            prices[assets[i]] = newPrices[i];\n        }\n        lastUpdate = block.timestamp;\n        emit PriceUpdate(assets, newPrices);\n    }\n\n    function setUpdater(address _updater) external {\n        require(msg.sender == REGISTRY.owner(), \"Only registry owner can set\");\n        UPDATER = _updater;\n    }\n\n    /// @notice _maxSpread becomes a percentage when divided by 10^18\n    /// @notice (e.g. 10^17 becomes 10%)\n    function setMaxSpread(uint _maxSpread) external {\n        require(msg.sender == REGISTRY.owner(), \"Only registry owner can set\");\n        MAX_SPREAD = _maxSpread;\n    }\n\n    // PUBLIC VIEW METHODS\n\n    // FEED INFORMATION\n\n    function getQuoteAsset() public view returns (address) { return QUOTE_ASSET; }\n\n    // PRICES\n\n    /**\n    @notice Gets price of an asset multiplied by ten to the power of assetDecimals\n    @dev Asset has been registered\n    @param _asset Asset for which price should be returned\n    @return price Price formatting: mul(exchangePrice, 10 ** decimal), to avoid floating numbers\n    @return timestamp When the asset's price was updated\n    }\n    */\n    function getPrice(address _asset)\n        public\n        view\n        returns (uint price, uint timestamp)\n    {\n        (price, ) =  getReferencePriceInfo(_asset, QUOTE_ASSET);\n        timestamp = now;\n    }\n\n    function getPrices(address[] memory _assets)\n        public\n        view\n        returns (uint256[] memory, uint256[] memory)\n    {\n        uint[] memory newPrices = new uint[](_assets.length);\n        uint[] memory timestamps = new uint[](_assets.length);\n        for (uint i; i < _assets.length; i++) {\n            (newPrices[i], timestamps[i]) = getPrice(_assets[i]);\n        }\n        return (newPrices, timestamps);\n    }\n\n    function hasValidPrice(address _asset)\n        public\n        view\n        returns (bool)\n    {\n        bool isRegistered = REGISTRY.assetIsRegistered(_asset);\n        bool isFresh = block.timestamp < add(lastUpdate, VALIDITY_INTERVAL);\n        return prices[_asset] != 0 && isRegistered && isFresh;\n    }\n\n    function hasValidPrices(address[] memory _assets)\n        public\n        view\n        returns (bool)\n    {\n        for (uint i; i < _assets.length; i++) {\n            if (!hasValidPrice(_assets[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n    @param _baseAsset Address of base asset\n    @param _quoteAsset Address of quote asset\n    @return referencePrice Quantity of quoteAsset per whole baseAsset\n    @return decimals Decimal places for quoteAsset\n    }\n    */\n    function getReferencePriceInfo(address _baseAsset, address _quoteAsset)\n        public\n        view\n        returns (uint referencePrice, uint decimals)\n    {\n        bool isValid;\n        (\n            isValid,\n            referencePrice,\n            decimals\n        ) = getRawReferencePriceInfo(_baseAsset, _quoteAsset);\n        require(isValid, \"Price is not valid\");\n        return (referencePrice, decimals);\n    }\n\n    function getRawReferencePriceInfo(address _baseAsset, address _quoteAsset)\n        public\n        view\n        returns (bool isValid, uint256 referencePrice, uint256 decimals)\n    {\n        isValid = hasValidPrice(_baseAsset) && hasValidPrice(_quoteAsset);\n        uint256 quoteDecimals = ERC20WithFields(_quoteAsset).decimals();\n\n        if (prices[_quoteAsset] == 0) {\n            return (false, 0, 0);  // return early and avoid revert\n        }\n\n        referencePrice = mul(\n            prices[_baseAsset],\n            10 ** uint(quoteDecimals)\n        ) / prices[_quoteAsset];\n\n        return (isValid, referencePrice, quoteDecimals);\n    }\n\n    function getPriceInfo(address _asset)\n        public\n        view\n        returns (uint256 price, uint256 assetDecimals)\n    {\n        return getReferencePriceInfo(_asset, QUOTE_ASSET);\n    }\n\n    /**\n    @notice Gets inverted price of an asset\n    @dev Asset has been initialised and its price is non-zero\n    @param _asset Asset for which inverted price should be return\n    @return invertedPrice Price based (instead of quoted) against QUOTE_ASSET\n    @return assetDecimals Decimal places for this asset\n    }\n    */\n    function getInvertedPriceInfo(address _asset)\n        public\n        view\n        returns (uint256 invertedPrice, uint256 assetDecimals)\n    {\n        return getReferencePriceInfo(QUOTE_ASSET, _asset);\n    }\n\n    /// @dev Get Kyber representation of ETH if necessary\n    function getKyberMaskAsset(address _asset) public view returns (address) {\n        if (_asset == REGISTRY.nativeAsset()) {\n            return KYBER_ETH_TOKEN;\n        }\n        return _asset;\n    }\n\n    /// @notice Returns validity and price from Kyber\n    function getKyberPrice(address _baseAsset, address _quoteAsset)\n        public\n        view\n        returns (bool, uint)\n    {\n        uint bidRate;\n        uint bidRateOfReversePair;\n        (bidRate,) = IKyberNetworkProxy(KYBER_NETWORK_PROXY).getExpectedRate(\n            getKyberMaskAsset(_baseAsset),\n            getKyberMaskAsset(_quoteAsset),\n            REGISTRY.getReserveMin(_baseAsset)\n        );\n        (bidRateOfReversePair,) = IKyberNetworkProxy(KYBER_NETWORK_PROXY).getExpectedRate(\n            getKyberMaskAsset(_quoteAsset),\n            getKyberMaskAsset(_baseAsset),\n            REGISTRY.getReserveMin(_quoteAsset)\n        );\n\n        if (bidRate == 0 || bidRateOfReversePair == 0) {\n            return (false, 0);  // return early and avoid revert\n        }\n\n        uint askRate = 10 ** (KYBER_PRECISION * 2) / bidRateOfReversePair;\n        /**\n          Average the bid/ask prices:\n          avgPriceFromKyber = (bidRate + askRate) / 2\n          kyberPrice = (avgPriceFromKyber * 10^quoteDecimals) / 10^kyberPrecision\n          or, rearranged:\n          kyberPrice = ((bidRate + askRate) * 10^quoteDecimals) / 2 * 10^kyberPrecision\n        */\n        uint kyberPrice = mul(\n            add(bidRate, askRate),\n            10 ** uint(ERC20WithFields(_quoteAsset).decimals()) // use original quote decimals (not defined on mask)\n        ) / mul(2, 10 ** uint(KYBER_PRECISION));\n\n        // Find the \"quoted spread\", to inform caller whether it is below maximum\n        uint spreadFromKyber;\n        if (bidRate > askRate) {\n            spreadFromKyber = 0; // crossed market condition\n        } else {\n            spreadFromKyber = mul(\n                sub(askRate, bidRate),\n                10 ** uint(KYBER_PRECISION)\n            ) / kyberPrice;\n        }\n\n        return (\n            spreadFromKyber <= MAX_SPREAD && bidRate != 0 && askRate != 0,\n            kyberPrice\n        );\n    }\n\n    /// @notice Gets price of Order\n    /// @param sellAsset Address of the asset to be sold\n    /// @param buyAsset Address of the asset to be bought\n    /// @param sellQuantity Quantity in base units being sold of sellAsset\n    /// @param buyQuantity Quantity in base units being bought of buyAsset\n    /// @return orderPrice Price as determined by an order\n    function getOrderPriceInfo(\n        address sellAsset,\n        address buyAsset,\n        uint sellQuantity,\n        uint buyQuantity\n    )\n        public\n        view\n        returns (uint orderPrice)\n    {\n        // TODO: decimals\n        return mul(buyQuantity, 10 ** uint(ERC20WithFields(sellAsset).decimals())) / sellQuantity;\n    }\n\n    /// @notice Checks whether data exists for a given asset pair\n    /// @dev Prices are only upated against QUOTE_ASSET\n    /// @param sellAsset Asset for which check to be done if data exists\n    /// @param buyAsset Asset for which check to be done if data exists\n    function existsPriceOnAssetPair(address sellAsset, address buyAsset)\n        public\n        view\n        returns (bool)\n    {\n        return\n            hasValidPrice(sellAsset) && // Is tradable asset (TODO cleaner) and datafeed delivering data\n            hasValidPrice(buyAsset);\n    }\n\n    /// @notice Get quantity of toAsset equal in value to given quantity of fromAsset\n    function convertQuantity(\n        uint fromAssetQuantity,\n        address fromAsset,\n        address toAsset\n    )\n        public\n        view\n        returns (uint)\n    {\n        uint fromAssetPrice;\n        (fromAssetPrice,) = getReferencePriceInfo(fromAsset, toAsset);\n        uint fromAssetDecimals = ERC20WithFields(fromAsset).decimals();\n        return mul(\n            fromAssetQuantity,\n            fromAssetPrice\n        ) / (10 ** uint(fromAssetDecimals));\n    }\n\n    function getLastUpdate() public view returns (uint) { return lastUpdate; }\n}\n"
    },
    "./src/version/IVersion.sol": {
      "content": "pragma solidity 0.6.1;\n\ninterface IVersion {\n    function shutDownFund(address) external;\n}\n\n"
    },
    "./src/version/Registry.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"../dependencies/DSAuth.sol\";\nimport \"../fund/hub/Hub.sol\";\nimport \"../dependencies/token/IERC20.sol\";\n\ncontract Registry is DSAuth {\n\n    // EVENTS\n    event AssetUpsert (\n        address indexed asset,\n        string name,\n        string symbol,\n        uint decimals,\n        string url,\n        uint reserveMin,\n        uint[] standards,\n        bytes4[] sigs\n    );\n\n    event ExchangeAdapterUpsert (\n        address indexed exchange,\n        address indexed adapter,\n        bool takesCustody,\n        bytes4[] sigs\n    );\n\n    event AssetRemoval (address indexed asset);\n    event EfxWrapperRegistryChange(address indexed registry);\n    event EngineChange(address indexed engine);\n    event ExchangeAdapterRemoval (address indexed exchange);\n    event IncentiveChange(uint incentiveAmount);\n    event MGMChange(address indexed MGM);\n    event MlnTokenChange(address indexed mlnToken);\n    event NativeAssetChange(address indexed nativeAsset);\n    event PriceSourceChange(address indexed priceSource);\n    event VersionRegistration(address indexed version);\n\n    // TYPES\n    struct Asset {\n        bool exists;\n        string name;\n        string symbol;\n        uint decimals;\n        string url;\n        uint reserveMin;\n        uint[] standards;\n        bytes4[] sigs;\n    }\n\n    struct Exchange {\n        bool exists;\n        address exchangeAddress;\n        bool takesCustody;\n        bytes4[] sigs;\n    }\n\n    struct Version {\n        bool exists;\n        bytes32 name;\n    }\n\n    // CONSTANTS\n    uint public constant MAX_REGISTERED_ENTITIES = 20;\n    uint public constant MAX_FUND_NAME_BYTES = 66;\n\n    // FIELDS\n    mapping (address => Asset) public assetInformation;\n    address[] public registeredAssets;\n\n    // Mapping from adapter address to exchange Information (Adapters are unique)\n    mapping (address => Exchange) public exchangeInformation;\n    address[] public registeredExchangeAdapters;\n\n    mapping (address => Version) public versionInformation;\n    address[] public registeredVersions;\n\n    mapping (address => bool) public isFeeRegistered;\n\n    mapping (address => address) public fundsToVersions;\n    mapping (bytes32 => bool) public versionNameExists;\n    mapping (bytes32 => address) public fundNameHashToOwner;\n\n\n    uint public incentive = 10 finney;\n    address public priceSource;\n    address public mlnToken;\n    address public nativeAsset;\n    address public engine;\n    address public ethfinexWrapperRegistry;\n    address public MGM;\n\n    modifier onlyVersion() {\n        require(\n            versionInformation[msg.sender].exists,\n            \"Only a Version can do this\"\n        );\n        _;\n    }\n\n    // METHODS\n\n    constructor(address _postDeployOwner) public {\n        setOwner(_postDeployOwner);\n    }\n\n    // PUBLIC METHODS\n\n    /// @notice Whether _name has only valid characters\n    function isValidFundName(string memory _name) public pure returns (bool) {\n        bytes memory b = bytes(_name);\n        if (b.length > MAX_FUND_NAME_BYTES) return false;\n        for (uint i; i < b.length; i++){\n            bytes1 char = b[i];\n            if(\n                !(char >= 0x30 && char <= 0x39) && // 9-0\n                !(char >= 0x41 && char <= 0x5A) && // A-Z\n                !(char >= 0x61 && char <= 0x7A) && // a-z\n                !(char == 0x20 || char == 0x2D) && // space, dash\n                !(char == 0x2E || char == 0x5F) && // period, underscore\n                !(char == 0x2A) // *\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Whether _user can use _name for their fund\n    function canUseFundName(address _user, string memory _name) public view returns (bool) {\n        bytes32 nameHash = keccak256(bytes(_name));\n        return (\n            isValidFundName(_name) &&\n            (\n                fundNameHashToOwner[nameHash] == address(0) ||\n                fundNameHashToOwner[nameHash] == _user\n            )\n        );\n    }\n\n    function reserveFundName(address _owner, string calldata _name)\n        external\n        onlyVersion\n    {\n        require(canUseFundName(_owner, _name), \"Fund name cannot be used\");\n        fundNameHashToOwner[keccak256(bytes(_name))] = _owner;\n    }\n\n    function registerFund(address _fund, address _owner, string calldata _name)\n        external\n        onlyVersion\n    {\n        require(canUseFundName(_owner, _name), \"Fund name cannot be used\");\n        fundsToVersions[_fund] = msg.sender;\n    }\n\n    /// @notice Registers an Asset information entry\n    /// @dev Pre: Only registrar owner should be able to register\n    /// @dev Post: Address _asset is registered\n    /// @param _asset Address of asset to be registered\n    /// @param _name Human-readable name of the Asset\n    /// @param _symbol Human-readable symbol of the Asset\n    /// @param _url Url for extended information of the asset\n    /// @param _standards Integers of EIP standards this asset adheres to\n    /// @param _sigs Function signatures for whitelisted asset functions\n    function registerAsset(\n        address _asset,\n        string calldata _name,\n        string calldata _symbol,\n        string calldata _url,\n        uint _reserveMin,\n        uint[] calldata _standards,\n        bytes4[] calldata _sigs\n    ) external auth {\n        require(registeredAssets.length < MAX_REGISTERED_ENTITIES);\n        require(!assetInformation[_asset].exists);\n        assetInformation[_asset].exists = true;\n        registeredAssets.push(_asset);\n        updateAsset(\n            _asset,\n            _name,\n            _symbol,\n            _url,\n            _reserveMin,\n            _standards,\n            _sigs\n        );\n    }\n\n    /// @notice Register an exchange information entry (A mapping from exchange adapter -> Exchange information)\n    /// @dev Adapters are unique so are used as the mapping key. There may be different adapters for same exchange (0x / Ethfinex)\n    /// @dev Pre: Only registrar owner should be able to register\n    /// @dev Post: Address _exchange is registered\n    /// @param _exchange Address of the exchange for the adapter\n    /// @param _adapter Address of exchange adapter\n    /// @param _takesCustody Whether this exchange takes custody of tokens before trading\n    /// @param _sigs Function signatures for whitelisted exchange functions\n    function registerExchangeAdapter(\n        address _exchange,\n        address _adapter,\n        bool _takesCustody,\n        bytes4[] calldata _sigs\n    ) external auth {\n        require(!exchangeInformation[_adapter].exists, \"Adapter already exists\");\n        exchangeInformation[_adapter].exists = true;\n        require(registeredExchangeAdapters.length < MAX_REGISTERED_ENTITIES, \"Exchange limit reached\");\n        registeredExchangeAdapters.push(_adapter);\n        updateExchangeAdapter(\n            _exchange,\n            _adapter,\n            _takesCustody,\n            _sigs\n        );\n    }\n\n    /// @notice Versions cannot be removed from registry\n    /// @param _version Address of the version contract\n    /// @param _name Name of the version\n    function registerVersion(\n        address _version,\n        bytes32 _name\n    ) external auth {\n        require(!versionInformation[_version].exists, \"Version already exists\");\n        require(!versionNameExists[_name], \"Version name already exists\");\n        versionInformation[_version].exists = true;\n        versionNameExists[_name] = true;\n        versionInformation[_version].name = _name;\n        registeredVersions.push(_version);\n        emit VersionRegistration(_version);\n    }\n\n    function setIncentive(uint _weiAmount) external auth {\n        incentive = _weiAmount;\n        emit IncentiveChange(_weiAmount);\n    }\n\n    function setPriceSource(address _priceSource) external auth {\n        priceSource = _priceSource;\n        emit PriceSourceChange(_priceSource);\n    }\n\n    function setMlnToken(address _mlnToken) external auth {\n        mlnToken = _mlnToken;\n        emit MlnTokenChange(_mlnToken);\n    }\n\n    function setNativeAsset(address _nativeAsset) external auth {\n        nativeAsset = _nativeAsset;\n        emit NativeAssetChange(_nativeAsset);\n    }\n\n    function setEngine(address _engine) external auth {\n        engine = _engine;\n        emit EngineChange(_engine);\n    }\n\n    function setMGM(address _MGM) external auth {\n        MGM = _MGM;\n        emit MGMChange(_MGM);\n    }\n\n    function setEthfinexWrapperRegistry(address _registry) external auth {\n        ethfinexWrapperRegistry = _registry;\n        emit EfxWrapperRegistryChange(_registry);\n    }\n\n    /// @notice Updates description information of a registered Asset\n    /// @dev Pre: Owner can change an existing entry\n    /// @dev Post: Changed Name, Symbol, URL and/or IPFSHash\n    /// @param _asset Address of the asset to be updated\n    /// @param _name Human-readable name of the Asset\n    /// @param _symbol Human-readable symbol of the Asset\n    /// @param _url Url for extended information of the asset\n    function updateAsset(\n        address _asset,\n        string memory _name,\n        string memory _symbol,\n        string memory _url,\n        uint _reserveMin,\n        uint[] memory _standards,\n        bytes4[] memory _sigs\n    ) public auth {\n        require(assetInformation[_asset].exists);\n        Asset storage asset = assetInformation[_asset];\n        asset.name = _name;\n        asset.symbol = _symbol;\n        asset.decimals = ERC20WithFields(_asset).decimals();\n        asset.url = _url;\n        asset.reserveMin = _reserveMin;\n        asset.standards = _standards;\n        asset.sigs = _sigs;\n        emit AssetUpsert(\n            _asset,\n            _name,\n            _symbol,\n            asset.decimals,\n            _url,\n            _reserveMin,\n            _standards,\n            _sigs\n        );\n    }\n\n    function updateExchangeAdapter(\n        address _exchange,\n        address _adapter,\n        bool _takesCustody,\n        bytes4[] memory _sigs\n    ) public auth {\n        require(exchangeInformation[_adapter].exists, \"Exchange with adapter doesn't exist\");\n        Exchange storage exchange = exchangeInformation[_adapter];\n        exchange.exchangeAddress = _exchange;\n        exchange.takesCustody = _takesCustody;\n        exchange.sigs = _sigs;\n        emit ExchangeAdapterUpsert(\n            _exchange,\n            _adapter,\n            _takesCustody,\n            _sigs\n        );\n    }\n\n    /// @notice Deletes an existing entry\n    /// @dev Owner can delete an existing entry\n    /// @param _asset address for which specific information is requested\n    function removeAsset(\n        address _asset,\n        uint _assetIndex\n    ) external auth {\n        require(assetInformation[_asset].exists);\n        require(registeredAssets[_assetIndex] == _asset);\n        delete assetInformation[_asset];\n        delete registeredAssets[_assetIndex];\n        for (uint i = _assetIndex; i < registeredAssets.length-1; i++) {\n            registeredAssets[i] = registeredAssets[i+1];\n        }\n        registeredAssets.pop();\n        emit AssetRemoval(_asset);\n    }\n\n    /// @notice Deletes an existing entry\n    /// @dev Owner can delete an existing entry\n    /// @param _adapter address of the adapter of the exchange that is to be removed\n    /// @param _adapterIndex index of the exchange in array\n    function removeExchangeAdapter(\n        address _adapter,\n        uint _adapterIndex\n    ) external auth {\n        require(exchangeInformation[_adapter].exists, \"Exchange with adapter doesn't exist\");\n        require(registeredExchangeAdapters[_adapterIndex] == _adapter, \"Incorrect adapter index\");\n        delete exchangeInformation[_adapter];\n        delete registeredExchangeAdapters[_adapterIndex];\n        for (uint i = _adapterIndex; i < registeredExchangeAdapters.length-1; i++) {\n            registeredExchangeAdapters[i] = registeredExchangeAdapters[i+1];\n        }\n        registeredExchangeAdapters.pop();\n        emit ExchangeAdapterRemoval(_adapter);\n    }\n\n    function registerFees(address[] calldata _fees) external auth {\n        for (uint i; i < _fees.length; i++) {\n            isFeeRegistered[_fees[i]] = true;\n        }\n    }\n\n    function deregisterFees(address[] calldata _fees) external auth {\n        for (uint i; i < _fees.length; i++) {\n            delete isFeeRegistered[_fees[i]];\n        }\n    }\n\n    // PUBLIC VIEW METHODS\n\n    // get asset specific information\n    function getName(address _asset) external view returns (string memory) {\n        return assetInformation[_asset].name;\n    }\n    function getSymbol(address _asset) external view returns (string memory) {\n        return assetInformation[_asset].symbol;\n    }\n    function getDecimals(address _asset) external view returns (uint) {\n        return assetInformation[_asset].decimals;\n    }\n    function getReserveMin(address _asset) external view returns (uint) {\n        return assetInformation[_asset].reserveMin;\n    }\n    function assetIsRegistered(address _asset) external view returns (bool) {\n        return assetInformation[_asset].exists;\n    }\n    function getRegisteredAssets() external view returns (address[] memory) {\n        return registeredAssets;\n    }\n    function assetMethodIsAllowed(address _asset, bytes4 _sig)\n        external\n        view\n        returns (bool)\n    {\n        bytes4[] memory signatures = assetInformation[_asset].sigs;\n        for (uint i = 0; i < signatures.length; i++) {\n            if (signatures[i] == _sig) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // get exchange-specific information\n    function exchangeAdapterIsRegistered(address _adapter) external view returns (bool) {\n        return exchangeInformation[_adapter].exists;\n    }\n    function getRegisteredExchangeAdapters() external view returns (address[] memory) {\n        return registeredExchangeAdapters;\n    }\n    function getExchangeInformation(address _adapter)\n        public\n        view\n        returns (address, bool)\n    {\n        Exchange memory exchange = exchangeInformation[_adapter];\n        return (\n            exchange.exchangeAddress,\n            exchange.takesCustody\n        );\n    }\n    function exchangeForAdapter(address _adapter) external view returns (address) {\n        Exchange memory exchange = exchangeInformation[_adapter];\n        return exchange.exchangeAddress;\n    }\n    function getAdapterFunctionSignatures(address _adapter)\n        public\n        view\n        returns (bytes4[] memory)\n    {\n        return exchangeInformation[_adapter].sigs;\n    }\n    function adapterMethodIsAllowed(\n        address _adapter, bytes4 _sig\n    )\n        external\n        view\n        returns (bool)\n    {\n        bytes4[] memory signatures = exchangeInformation[_adapter].sigs;\n        for (uint i = 0; i < signatures.length; i++) {\n            if (signatures[i] == _sig) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // get version and fund information\n    function getRegisteredVersions() external view returns (address[] memory) {\n        return registeredVersions;\n    }\n\n    function isFund(address _who) external view returns (bool) {\n        if (fundsToVersions[_who] != address(0)) {\n            return true; // directly from a hub\n        } else {\n            Hub hub = Hub(Spoke(_who).hub());\n            require(\n                hub.isSpoke(_who),\n                \"Call from either a spoke or hub\"\n            );\n            return fundsToVersions[address(hub)] != address(0);\n        }\n    }\n\n    function isFundFactory(address _who) external view returns (bool) {\n        return versionInformation[_who].exists;\n    }\n}\n\n"
    },
    "./src/version/Version.sol": {
      "content": "pragma solidity 0.6.1;\npragma experimental ABIEncoderV2;\n\nimport \"../factory/FundFactory.sol\";\nimport \"../fund/hub/Hub.sol\";\n\n/// @notice Controlled by governance\ncontract Version is FundFactory, DSAuth {\n\n    constructor(\n        address _accountingFactory,\n        address _feeManagerFactory,\n        address _participationFactory,\n        address _sharesFactory,\n        address _tradingFactory,\n        address _vaultFactory,\n        address _policyManagerFactory,\n        address _registry,\n        address _postDeployOwner\n    )\n        public\n        FundFactory(\n            _accountingFactory,\n            _feeManagerFactory,\n            _participationFactory,\n            _sharesFactory,\n            _tradingFactory,\n            _vaultFactory,\n            _policyManagerFactory,\n            address(this)\n        )\n    {\n        associatedRegistry = Registry(_registry);\n        setOwner(_postDeployOwner);\n    }\n\n    function shutDownFund(address _hub) external {\n        require(\n            managersToHubs[msg.sender] == _hub,\n            \"Conditions not met for fund shutdown\"\n        );\n        Hub(_hub).shutDownFund();\n    }\n}\n"
    },
    "./tests/contracts/BooleanPolicy.sol": {
      "content": "pragma solidity 0.6.1;\n\ncontract BooleanPolicy {\n    enum Applied { pre, post }\n\n    bool allowed;\n\n    function rule(bytes4 sig, address[5] calldata addresses, uint[3] calldata values, bytes32 identifier) external returns (bool) {\n        return allowed;\n    }\n\n    function position() external pure returns (Applied) { return Applied.pre; }\n}\n\ncontract TruePolicy is BooleanPolicy {\n    constructor() public { allowed = true; }\n    function identifier() external pure returns (string memory) { return \"TruePolicy\"; }\n}\n\ncontract FalsePolicy is BooleanPolicy {\n    constructor() public { allowed = false; }\n    function identifier() external pure returns (string memory) { return \"FalsePolicy\"; }\n}\n"
    },
    "./tests/contracts/MaliciousToken.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"main/dependencies/token/PreminedToken.sol\";\n\ncontract MaliciousToken is PreminedToken {\n\n    bool public isReverting = false;\n\n    constructor(string memory _symbol, uint8 _decimals, string memory _name)\n        public\n        PreminedToken(_symbol, _decimals, _name)\n    {}\n\n    function startReverting() public {\n        isReverting = true;\n    }\n\n    function transfer(address _to, uint256 _value) public override returns (bool) {\n        require(!isReverting, \"I'm afraid I can't do that, Dave\");\n        super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        override\n        returns (bool)\n    {\n        require(!isReverting, \"I'm afraid I can't do that, Dave\");\n        super.transferFrom(_from, _to, _value);\n    }\n}\n"
    },
    "./tests/contracts/MockAccounting.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"main/fund/hub/Spoke.sol\";\n\n/// @dev Balances are fake and can be set by anyone (testing)\ncontract MockAccounting is Spoke {\n\n    uint public gav;\n    uint public nav;\n    uint public unclaimedFees;\n    uint public mockValuePerShare;\n\n    address[] public ownedAssets;\n    mapping (address => bool) public isInAssetList;\n    mapping (address => uint) public held; // mock total held across all components\n    mapping (address => uint) public assetGav;\n    address public DENOMINATION_ASSET;\n    address public NATIVE_ASSET;\n    uint public DEFAULT_SHARE_PRICE;\n    uint public SHARES_DECIMALS;\n\n    constructor(address _hub, address _denominationAsset, address _nativeAsset)\n        public\n        Spoke(_hub)\n    {\n        DENOMINATION_ASSET = _denominationAsset;\n        NATIVE_ASSET = _nativeAsset;\n        SHARES_DECIMALS = 18;\n        DEFAULT_SHARE_PRICE = 10 ** uint(SHARES_DECIMALS);\n    }\n\n    function setOwnedAssets(address[] memory _assets) public { ownedAssets = _assets; }\n    function getOwnedAssetsLength() public view returns (uint) { return ownedAssets.length; }\n    function setGav(uint _gav) public { gav = _gav; }\n    function setNav(uint _nav) public { nav = _nav; }\n    function setAssetGAV(address _asset, uint _amt) public { assetGav[_asset] = _amt; }\n    function setFundHoldings(uint[] memory _amounts, address[] memory _assets) public {\n        for (uint i = 0; i < _assets.length; i++) {\n            held[_assets[i]] = _amounts[i];\n        }\n    }\n\n    function getFundHoldings() public view returns (uint[] memory, address[] memory) {\n        uint[] memory _quantities = new uint[](ownedAssets.length);\n        address[] memory _assets = new address[](ownedAssets.length);\n        for (uint i = 0; i < ownedAssets.length; i++) {\n            address ofAsset = ownedAssets[i];\n            // holdings formatting: mul(exchangeHoldings, 10 ** assetDecimal)\n            uint quantityHeld = held[ofAsset];\n\n            if (quantityHeld != 0) {\n                _assets[i] = ofAsset;\n                _quantities[i] = quantityHeld;\n            }\n        }\n        return (_quantities, _assets);\n    }\n\n    function calcGav() public view returns (uint) { return gav; }\n    function calcNav() public view returns (uint) { return nav; }\n\n    function calcAssetGAV(address _a) public view returns (uint) { return assetGav[_a]; }\n\n    function valuePerShare(uint totalValue, uint numShares) public view returns (uint) {\n        return mockValuePerShare;\n    }\n\n    function performCalculations() public view returns (uint, uint, uint, uint, uint) {\n        return (gav, unclaimedFees, 0, nav, mockValuePerShare);\n    }\n\n    function calcSharePrice() public view returns (uint sharePrice) {\n        (,,,,sharePrice) = performCalculations();\n        return sharePrice;\n    }\n}\n"
    },
    "./tests/contracts/MockAdapter.sol": {
      "content": "pragma solidity 0.6.1;\npragma experimental ABIEncoderV2;\n\nimport \"main/fund/trading/Trading.sol\";\nimport \"main/fund/accounting/Accounting.sol\";\nimport \"main/exchanges/ExchangeAdapter.sol\";\n\ncontract MockAdapter is ExchangeAdapter {\n\n    //  METHODS\n\n    //  PUBLIC METHODS\n\n    /// @notice Mock make order\n    function makeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public override {\n        address makerAsset = orderAddresses[2];\n        address takerAsset = orderAddresses[3];\n        uint makerQuantity = orderValues[0];\n        uint takerQuantity = orderValues[1];\n\n        withdrawAndApproveAsset(makerAsset, targetExchange, makerQuantity, \"makerAsset\");\n\n        getTrading().orderUpdateHook(\n            targetExchange,\n            identifier,\n            Trading.UpdateType.make,\n            [payable(makerAsset), payable(takerAsset)],\n            [makerQuantity, takerQuantity, uint(0)]\n        );\n        getTrading().addOpenMakeOrder(targetExchange, makerAsset, takerAsset, uint(identifier), 0);\n    }\n\n    /// @notice Mock take order\n    function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public override {\n        address makerAsset = orderAddresses[2];\n        address takerAsset = orderAddresses[3];\n        uint makerQuantity = orderValues[0];\n        uint takerQuantity = orderValues[1];\n        uint fillTakerQuantity = orderValues[6];\n\n        withdrawAndApproveAsset(takerAsset, targetExchange, fillTakerQuantity, \"takerAsset\");\n\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(identifier),\n            Trading.UpdateType.take,\n            [payable(makerAsset), payable(takerAsset)],\n            [makerQuantity, takerQuantity, fillTakerQuantity]\n        );\n    }\n\n    /// @notice Mock cancel order\n    function cancelOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public override {\n        address makerAsset = orderAddresses[2];\n        uint makerQuantity = orderValues[0];\n\n        revokeApproveAsset(makerAsset, targetExchange, makerQuantity, \"makerAsset\");\n\n        getTrading().removeOpenMakeOrder(targetExchange, makerAsset);\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(identifier),\n            Trading.UpdateType.cancel,\n            [address(0), address(0)],\n            [uint(0), uint(0), uint(0)]\n        );\n    }\n}\n"
    },
    "./tests/contracts/MockFee.sol": {
      "content": "pragma solidity 0.6.1;\n\ncontract MockFee {\n\n    uint public fee;\n    uint public FEE_RATE;\n    uint public FEE_PERIOD;\n    uint public feeNumber;\n\n    constructor(uint _feeNumber) public {\n        feeNumber = _feeNumber;\n    }\n\n    function setFeeAmount(uint amount) public {\n        fee = amount;\n    }\n\n    function feeAmount() external returns (uint feeInShares) {\n        return fee;\n    }\n\n    function initializeForUser(uint feeRate, uint feePeriod, address denominationAsset) external {\n        fee = 0;\n        FEE_RATE = feeRate;\n        FEE_PERIOD = feePeriod;\n    }\n\n    function updateState() external {\n        fee = 0;\n    }\n\n    function identifier() external view returns (uint) {\n        return feeNumber;\n    }\n}\n\n"
    },
    "./tests/contracts/MockFeeManager.sol": {
      "content": "pragma solidity 0.6.1;\npragma experimental ABIEncoderV2;\n\nimport \"main/fund/hub/Spoke.sol\";\nimport \"main/fund/shares/Shares.sol\";\nimport \"main/factory/Factory.sol\";\nimport \"main/dependencies/DSMath.sol\";\nimport \"main/engine/AmguConsumer.sol\";\n\ncontract MockFeeManager is DSMath, Spoke, AmguConsumer {\n\n    struct FeeInfo {\n        address feeAddress;\n        uint feeRate;\n        uint feePeriod;\n    }\n\n    uint totalFees;\n    uint performanceFees;\n\n    constructor(\n        address _hub,\n        address _denominationAsset,\n        address[] memory _fees,\n        uint[] memory _periods,\n        uint _rates,\n        address registry\n    ) Spoke(_hub) public {}\n\n    function setTotalFeeAmount(uint _amt) public { totalFees = _amt; }\n    function setPerformanceFeeAmount(uint _amt) public { performanceFees = _amt; }\n\n    function rewardManagementFee() public { return; }\n    function performanceFeeAmount() external returns (uint) { return performanceFees; }\n    function totalFeeAmount() external returns (uint) { return totalFees; }\n    function engine() public view override(AmguConsumer, Spoke) returns (address) { return routes.engine; }\n    function mlnToken() public view override(AmguConsumer, Spoke) returns (address) { return routes.mlnToken; }\n    function priceSource() public view override(AmguConsumer, Spoke) returns (address) { return hub.priceSource(); }\n    function registry() public view override(AmguConsumer, Spoke) returns (address) { return routes.registry; }\n}\n"
    },
    "./tests/contracts/MockHub.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"main/dependencies/DSGuard.sol\";\nimport \"main/fund/hub/Spoke.sol\";\nimport \"main/version/Registry.sol\";\n\n/// @notice Hub used for testing\ncontract MockHub is DSGuard {\n\n    struct Routes {\n        address accounting;\n        address feeManager;\n        address participation;\n        address policyManager;\n        address shares;\n        address trading;\n        address vault;\n        address registry;\n        address version;\n        address engine;\n        address mlnAddress;\n    }\n    Routes public routes;\n    address public manager;\n    string public name;\n    bool public isShutDown;\n\n    function setManager(address _manager) public { manager = _manager; }\n\n    function setName(string memory _name) public { name = _name; }\n\n    function shutDownFund() public { isShutDown = true; }\n\n    function setShutDownState(bool _state) public { isShutDown = _state; }\n\n    function setSpokes(address[11] memory _spokes) public {\n        routes.accounting = _spokes[0];\n        routes.feeManager = _spokes[1];\n        routes.participation = _spokes[2];\n        routes.policyManager = _spokes[3];\n        routes.shares = _spokes[4];\n        routes.trading = _spokes[5];\n        routes.vault = _spokes[6];\n        routes.registry = _spokes[7];\n        routes.version = _spokes[8];\n        routes.engine = _spokes[9];\n        routes.mlnAddress = _spokes[10];\n    }\n\n    function setRouting() public {\n        address[11] memory spokes = [\n            routes.accounting, routes.feeManager, routes.participation,\n            routes.policyManager, routes.shares, routes.trading,\n            routes.vault, routes.registry, routes.version,\n            routes.engine, routes.mlnAddress\n        ];\n        Spoke(routes.accounting).initialize(spokes);\n        Spoke(routes.feeManager).initialize(spokes);\n        Spoke(routes.participation).initialize(spokes);\n        Spoke(routes.policyManager).initialize(spokes);\n        Spoke(routes.shares).initialize(spokes);\n        Spoke(routes.trading).initialize(spokes);\n        Spoke(routes.vault).initialize(spokes);\n    }\n\n    function setPermissions() public {\n        permit(routes.participation, routes.vault, bytes4(keccak256('withdraw(address,uint256)')));\n        permit(routes.trading, routes.vault, bytes4(keccak256('withdraw(address,uint256)')));\n        permit(routes.participation, routes.shares, bytes4(keccak256('createFor(address,uint256)')));\n        permit(routes.participation, routes.shares, bytes4(keccak256('destroyFor(address,uint256)')));\n        permit(routes.feeManager, routes.shares, bytes4(keccak256('createFor(address,uint256)')));\n        permit(routes.participation, routes.accounting, bytes4(keccak256('addAssetToOwnedAssets(address)')));\n        permit(routes.participation, routes.accounting, bytes4(keccak256('removeFromOwnedAssets(address)')));\n        permit(routes.trading, routes.accounting, bytes4(keccak256('addAssetToOwnedAssets(address)')));\n        permit(routes.trading, routes.accounting, bytes4(keccak256('removeFromOwnedAssets(address)')));\n        permit(routes.accounting, routes.feeManager, bytes4(keccak256('rewardAllFees()')));\n        permit(manager, routes.feeManager, bytes4(keccak256('register(address)')));\n        permit(manager, routes.feeManager, bytes4(keccak256('batchRegister(address[])')));\n        permit(manager, routes.policyManager, bytes4(keccak256('register(bytes4,address)')));\n        permit(manager, routes.policyManager, bytes4(keccak256('batchRegister(bytes4[],address[])')));\n        permit(manager, routes.participation, bytes4(keccak256('enableInvestment(address[])')));\n        permit(manager, routes.participation, bytes4(keccak256('disableInvestment(address[])')));\n        permit(bytes32(bytes20(msg.sender)), ANY, ANY);\n    }\n\n    function permitSomething(address _from, address _to, bytes4 _sig) public {\n        permit(\n            bytes32(bytes20(_from)),\n            bytes32(bytes20(_to)),\n            _sig\n        );\n    }\n\n    function initializeSpoke(address _spoke) public {\n        address[11] memory spokes = [\n            routes.accounting, routes.feeManager, routes.participation,\n            routes.policyManager, routes.shares, routes.trading,\n            routes.vault, routes.registry, routes.version,\n            routes.engine, routes.mlnAddress\n        ];\n        Spoke(_spoke).initialize(spokes);\n    }\n\n    function vault() public view returns (address) { return routes.vault; }\n    function accounting() public view returns (address) { return routes.accounting; }\n    function priceSource() public view returns (address) { return Registry(routes.registry).priceSource(); }\n    function participation() public view returns (address) { return routes.participation; }\n    function trading() public view returns (address) { return routes.trading; }\n    function shares() public view returns (address) { return routes.shares; }\n    function policyManager() public view returns (address) { return routes.policyManager; }\n    function registry() public view returns (address) { return routes.registry; }\n}\n\n"
    },
    "./tests/contracts/MockRegistry.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"main/dependencies/DSAuth.sol\";\n\n/// @dev Simplified for testing, and by default rigged to always return true\ncontract MockRegistry is DSAuth {\n\n    bool public alwaysRegistered = true;\n    bool public methodAllowed = true;\n\n    address public priceSource;\n    address public mlnToken;\n    address public nativeAsset;\n    address public engine;\n    address public fundFactory;\n    address[] public assets;\n    uint public incentive;\n    mapping (address => bool) public registered;\n    mapping (address => bool) public fundExists;\n    mapping (address => address) public exchangeForAdapter;\n    mapping (address => bool) public takesCustodyForAdapter;\n\n\n    function register(address _addr) public {\n        registered[_addr] = true;\n        assets.push(_addr);\n    }\n\n    function remove(address _addr) public {\n        delete registered[_addr];\n    }\n\n    function assetIsRegistered(address _asset) public view returns (bool) {\n        return alwaysRegistered || registered[_asset];\n    }\n\n    function exchangeAdapterIsRegistered(address _adapter) public view returns (bool) {\n        return alwaysRegistered || registered[_adapter];\n    }\n\n    function registerExchangeAdapter(\n        address _exchange,\n        address _adapter\n    ) public {\n        exchangeForAdapter[_adapter] = _exchange;\n        takesCustodyForAdapter[_adapter] = true;\n    }\n\n    function adapterMethodIsAllowed(\n        address _adapter,\n        bytes4 _sig\n    ) public view returns (bool) { return methodAllowed; }\n\n    function setPriceSource(address _a) public { priceSource = _a; }\n    function setMlnToken(address _a) public { mlnToken = _a; }\n    function setNativeAsset(address _a) public { nativeAsset = _a; }\n    function setEngine(address _a) public { engine = _a; }\n    function setFundFactory(address _a) public { fundFactory = _a; }\n    function setIsFund(address _who) public { fundExists[_who] = true; }\n\n    function isFund(address _who) public view returns (bool) { return fundExists[_who]; }\n    function isFundFactory(address _who) public view returns (bool) {\n        return _who == fundFactory;\n    }\n    function getRegisteredAssets() public view returns (address[] memory) { return assets; }\n    function getReserveMin(address _asset) public view returns (uint) { return 0; }\n    function isFeeRegistered(address _fee) public view returns (bool) {\n        return alwaysRegistered;\n    }\n    function getExchangeInformation(address _adapter)\n        public\n        view\n        returns (address, bool)\n    {\n        return (\n            exchangeForAdapter[_adapter],\n            takesCustodyForAdapter[_adapter]\n        );\n    }\n}\n\n"
    },
    "./tests/contracts/MockShares.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"main/fund/hub/Spoke.sol\";\nimport \"main/dependencies/token/StandardToken.sol\";\n\n/// @dev Shares can be destroyed and created by anyone (testing)\ncontract MockShares is Spoke, StandardToken {\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n\n    constructor(address _hub) public Spoke(_hub) {\n        name = hub.name();\n        symbol = \"MOCK\";\n        decimals = 18;\n    }\n\n    function createFor(address who, uint amount) public {\n        _mint(who, amount);\n    }\n\n    function destroyFor(address who, uint amount) public {\n        _burn(who, amount);\n    }\n\n    function setBalanceFor(address who, uint newBalance) public {\n        uint currentBalance = balances[who];\n        if (currentBalance > newBalance) {\n            destroyFor(who, currentBalance.sub(newBalance));\n        } else if (balances[who] < newBalance) {\n            createFor(who, newBalance.sub(currentBalance));\n        }\n    }\n}\n\n"
    },
    "./tests/contracts/MockVersion.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"main/fund/hub/Hub.sol\";\n\n/// @notice Version contract useful for testing\ncontract MockVersion {\n    uint public amguPrice;\n    bool public isShutDown;\n\n    function setAmguPrice(uint _price) public { amguPrice = _price; }\n    function securityShutDown() external { isShutDown = true; }\n    function shutDownFund(address _hub) external { Hub(_hub).shutDownFund(); }\n    function getShutDownStatus() external view returns (bool) {return isShutDown;}\n    function getAmguPrice() public view returns (uint) { return amguPrice; }\n}\n"
    },
    "./tests/contracts/PermissiveAuthority.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"main/dependencies/DSAuth.sol\";\n\ncontract PermissiveAuthority is DSAuthority {\n    function canCall(address src, address dst, bytes4 sig)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return true;\n    }\n}\n"
    },
    "./tests/contracts/SelfDestructing.sol": {
      "content": "pragma solidity 0.6.1;\n\n/// @dev Useful for testing force-sending of funds\ncontract SelfDestructing {\n    function bequeath(address payable _heir) public {\n        selfdestruct(_heir);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "./tests/contracts/TestingPriceFeed.sol": {
      "content": "pragma solidity 0.6.1;\n\nimport \"main/dependencies/token/IERC20.sol\";\nimport \"main/dependencies/DSMath.sol\";\n\n/// @notice Intended for testing purposes only\n/// @notice Updates and exposes price information\ncontract TestingPriceFeed is DSMath {\n    event PriceUpdate(address[] token, uint[] price);\n\n    struct Data {\n        uint price;\n        uint timestamp;\n    }\n\n    address public QUOTE_ASSET;\n    uint public updateId;\n    uint public lastUpdate;\n    mapping(address => Data) public assetsToPrices;\n    mapping(address => uint) public assetsToDecimals;\n    bool mockIsRecent = true;\n    bool neverValid = false;\n\n    constructor(address _quoteAsset, uint _quoteDecimals) public {\n        QUOTE_ASSET = _quoteAsset;\n        setDecimals(_quoteAsset, _quoteDecimals);\n    }\n\n    /**\n      Input price is how much quote asset you would get\n      for one unit of _asset (10**assetDecimals)\n     */\n    function update(address[] calldata _assets, uint[] calldata _prices) external {\n        require(_assets.length == _prices.length, \"Array lengths unequal\");\n        updateId++;\n        for (uint i = 0; i < _assets.length; ++i) {\n            assetsToPrices[_assets[i]] = Data({\n                timestamp: block.timestamp,\n                price: _prices[i]\n            });\n        }\n        lastUpdate = block.timestamp;\n        emit PriceUpdate(_assets, _prices);\n    }\n\n    function getPrice(address ofAsset)\n        public\n        view\n        returns (uint price, uint timestamp)\n    {\n        Data storage data = assetsToPrices[ofAsset];\n        return (data.price, data.timestamp);\n    }\n\n    function getPrices(address[] memory ofAssets)\n        public\n        view\n        returns (uint[] memory, uint[] memory)\n    {\n        uint[] memory prices = new uint[](ofAssets.length);\n        uint[] memory timestamps = new uint[](ofAssets.length);\n        for (uint i; i < ofAssets.length; i++) {\n            uint price;\n            uint timestamp;\n            (price, timestamp) = getPrice(ofAssets[i]);\n            prices[i] = price;\n            timestamps[i] = timestamp;\n        }\n        return (prices, timestamps);\n    }\n\n    function getPriceInfo(address ofAsset)\n        public\n        view\n        returns (uint price, uint assetDecimals)\n    {\n        (price, ) = getPrice(ofAsset);\n        assetDecimals = assetsToDecimals[ofAsset];\n    }\n\n    function getInvertedPriceInfo(address ofAsset)\n        public\n        view\n        returns (uint invertedPrice, uint assetDecimals)\n    {\n        uint inputPrice;\n        // inputPrice quoted in QUOTE_ASSET and multiplied by 10 ** assetDecimal\n        (inputPrice, assetDecimals) = getPriceInfo(ofAsset);\n\n        // outputPrice based in QUOTE_ASSET and multiplied by 10 ** quoteDecimal\n        uint quoteDecimals = assetsToDecimals[QUOTE_ASSET];\n\n        return (\n            mul(\n                10 ** uint(quoteDecimals),\n                10 ** uint(assetDecimals)\n            ) / inputPrice,\n            quoteDecimals\n        );\n    }\n\n    function setNeverValid(bool _state) public {\n        neverValid = _state;\n    }\n\n    function setIsRecent(bool _state) public {\n        mockIsRecent = _state;\n    }\n\n    // NB: not permissioned; anyone can change this in a test\n    function setDecimals(address _asset, uint _decimal) public {\n        assetsToDecimals[_asset] = _decimal;\n    }\n\n    // needed just to get decimals for prices\n    function batchSetDecimals(address[] memory _assets, uint[] memory _decimals) public {\n        require(_assets.length == _decimals.length, \"Array lengths unequal\");\n        for (uint i = 0; i < _assets.length; i++) {\n            setDecimals(_assets[i], _decimals[i]);\n        }\n    }\n\n    function getReferencePriceInfo(address ofBase, address ofQuote)\n        public\n        view\n        returns (uint referencePrice, uint decimal)\n    {\n        uint quoteDecimals = assetsToDecimals[ofQuote];\n\n        // Price of 1 unit for the pair of same asset\n        if (ofBase == ofQuote) {\n            return (10 ** uint(quoteDecimals), quoteDecimals);\n        }\n\n        referencePrice = mul(\n            assetsToPrices[ofBase].price,\n            10 ** uint(quoteDecimals)\n        ) / assetsToPrices[ofQuote].price;\n\n        return (referencePrice, quoteDecimals);\n    }\n\n    function getOrderPriceInfo(\n        address sellAsset,\n        address buyAsset,\n        uint sellQuantity,\n        uint buyQuantity\n    )\n        public\n        view\n        returns (uint orderPrice)\n    {\n        return mul(buyQuantity, 10 ** uint(assetsToDecimals[sellAsset])) / sellQuantity;\n    }\n\n    /// @notice Doesn't check validity as TestingPriceFeed has no validity variable\n    /// @param _asset Asset in registrar\n    /// @return isValid Price information ofAsset is recent\n    function hasValidPrice(address _asset)\n        public\n        view\n        returns (bool isValid)\n    {\n        uint price;\n        (price, ) = getPrice(_asset);\n\n        return !neverValid && price != 0;\n    }\n\n    function hasValidPrices(address[] memory _assets)\n        public\n        view\n        returns (bool)\n    {\n        for (uint i; i < _assets.length; i++) {\n            if (!hasValidPrice(_assets[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Checks whether data exists for a given asset pair\n    /// @dev Prices are only upated against QUOTE_ASSET\n    /// @param sellAsset Asset for which check to be done if data exists\n    /// @param buyAsset Asset for which check to be done if data exists\n    function existsPriceOnAssetPair(address sellAsset, address buyAsset)\n        public\n        view\n        returns (bool isExistent)\n    {\n        return\n            hasValidPrice(sellAsset) &&\n            hasValidPrice(buyAsset);\n    }\n\n    function getLastUpdateId() public view returns (uint) { return updateId; }\n    function getQuoteAsset() public view returns (address) { return QUOTE_ASSET; }\n\n    /// @notice Get quantity of toAsset equal in value to given quantity of fromAsset\n    function convertQuantity(\n        uint fromAssetQuantity,\n        address fromAsset,\n        address toAsset\n    )\n        public\n        view\n        returns (uint)\n    {\n        uint fromAssetPrice;\n        (fromAssetPrice,) = getReferencePriceInfo(fromAsset, toAsset);\n        uint fromAssetDecimals = ERC20WithFields(fromAsset).decimals();\n        return mul(\n            fromAssetQuantity,\n            fromAssetPrice\n        ) / (10 ** uint(fromAssetDecimals));\n    }\n\n    function getLastUpdate() public view returns (uint) { return lastUpdate; }\n}\n\n"
    }
  }
}}