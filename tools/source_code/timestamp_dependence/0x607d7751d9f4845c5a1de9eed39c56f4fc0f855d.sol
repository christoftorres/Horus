{"ConversionRatesInterface.sol":{"content":"pragma solidity 0.4.18;\n\n\nimport \"./ERC20Interface.sol\";\n\n\ninterface ConversionRatesInterface {\n\n    function recordImbalance(\n        ERC20 token,\n        int buyAmount,\n        uint rateUpdateBlock,\n        uint currentBlock\n    )\n        public;\n\n    function getRate(ERC20 token, uint currentBlockNumber, bool buy, uint qty) public view returns(uint);\n}\n"},"ERC20Interface.sol":{"content":"pragma solidity 0.4.18;\n\n\n// https://github.com/ethereum/EIPs/issues/20\ninterface ERC20 {\n    function totalSupply() public view returns (uint supply);\n    function balanceOf(address _owner) public view returns (uint balance);\n    function transfer(address _to, uint _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n    function approve(address _spender, uint _value) public returns (bool success);\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\n    function decimals() public view returns(uint digits);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n"},"KyberReserve.sol":{"content":"pragma solidity 0.4.18;\n\n\nimport \"../ERC20Interface.sol\";\nimport \"../Utils.sol\";\nimport \"../Withdrawable.sol\";\nimport \"../ConversionRatesInterface.sol\";\nimport \"../SanityRatesInterface.sol\";\nimport \"../KyberReserveInterface.sol\";\n\n\n/// @title Kyber Reserve contract\ncontract KyberReserve is KyberReserveInterface, Withdrawable, Utils {\n\n    address public kyberNetwork;\n    bool public tradeEnabled;\n    ConversionRatesInterface public conversionRatesContract;\n    SanityRatesInterface public sanityRatesContract;\n    mapping(bytes32=\u003ebool) public approvedWithdrawAddresses; // sha3(token,address)=\u003ebool\n    mapping(address=\u003eaddress) public tokenWallet;\n\n    function KyberReserve(address _kyberNetwork, ConversionRatesInterface _ratesContract, address _admin) public {\n        require(_admin != address(0));\n        require(_ratesContract != address(0));\n        require(_kyberNetwork != address(0));\n        kyberNetwork = _kyberNetwork;\n        conversionRatesContract = _ratesContract;\n        admin = _admin;\n        tradeEnabled = true;\n    }\n\n    event DepositToken(ERC20 token, uint amount);\n\n    function() public payable {\n        DepositToken(ETH_TOKEN_ADDRESS, msg.value);\n    }\n\n    event TradeExecute(\n        address indexed origin,\n        address src,\n        uint srcAmount,\n        address destToken,\n        uint destAmount,\n        address destAddress\n    );\n\n    function trade(\n        ERC20 srcToken,\n        uint srcAmount,\n        ERC20 destToken,\n        address destAddress,\n        uint conversionRate,\n        bool validate\n    )\n        public\n        payable\n        returns(bool)\n    {\n        require(tradeEnabled);\n        require(msg.sender == kyberNetwork);\n\n        require(doTrade(srcToken, srcAmount, destToken, destAddress, conversionRate, validate));\n\n        return true;\n    }\n\n    event TradeEnabled(bool enable);\n\n    function enableTrade() public onlyAdmin returns(bool) {\n        tradeEnabled = true;\n        TradeEnabled(true);\n\n        return true;\n    }\n\n    function disableTrade() public onlyAlerter returns(bool) {\n        tradeEnabled = false;\n        TradeEnabled(false);\n\n        return true;\n    }\n\n    event WithdrawAddressApproved(ERC20 token, address addr, bool approve);\n\n    function approveWithdrawAddress(ERC20 token, address addr, bool approve) public onlyAdmin {\n        approvedWithdrawAddresses[keccak256(token, addr)] = approve;\n        WithdrawAddressApproved(token, addr, approve);\n\n        setDecimals(token);\n        if ((tokenWallet[token] == address(0x0)) \u0026\u0026 (token != ETH_TOKEN_ADDRESS)) {\n            tokenWallet[token] = this; // by default\n            require(token.approve(this, 2 ** 255));\n        }\n    }\n\n    event NewTokenWallet(ERC20 token, address wallet);\n\n    function setTokenWallet(ERC20 token, address wallet) public onlyAdmin {\n        require(wallet != address(0x0));\n        tokenWallet[token] = wallet;\n        NewTokenWallet(token, wallet);\n    }\n\n    event WithdrawFunds(ERC20 token, uint amount, address destination);\n\n    function withdraw(ERC20 token, uint amount, address destination) public onlyOperator returns(bool) {\n        require(approvedWithdrawAddresses[keccak256(token, destination)]);\n\n        if (token == ETH_TOKEN_ADDRESS) {\n            destination.transfer(amount);\n        } else {\n            require(token.transferFrom(tokenWallet[token], destination, amount));\n        }\n\n        WithdrawFunds(token, amount, destination);\n\n        return true;\n    }\n\n    event SetContractAddresses(address network, address rate, address sanity);\n\n    function setContracts(\n        address _kyberNetwork,\n        ConversionRatesInterface _conversionRates,\n        SanityRatesInterface _sanityRates\n    )\n        public\n        onlyAdmin\n    {\n        require(_kyberNetwork != address(0));\n        require(_conversionRates != address(0));\n\n        kyberNetwork = _kyberNetwork;\n        conversionRatesContract = _conversionRates;\n        sanityRatesContract = _sanityRates;\n\n        SetContractAddresses(kyberNetwork, conversionRatesContract, sanityRatesContract);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    /// status functions ///////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////\n    function getBalance(ERC20 token) public view returns(uint) {\n        if (token == ETH_TOKEN_ADDRESS)\n            return this.balance;\n        else {\n            address wallet = tokenWallet[token];\n            uint balanceOfWallet = token.balanceOf(wallet);\n            uint allowanceOfWallet = token.allowance(wallet, this);\n\n            return (balanceOfWallet \u003c allowanceOfWallet) ? balanceOfWallet : allowanceOfWallet;\n        }\n    }\n\n    function getDestQty(ERC20 src, ERC20 dest, uint srcQty, uint rate) public view returns(uint) {\n        uint dstDecimals = getDecimals(dest);\n        uint srcDecimals = getDecimals(src);\n\n        return calcDstQty(srcQty, srcDecimals, dstDecimals, rate);\n    }\n\n    function getSrcQty(ERC20 src, ERC20 dest, uint dstQty, uint rate) public view returns(uint) {\n        uint dstDecimals = getDecimals(dest);\n        uint srcDecimals = getDecimals(src);\n\n        return calcSrcQty(dstQty, srcDecimals, dstDecimals, rate);\n    }\n\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns(uint) {\n        ERC20 token;\n        bool  isBuy;\n\n        if (!tradeEnabled) return 0;\n\n        if (ETH_TOKEN_ADDRESS == src) {\n            isBuy = true;\n            token = dest;\n        } else if (ETH_TOKEN_ADDRESS == dest) {\n            isBuy = false;\n            token = src;\n        } else {\n            return 0; // pair is not listed\n        }\n\n        uint rate = conversionRatesContract.getRate(token, blockNumber, isBuy, srcQty);\n        uint destQty = getDestQty(src, dest, srcQty, rate);\n\n        if (getBalance(dest) \u003c destQty) return 0;\n\n        if (sanityRatesContract != address(0)) {\n            uint sanityRate = sanityRatesContract.getSanityRate(src, dest);\n            if (rate \u003e sanityRate) return 0;\n        }\n\n        return rate;\n    }\n\n    /// @dev do a trade\n    /// @param srcToken Src token\n    /// @param srcAmount Amount of src token\n    /// @param destToken Destination token\n    /// @param destAddress Destination address to send tokens to\n    /// @param validate If true, additional validations are applicable\n    /// @return true iff trade is successful\n    function doTrade(\n        ERC20 srcToken,\n        uint srcAmount,\n        ERC20 destToken,\n        address destAddress,\n        uint conversionRate,\n        bool validate\n    )\n        internal\n        returns(bool)\n    {\n        // can skip validation if done at kyber network level\n        if (validate) {\n            require(conversionRate \u003e 0);\n            if (srcToken == ETH_TOKEN_ADDRESS)\n                require(msg.value == srcAmount);\n            else\n                require(msg.value == 0);\n        }\n\n        uint destAmount = getDestQty(srcToken, destToken, srcAmount, conversionRate);\n        // sanity check\n        require(destAmount \u003e 0);\n\n        // add to imbalance\n        ERC20 token;\n        int tradeAmount;\n        if (srcToken == ETH_TOKEN_ADDRESS) {\n            tradeAmount = int(destAmount);\n            token = destToken;\n        } else {\n            tradeAmount = -1 * int(srcAmount);\n            token = srcToken;\n        }\n\n        conversionRatesContract.recordImbalance(\n            token,\n            tradeAmount,\n            0,\n            block.number\n        );\n\n        // collect src tokens\n        if (srcToken != ETH_TOKEN_ADDRESS) {\n            require(srcToken.transferFrom(msg.sender, tokenWallet[srcToken], srcAmount));\n        }\n\n        // send dest tokens\n        if (destToken == ETH_TOKEN_ADDRESS) {\n            destAddress.transfer(destAmount);\n        } else {\n            require(destToken.transferFrom(tokenWallet[destToken], destAddress, destAmount));\n        }\n\n        TradeExecute(msg.sender, srcToken, srcAmount, destToken, destAmount, destAddress);\n\n        return true;\n    }\n}\n"},"KyberReserveInterface.sol":{"content":"pragma solidity 0.4.18;\n\n\nimport \"./ERC20Interface.sol\";\n\n/// @title Kyber Reserve contract\ninterface KyberReserveInterface {\n\n    function trade(\n        ERC20 srcToken,\n        uint srcAmount,\n        ERC20 destToken,\n        address destAddress,\n        uint conversionRate,\n        bool validate\n    )\n        public\n        payable\n        returns(bool);\n\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns(uint);\n}\n"},"PermissionGroups.sol":{"content":"pragma solidity 0.4.18;\n\n\ncontract PermissionGroups {\n\n    address public admin;\n    address public pendingAdmin;\n    mapping(address=\u003ebool) internal operators;\n    mapping(address=\u003ebool) internal alerters;\n    address[] internal operatorsGroup;\n    address[] internal alertersGroup;\n    uint constant internal MAX_GROUP_SIZE = 50;\n\n    function PermissionGroups() public {\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(operators[msg.sender]);\n        _;\n    }\n\n    modifier onlyAlerter() {\n        require(alerters[msg.sender]);\n        _;\n    }\n\n    function getOperators () external view returns(address[]) {\n        return operatorsGroup;\n    }\n\n    function getAlerters () external view returns(address[]) {\n        return alertersGroup;\n    }\n\n    event TransferAdminPending(address pendingAdmin);\n\n    /**\n     * @dev Allows the current admin to set the pendingAdmin address.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdmin(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0));\n        TransferAdminPending(pendingAdmin);\n        pendingAdmin = newAdmin;\n    }\n\n    /**\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0));\n        TransferAdminPending(newAdmin);\n        AdminClaimed(newAdmin, admin);\n        admin = newAdmin;\n    }\n\n    event AdminClaimed( address newAdmin, address previousAdmin);\n\n    /**\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\n     */\n    function claimAdmin() public {\n        require(pendingAdmin == msg.sender);\n        AdminClaimed(pendingAdmin, admin);\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n    event AlerterAdded (address newAlerter, bool isAdd);\n\n    function addAlerter(address newAlerter) public onlyAdmin {\n        require(!alerters[newAlerter]); // prevent duplicates.\n        require(alertersGroup.length \u003c MAX_GROUP_SIZE);\n\n        AlerterAdded(newAlerter, true);\n        alerters[newAlerter] = true;\n        alertersGroup.push(newAlerter);\n    }\n\n    function removeAlerter (address alerter) public onlyAdmin {\n        require(alerters[alerter]);\n        alerters[alerter] = false;\n\n        for (uint i = 0; i \u003c alertersGroup.length; ++i) {\n            if (alertersGroup[i] == alerter) {\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\n                alertersGroup.length--;\n                AlerterAdded(alerter, false);\n                break;\n            }\n        }\n    }\n\n    event OperatorAdded(address newOperator, bool isAdd);\n\n    function addOperator(address newOperator) public onlyAdmin {\n        require(!operators[newOperator]); // prevent duplicates.\n        require(operatorsGroup.length \u003c MAX_GROUP_SIZE);\n\n        OperatorAdded(newOperator, true);\n        operators[newOperator] = true;\n        operatorsGroup.push(newOperator);\n    }\n\n    function removeOperator (address operator) public onlyAdmin {\n        require(operators[operator]);\n        operators[operator] = false;\n\n        for (uint i = 0; i \u003c operatorsGroup.length; ++i) {\n            if (operatorsGroup[i] == operator) {\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\n                operatorsGroup.length -= 1;\n                OperatorAdded(operator, false);\n                break;\n            }\n        }\n    }\n}\n"},"SanityRatesInterface.sol":{"content":"pragma solidity 0.4.18;\n\n\nimport \"./ERC20Interface.sol\";\n\ninterface SanityRatesInterface {\n    function getSanityRate(ERC20 src, ERC20 dest) public view returns(uint);\n}\n"},"Utils.sol":{"content":"pragma solidity 0.4.18;\n\n\nimport \"./ERC20Interface.sol\";\n\n\n/// @title Kyber constants contract\ncontract Utils {\n\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n    uint  constant internal PRECISION = (10**18);\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\n    uint  constant internal MAX_DECIMALS = 18;\n    uint  constant internal ETH_DECIMALS = 18;\n    mapping(address=\u003euint) internal decimals;\n\n    function setDecimals(ERC20 token) internal {\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\n        else decimals[token] = token.decimals();\n    }\n\n    function getDecimals(ERC20 token) internal view returns(uint) {\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\n        uint tokenDecimals = decimals[token];\n        // technically, there might be token with decimals 0\n        // moreover, very possible that old tokens have decimals 0\n        // these tokens will just have higher gas fees.\n        if(tokenDecimals == 0) return token.decimals();\n\n        return tokenDecimals;\n    }\n\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\n        require(srcQty \u003c= MAX_QTY);\n        require(rate \u003c= MAX_RATE);\n\n        if (dstDecimals \u003e= srcDecimals) {\n            require((dstDecimals - srcDecimals) \u003c= MAX_DECIMALS);\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\n        } else {\n            require((srcDecimals - dstDecimals) \u003c= MAX_DECIMALS);\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\n        }\n    }\n\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\n        require(dstQty \u003c= MAX_QTY);\n        require(rate \u003c= MAX_RATE);\n        \n        //source quantity is rounded up. to avoid dest quantity being too low.\n        uint numerator;\n        uint denominator;\n        if (srcDecimals \u003e= dstDecimals) {\n            require((srcDecimals - dstDecimals) \u003c= MAX_DECIMALS);\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\n            denominator = rate;\n        } else {\n            require((dstDecimals - srcDecimals) \u003c= MAX_DECIMALS);\n            numerator = (PRECISION * dstQty);\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\n        }\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\n    }\n}\n"},"Withdrawable.sol":{"content":"pragma solidity 0.4.18;\n\n\nimport \"./ERC20Interface.sol\";\nimport \"./PermissionGroups.sol\";\n\n\n/**\n * @title Contracts that should be able to recover tokens or ethers\n * @author Ilan Doron\n * @dev This allows to recover any tokens or Ethers received in a contract.\n * This will prevent any accidental loss of tokens.\n */\ncontract Withdrawable is PermissionGroups {\n\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\n\n    /**\n     * @dev Withdraw all ERC20 compatible tokens\n     * @param token ERC20 The address of the token contract\n     */\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\n        require(token.transfer(sendTo, amount));\n        TokenWithdraw(token, amount, sendTo);\n    }\n\n    event EtherWithdraw(uint amount, address sendTo);\n\n    /**\n     * @dev Withdraw Ethers\n     */\n    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\n        sendTo.transfer(amount);\n        EtherWithdraw(amount, sendTo);\n    }\n}\n"}}