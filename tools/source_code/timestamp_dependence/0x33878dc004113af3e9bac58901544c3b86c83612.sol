{"AssetSwap.sol":{"content":"pragma solidity 0.5.15;\r\n\r\nimport \"./Book.sol\";\r\nimport \"./Oracle.sol\";\r\n\r\n\r\ncontract AssetSwap {\r\n\r\n    constructor (address priceOracle, int _levRatio)\r\n        public {\r\n            administrators[msg.sender] = true;\r\n            feeAddress = msg.sender;\r\n            oracle = Oracle(priceOracle);\r\n            leverageRatio = _levRatio;\r\n        }\r\n\r\n    Oracle public oracle;\r\n    int[5][2] public assetReturns; /// these are   pushed by the oracle each week\r\n    int public leverageRatio;\r\n    uint public lastOracleSettleTime; /// updates at time of oracle settlement.\r\n    /// Used a lot so this is written to the contract\r\n    mapping(address =\u003e address) public books;  /// LP eth address to book contract address\r\n    mapping(address =\u003e uint) public assetSwapBalance;  /// how ETH is ultimately withdrawn\r\n    mapping(address =\u003e bool) public administrators;  /// gives user right to key functions\r\n    address payable public feeAddress;   /// address for oracle fees PAYABLE!!\r\n\r\n    event SubkTracker(\r\n        address indexed eLP,\r\n        address indexed eTaker,\r\n        bytes32 eSubkID,\r\n        bool eisOpen);\r\n\r\n    event PauseOnTakes(\r\n        bool openForNewTakes);\r\n\r\n    event BurnHist(\r\n        address eLP,\r\n        bytes32 eSubkID,\r\n        address eBurner,\r\n        uint eTime);\r\n\r\n    event LPNewBook(\r\n        address indexed eLP,\r\n        address eLPBook);\r\n\r\n    event RatesUpdated(\r\n        address indexed eLP,\r\n        uint8 closefee,\r\n        int16 longFundingRate,\r\n        int16 shortFundingRate\r\n        );\r\n\r\n    modifier onlyAdmin() {\r\n        require(administrators[msg.sender], \"admin only\");\r\n        _;\r\n    }\r\n\r\n    function removeAdmin(address toRemove)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        require(toRemove != msg.sender, \"You may not remove yourself as an admin.\");\r\n        administrators[toRemove] = false;\r\n    }\r\n\r\n    /** Grant administrator priviledges to a user\r\n    * @param newAdmin the address to promote\r\n    */\r\n    function addAdmin(address newAdmin)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        administrators[newAdmin] = true;\r\n    }\r\n\r\n    function adjustMinRM(uint16 _min)\r\n        external\r\n    {\r\n        require(books[msg.sender] != address(0), \"User must have a book\");\r\n        require(_min \u003e= 1);\r\n        Book b = Book(books[msg.sender]);\r\n        b.adjustMinRMBook(_min);\r\n    }\r\n\r\n    /** data are input in basis points as a percent of national\r\n    * thus 10 is 0.1% of notional, which when applied to the crypto\r\n    * with 2.5 leverage, generates a 0.25% of RM charge. funding rates\r\n    * can be negative, which implies the taker receives a payment.\r\n    */\r\n    function updateFees(uint newClose, int frLong, int frShort)\r\n        external\r\n    {\r\n        require(books[msg.sender] != address(0), \"User must have a book\");\r\n        /// data are input as basis points of notional, adjusted to bps of RM to simplify calculations\r\n        int longRate = frLong * leverageRatio / 1e2;\r\n        int shortRate = frShort * leverageRatio / 1e2;\r\n        uint closefee = newClose * uint(leverageRatio) / 1e2;\r\n        /// fees are capped to avoid predatory pricing that would potentially besmirch OracleSwap\u0027s reputation\r\n        require(closefee \u003c= 250);\r\n        require(longRate \u003c= 250 \u0026\u0026 longRate \u003e= -250);\r\n        require(shortRate \u003c= 250 \u0026\u0026 shortRate \u003e= -250);\r\n        Book b = Book(books[msg.sender]);\r\n        b.updateFeesBook(uint8(closefee), int16(longRate), int16(shortRate));\r\n        emit RatesUpdated(msg.sender, uint8(closefee), int16(longRate), int16(shortRate));\r\n    }\r\n\r\n    function changeFeeAddress(address payable newAddress)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        feeAddress = newAddress;\r\n    }\r\n\r\n    function balanceInput(address recipient)\r\n            external\r\n            payable\r\n    {\r\n        assetSwapBalance[recipient] += msg.value;\r\n    }\r\n\r\n    /** fees are in basis points of national, as in the case when updating the fees\r\n    * minimum RM is in ETH, so 4 would imply a minimum RM of 4 ETH\r\n    */\r\n    function createBook(uint16 _min, uint _closefee, int frLong, int frShort)\r\n        external\r\n        payable\r\n        returns (address newBook)\r\n    {\r\n        require(books[msg.sender] == address(0), \"User must not have a preexisting book\");\r\n        require(msg.value \u003e= uint(_min) * 10 ether, \"Must prep for book\");\r\n        require(_min \u003e= 1);\r\n        int16 longRate = int16(frLong * leverageRatio / 1e2);\r\n        int16 shortRate = int16(frShort * leverageRatio / 1e2);\r\n        uint8 closefee = uint8(_closefee * uint(leverageRatio) / 1e2);\r\n        require(longRate \u003c= 250 \u0026\u0026 longRate \u003e= -250);\r\n        require(shortRate \u003c= 250 \u0026\u0026 shortRate \u003e= -250);\r\n        require(closefee \u003c= 250);\r\n        books[msg.sender] = address(new Book(msg.sender, address(this), _min, closefee, longRate, shortRate));\r\n        Book b = Book(books[msg.sender]);\r\n        b.fundLPBook.value(msg.value)();\r\n        emit LPNewBook(msg.sender, books[msg.sender]);\r\n        return books[msg.sender];\r\n    }\r\n\r\n    function fundLP(address _lp)\r\n        external\r\n        payable\r\n    {\r\n        require(books[_lp] != address(0));\r\n        Book b = Book(books[_lp]);\r\n        b.fundLPBook.value(msg.value)();\r\n    }\r\n\r\n    function fundTaker(address _lp, bytes32 subkID)\r\n        external\r\n        payable\r\n        {\r\n        require(books[_lp] != address(0));\r\n        Book b = Book(books[_lp]);\r\n        b.fundTakerBook.value(msg.value)(subkID);\r\n    }\r\n\r\n    function burnTaker(address _lp, bytes32 subkID)\r\n        external\r\n        payable\r\n    {\r\n        require(books[_lp] != address(0));\r\n        Book b = Book(books[_lp]);\r\n        uint refund = b.burnTakerBook(subkID, msg.sender, msg.value);\r\n        emit BurnHist(_lp, subkID, msg.sender, now);\r\n        assetSwapBalance[msg.sender] += refund;\r\n    }\r\n\r\n    function burnLP()\r\n        external\r\n        payable\r\n    {\r\n        require(books[msg.sender] != address(0));\r\n        Book b = Book(books[msg.sender]);\r\n        uint refund = b.burnLPBook(msg.value);\r\n        bytes32 abcnull;\r\n        emit BurnHist(msg.sender, abcnull, msg.sender, now);\r\n        assetSwapBalance[msg.sender] += refund;\r\n    }\r\n\r\n    function cancel(address _lp, bytes32 subkID, bool closeNow)\r\n        external\r\n        payable\r\n    {\r\n        Book b = Book(books[_lp]);\r\n        uint8 priceDay = oracle.getStartDay();\r\n        uint8 endDay = 5;\r\n        if (closeNow)\r\n            endDay = priceDay;\r\n        b.cancelBook.value(msg.value)(lastOracleSettleTime, subkID, msg.sender, endDay);\r\n    }\r\n\r\n    function closeBook(address _lp)\r\n        external\r\n        payable\r\n    {\r\n        require(msg.sender == _lp);\r\n        require(books[_lp] != address(0));\r\n        Book b = Book(books[_lp]);\r\n        b.closeBookBook.value(msg.value)();\r\n    }\r\n\r\n    function redeem(address _lp, bytes32 subkID)\r\n        external\r\n    {\r\n        require(books[_lp] != address(0));\r\n        Book b = Book(books[_lp]);\r\n        b.redeemBook(subkID, msg.sender);\r\n        emit SubkTracker(_lp, msg.sender, subkID, false);\r\n    }\r\n\r\n    function settleParts(address _lp)\r\n        external\r\n        returns (bool isComplete)\r\n    {\r\n        require(books[_lp] != address(0));\r\n        Book b = Book(books[_lp]);\r\n        uint lastBookSettleTime = b.lastBookSettleTime();\r\n        require(now \u003e (lastOracleSettleTime + 24 hours));\r\n        require(lastOracleSettleTime \u003e lastBookSettleTime, \"one settle per week\");\r\n        uint settleNumb = b.settleNum();\r\n        if (settleNumb \u003c 1e4) {\r\n            b.settleExpiring(assetReturns[1]);\r\n        } else if (settleNumb \u003c 2e4) {\r\n            b.settleRolling(assetReturns[0][0]);\r\n        } else if (settleNumb \u003c 3e4) {\r\n            b.settleNew(assetReturns[0]);\r\n        } else if (settleNumb == 3e4) {\r\n            b.settleFinal();\r\n            isComplete = true;\r\n        }\r\n    }\r\n\r\n    function settleBatch(address _lp)\r\n        external\r\n    {\r\n        require(books[_lp] != address(0));\r\n        Book b = Book(books[_lp]);\r\n        uint lastBookSettleTime = b.lastBookSettleTime();\r\n        require(now \u003e (lastOracleSettleTime + 24 hours));\r\n        require(lastOracleSettleTime \u003e lastBookSettleTime, \"one settle per week\");\r\n        /// the 5x1 vector of returns in units of ether, where 0.6 is a +60% of RM payoff,\r\n        /// -0.6 is a -60% of RM payoff. The refer to initial price days to settlement day\r\n        b.settleExpiring(assetReturns[1]);\r\n        /// this is the settle to settle return\r\n        b.settleRolling(assetReturns[0][0]);\r\n        /// this is the return from the last settlement day to the price day\r\n        /// for regular closes, the price day == 5, so it is a settlement to settlement return\r\n        b.settleNew(assetReturns[0]);\r\n        b.settleFinal();\r\n    }\r\n\r\n    function take(address _lp, uint rm, bool isTakerLong)\r\n        external\r\n        payable\r\n        returns (bytes32 newsubkID)\r\n    {\r\n        rm = rm * 1 ether;\r\n        require(msg.value \u003e= 3 * rm / 2, \"Insuffient ETH for your RM\");\r\n        require(hourOfDay() != 16, \"Cannot take during 4 PM ET hour\");\r\n        uint takerLong;\r\n        if (isTakerLong)\r\n            takerLong = 1;\r\n        else\r\n            takerLong = 0;\r\n        /// starting price is taken from the oracle contract based on what the next price day is\r\n        uint8 priceDay = oracle.getStartDay();\r\n        Book book = Book(books[_lp]);\r\n        newsubkID = book.takeBook.value(msg.value)(msg.sender, rm, lastOracleSettleTime, priceDay, takerLong);\r\n        emit SubkTracker(_lp, msg.sender, newsubkID, true);\r\n    }\r\n\r\n    /** withdraw amounts are in finneys. Thus, 1234 is 1.234 ETH\r\n\r\n    */\r\n    function withdrawLP(uint amount)\r\n        external\r\n    {\r\n        require(amount \u003e 0);\r\n        require(books[msg.sender] != address(0));\r\n        Book b = Book(books[msg.sender]);\r\n        amount = 1 finney * amount;\r\n        b.withdrawLPBook(amount, lastOracleSettleTime);\r\n    }\r\n\r\n    function withdrawTaker(uint amount, address _lp, bytes32 subkID)\r\n        external\r\n    {\r\n        require(amount \u003e 0);\r\n        require(books[_lp] != address(0));\r\n        Book b = Book(books[_lp]);\r\n        amount = 1 finney * amount;\r\n        b.withdrawTakerBook(subkID, amount, lastOracleSettleTime, msg.sender);\r\n    }\r\n    /// one can withdraw from one\u0027s assetSwap balance at any time. It can only send the entire amount\r\n\r\n    function withdrawFromAssetSwap()\r\n        external\r\n    {\r\n        uint amount = assetSwapBalance[msg.sender];\r\n        require(amount \u003e 0);\r\n        assetSwapBalance[msg.sender] = 0;\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    function inactiveOracle(address _lp)\r\n        external\r\n    {\r\n        require(books[_lp] != address(0));\r\n        Book b = Book(books[_lp]);\r\n        b.inactiveOracleBook();\r\n    }\r\n\r\n    function inactiveLP(address _lp, bytes32 subkID)\r\n        external\r\n    {\r\n        require(books[_lp] != address(0));\r\n        Book b = Book(books[_lp]);\r\n        b.inactiveLPBook(subkID, msg.sender, lastOracleSettleTime);\r\n    }\r\n\r\n    function getBookData(address _lp)\r\n        external\r\n        view\r\n        returns (address book,\r\n            // balances in wei\r\n            uint lpMargin,\r\n            uint totalLpLong,\r\n            uint totalLpShort,\r\n            uint lpRM,\r\n            /// in ETH\r\n            uint bookMinimum,\r\n            /// in basis points as a percent of RM\r\n            /// to convert to notional, we multiply by the leverage ratio\r\n            int16 longFundingRate,\r\n            int16 shortFundingRate,\r\n            uint8 lpCloseFee,\r\n            /** 0 is fine, 1 means book cancels at next settlement\r\n            * 2 means LP burned (which cancels the book at next settlement)\r\n            * 3 book is inactive, no more settling or new positions\r\n            */\r\n            uint8 bookStatus\r\n            )\r\n    {\r\n        book = books[_lp];\r\n        if (book != address(0)) {\r\n            Book b = Book(book);\r\n            lpMargin = b.margin(0);\r\n            totalLpLong = b.margin(1);\r\n            totalLpShort = b.margin(2);\r\n            lpRM = b.margin(3);\r\n            bookMinimum = b.lpMinTakeRM();\r\n            longFundingRate = b.fundingRates(1);\r\n            shortFundingRate = b.fundingRates(0);\r\n            lpCloseFee = b.bookCloseFee();\r\n            bookStatus = b.bookStatus();\r\n        }\r\n    }\r\n\r\n    function getSubkData1(address _lp, bytes32 subkID)\r\n        external\r\n        view\r\n        returns (\r\n            address taker,\r\n            /// in wei\r\n            uint takerMargin,\r\n            uint reqMargin\r\n            )\r\n    {\r\n        address book = books[_lp];\r\n        if (book != address(0)) {\r\n            Book b = Book(book);\r\n            (taker, takerMargin, reqMargin) = b.getSubkData1Book(subkID);\r\n        }\r\n    }\r\n\r\n    function getSubkData2(address _lp, bytes32 subkID)\r\n        external\r\n        view\r\n        returns (\r\n          /** 0 new, 1 active and rolled over, 2 taker cancelled, 3 LP cancelled,\r\n          * 4 intraweek cancelled, 5 taker burned, 6 taker default/redeemable, 7 inactive/redeemable\r\n          */\r\n            uint8 subkStatus,\r\n          /// for new and expiring subcontracts, either the start or end price that week\r\n            uint8 priceDay,\r\n          /** the LP\u0027s closing fee, in basis points as a percent of the RM. The total closing fee\r\n          * is this plus 2.5% of RM, the oracle\u0027s fee\r\n          */\r\n            uint8 closeFee,\r\n          /// the funding rate paid by the taker, which may be negative\r\n            int16 fundingRate,\r\n          /// true for taker is long (and thus LP is short)\r\n            bool takerSide\r\n            )\r\n    {\r\n        address book = books[_lp];\r\n        if (book != address(0)) {\r\n            Book b = Book(book);\r\n            (subkStatus, priceDay, closeFee, fundingRate, takerSide)\r\n                = b.getSubkData2Book(subkID);\r\n        }\r\n    }\r\n\r\n    function getSettleInfo(address _lp)\r\n        external\r\n        view\r\n        returns (\r\n          /// total number of taker subcontracts, including new, rolled-over, cancelled, and inactive subcontracts\r\n            uint totalLength,\r\n          /// taker subcontracts that are expiring at next settlement\r\n            uint expiringLength,\r\n          /// taker subcontracts that have not yet settled. Such positions cannot be cancelled. The next week,\r\n          /// they will be \u0027active\u0027, and cancelable.\r\n            uint newLength,\r\n          /// time of last book settlement, in hours from 1970, Greenwich Mean Time\r\n            uint lastBookSettleUTC,\r\n          /// this is used for assessing the progress of a settlement when it is too large to be\r\n          /// executed in batch.\r\n            uint settleNumber,\r\n          /// amount of ETH in the LP book\r\n            uint bookBalance,\r\n          /// an LP can close they book en masse, which would push the maturity of the book to 28 days after\r\n          /// the close is instantiated. Takers should take note. A taker does not pay a cancel fee when\r\n          /// the LP cancels their book, but they must then wait until the final settlement\r\n            uint bookMaturityUTC\r\n            )\r\n    {\r\n        address book = books[_lp];\r\n        if (book != address(0)) {\r\n            Book b = Book(book);\r\n            (totalLength, expiringLength, newLength, lastBookSettleUTC, settleNumber,\r\n                bookBalance, bookMaturityUTC) = b.getSettleInfoBook();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * This gives the raw asset returns for all potential start and end dates: 5 different returns\r\n    * for new positions (price day to settlement day), and 5 for expiring positions (last settlement to price day)\r\n    * these are posted by the Oracle at the settlemnet price update.\r\n    * They are in % return * Leverage Ratio times 1 ETH,\r\n    * this allows the books to simply apply these numbers to the RM of the various subcontracts to generate the\r\n    * weekly PNL. They are capped at +/- 0.975e18, so that the extreme case of a maximum funding rate, the liability\r\n    * is never greater than 1 ETH. This effectively caps player liability at their RM\r\n    */\r\n    function updateReturns(int[5] memory assetRetNew, int[5] memory assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }\r\n\r\n    function hourOfDay()\r\n        public\r\n        view\r\n        returns(uint hour1)\r\n    {\r\n        uint nowTemp = now;\r\n    /**\r\n    * 2020 Summer, 1583668800 = March 8 2020 through 1604232000 = November 1 2020\r\n    * 2021 Summer, 1615705200 = March 14 2021 through 1636264800 = November 7 2021\r\n    * 2022 summer, 1647154800 = March 13 2022 through 1667714400 = November 6 2022\r\n    * summer is Daylight Savings Time in the US, where the hour is GMT - 5 in New York City\r\n    * winter is Standard Time in the US, where the hour is GMT - 4 in New York City\r\n    * No takes from 4-5 PM NYC time, so hour == 16 is the exclusion time\r\n    */\r\n        hour1 = (nowTemp % 86400) / 3600 - 5;\r\n        if ((nowTemp \u003e 1583668800 \u0026\u0026 nowTemp \u003c 1604232000) || (nowTemp \u003e 1615705200 \u0026\u0026 nowTemp \u003c 1636264800) ||\r\n            (nowTemp \u003e 1647154800 \u0026\u0026 nowTemp \u003c 1667714400))\r\n            hour1 = hour1 + 1;\r\n    }\r\n\r\n    function subzero(uint _a, uint _b)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        if (_b \u003e= _a) {\r\n            return 0;\r\n        }\r\n        return _a - _b;\r\n    }\r\n\r\n\r\n}\r\n"},"Book.sol":{"content":"pragma solidity 0.5.15;\r\n\r\nimport \"./AssetSwap.sol\";\r\n\r\n\r\ncontract Book {\r\n\r\n    constructor(address user, address admin, uint16 minReqMarg, uint8 closefee,\r\n        int16 frlong, int16 frshort)\r\n        public {\r\n            assetSwap = AssetSwap(admin);\r\n            lp = user;\r\n            lpMinTakeRM = minReqMarg;\r\n            lastBookSettleTime = now;\r\n            bookCloseFee = closefee;\r\n            fundingRates[0] = frshort;\r\n            fundingRates[1] = frlong;\r\n            endOfBookTime = now + 1100 days;\r\n        }\r\n\r\n    address public lp;\r\n    AssetSwap public assetSwap;\r\n    /// 0 is actual or total margin, 1 is sum of LP\u0027s short takers\r\n    /// 2 is sum of LP\u0027s long takers, 3 is the LP\u0027s required margin\r\n    /// units an in wei, and refer to the RM, not the notional\r\n    uint[4] public margin;\r\n    uint public lastBookSettleTime;\r\n    uint public burnFactor = 1 ether;\r\n    uint public settleNum;\r\n    int public lpSettleDebitAcct;\r\n    uint public endOfBookTime;\r\n    int16[2] public fundingRates;\r\n    uint16 public lpMinTakeRM;\r\n    uint8 public bookStatus;\r\n    uint8 public bookCloseFee;\r\n    bytes32[][2] public tempContracts;\r\n    bytes32[] public takerContracts;\r\n    mapping(bytes32 =\u003e Subcontract) public subcontracts;\r\n\r\n    struct Subcontract {\r\n        address taker;\r\n        uint takerMargin;   /// in wei\r\n        uint requiredMargin;     /// in wei\r\n        uint16 index;\r\n        int16 fundingRate;\r\n        uint8 closeFee;\r\n        uint8 subkStatus;\r\n        uint8 priceDay;\r\n        int8 takerSide; /// 1 if long, -1 if short\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == address(assetSwap));\r\n        _;\r\n    }\r\n\r\n    function adjustMinRMBook(uint16 _min)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        lpMinTakeRM = _min;\r\n    }\r\n\r\n    function updateFeesBook(uint8 newClose, int16 longrate, int16 shortrate)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        fundingRates[0] = shortrate;\r\n        fundingRates[1] = longrate;\r\n        bookCloseFee = newClose;\r\n    }\r\n\r\n    function burnTakerBook(bytes32 subkID, address sender, uint msgval)\r\n        external\r\n        onlyAdmin\r\n        returns (uint)\r\n    {\r\n        Subcontract storage k = subcontracts[subkID];\r\n        require(sender == k.taker, \"must by party to his subcontract\");\r\n        require(settleNum == 0, \"not during settlement process\");\r\n        require(k.subkStatus \u003c 5, \"can only burn active subcontract\");\r\n        uint burnFee = k.requiredMargin / 2;\r\n        require(msgval \u003e= burnFee, \"Insufficient burn fee\");\r\n        burnFee = subzero(msgval, burnFee);\r\n        if (margin[1] \u003e margin[2]) {\r\n            burnFactor = subzero(burnFactor, 1 ether * k.requiredMargin / margin[1]);\r\n        } else {\r\n            burnFactor = subzero(burnFactor, 1 ether * k.requiredMargin / margin[2]);\r\n        }\r\n        k.subkStatus = 5;\r\n        return burnFee;\r\n    }\r\n\r\n    function burnLPBook(uint msgval)\r\n        external\r\n        onlyAdmin\r\n        returns (uint)\r\n    {\r\n        require(bookStatus != 2, \"can only burn once\");\r\n        /// burn fee is 50% of RM\r\n        uint burnFee = margin[3] / 2;\r\n        require(msgval \u003e= burnFee, \"Insufficient burn fee\");\r\n        burnFee = subzero(msgval, burnFee);\r\n        /** The entire LP RM as a percent of the larger of the long or short\r\n        * side is used to decrement the credits of those at the upcoming settlement\r\n        */\r\n        if (margin[2] \u003e margin[1]) {\r\n            burnFactor = subzero(burnFactor, 1 ether * margin[3] / margin[2]);\r\n        } else {\r\n            burnFactor = subzero(burnFactor, 1 ether * margin[3] / margin[1]);\r\n        }\r\n        bookStatus = 2;\r\n        return burnFee;\r\n    }\r\n\r\n    function cancelBook(uint lastOracleSettle, bytes32 subkID, address sender, uint8 _endDay)\r\n        external\r\n        payable\r\n        onlyAdmin\r\n    {\r\n        Subcontract storage k = subcontracts[subkID];\r\n        require(lastOracleSettle \u003c lastBookSettleTime, \"Cannot do during settle period\");\r\n        require(sender == k.taker || sender == lp, \"Canceller not LP or taker\");\r\n        /// checks to see if subk already cancelled, as otherwise redundant\r\n        require(k.subkStatus == 1, \"redundant or too new\");\r\n        uint feeOracle = 250 * k.requiredMargin / 1e4;\r\n        require(msg.value \u003e= (2 * feeOracle), \"Insufficient cancel fee\");\r\n        uint feeLP = uint(k.closeFee) * k.requiredMargin / 1e4;\r\n        if (sender == k.taker \u0026\u0026 _endDay == 5) {\r\n            k.subkStatus = 2;  /// regular taker cancel\r\n        } else if (sender == k.taker) {\r\n            require(k.requiredMargin \u003c subzero(margin[0], margin[3]), \"Insuff LP RM for immed cancel\");\r\n            feeLP = feeOracle;  /// close fee is now max close fee, overriding initial close fee\r\n            k.subkStatus = 4;  /// immediate taker cancel\r\n            k.priceDay = _endDay;  /// this is the end-day of the subcontract\u0027s last week\r\n        } else {\r\n            feeOracle = 2 * feeOracle;\r\n            feeLP = subzero(msg.value, feeOracle); /// this is really a refund to the LP, not a fee\r\n            k.subkStatus = 3;  /// LP cancel\r\n        }\r\n        balanceSend(feeOracle, assetSwap.feeAddress());\r\n        tempContracts[1].push(subkID);  /// sets this up to settle as an expiring subcontract\r\n        margin[0] += feeLP;\r\n        k.takerMargin += subzero(msg.value, feeLP + feeOracle);\r\n    }\r\n\r\n    function fundLPBook()\r\n        external\r\n        onlyAdmin\r\n        payable\r\n    {\r\n        margin[0] += msg.value;\r\n    }\r\n\r\n    function fundTakerBook(bytes32 subkID)\r\n        external\r\n        onlyAdmin\r\n        payable\r\n    {\r\n        Subcontract storage k = subcontracts[subkID];\r\n        require(k.subkStatus \u003c 2);\r\n        k.takerMargin += msg.value;\r\n    }\r\n\r\n    function closeBookBook()\r\n        external\r\n        payable\r\n        onlyAdmin\r\n    { /// pays the close fee on the larger side of her book\r\n        uint feeOracle = 250 * (margin[1] + margin[2] - min(margin[1], margin[2])) / 1e4;\r\n        require(msg.value \u003e= feeOracle, \"Insufficient cancel fee\");\r\n        uint feeOverpay = msg.value - feeOracle;\r\n        balanceSend(feeOracle, assetSwap.feeAddress());\r\n        if (now \u003e endOfBookTime)\r\n        /// this means the next settlement ends this book\u0027s activity\r\n            bookStatus = 1;\r\n        else\r\n        /// if initial, needs to be run again in 28 days to complete the shut down\r\n            endOfBookTime = now + 28 days;\r\n        margin[0] += feeOverpay;\r\n    }\r\n\r\n    /**\r\n    *We only need look at when the last book settlement because\r\n    * if the LP was at fault, someone could have inactivatedthe LP\r\n    * and received a reward. Thus, the only scenario where a book\r\n    * can be active and the LP not inactivated, is when the oracle has been\r\n    * absent for a week\r\n    */\r\n    function inactiveOracleBook()\r\n        external\r\n        onlyAdmin\r\n        {\r\n        require(now \u003e (lastBookSettleTime + 10 days));\r\n        bookStatus = 3;\r\n    }\r\n\r\n    /** if the book was not settled, the LP is held accountable\r\n     * the first counterparty to execute this function will then get a bonus credit of their RM from  *the LP\r\n     * if the LP\u0027s total margin is zero, they will get whatever is there\r\n     * after the book is in default all players can redeem their subcontracts\r\n     * After a book is in default, this cannot be executed\r\n     */\r\n    function inactiveLPBook(bytes32 subkID, address sender, uint _lastOracleSettle)\r\n        external\r\n        onlyAdmin\r\n    {\r\n\r\n        require(bookStatus != 3);\r\n        Subcontract storage k = subcontracts[subkID];\r\n        require(k.taker == sender);\r\n        require(_lastOracleSettle \u003e lastBookSettleTime);\r\n        require(subzero(now, _lastOracleSettle) \u003e 48 hours);\r\n        uint lpDefFee = min(margin[0], margin[3] / 2);\r\n        margin[0] = subzero(margin[0], lpDefFee);\r\n        margin[3] = 0;\r\n        bookStatus = 3;\r\n        /// annoying, but at least someone good get the negligent LP\u0027s money\r\n        k.takerMargin += lpDefFee;\r\n    }\r\n\r\n    function redeemBook(bytes32 subkid, address sender)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        Subcontract storage k = subcontracts[subkid];\r\n        require(k.subkStatus \u003e 5 || bookStatus == 3);\r\n        /// redemption can happen if the subcontract has defaulted subkStatus = 6, is inactive subkStatus = 7\r\n        /// or if the book is inactive (bookStatus == 3)\r\n        uint tMargin = k.takerMargin;\r\n        k.takerMargin = 0;\r\n        uint16 index = k.index;\r\n        /// iff the taker defaulted on an active book, they are penalized by\r\n        /// burning RM/2 of their margin\r\n        bool isDefaulted = (k.subkStatus == 6 \u0026\u0026 bookStatus == 0);\r\n        uint defPay = k.requiredMargin / 2;\r\n        uint lpPayment;\r\n        address tAddress = k.taker;\r\n        /// this pays the lp for the gas and effort of redeeming for the taker\r\n        /// it\u0027s just 2 finney. The investor should now see their margin in the\r\n        /// assetSwapBalance, and withdraw from there\r\n        if (sender == lp) {\r\n            lpPayment = tMargin - subzero(tMargin, 2 finney);\r\n            tMargin -= lpPayment;\r\n            margin[0] += lpPayment;\r\n        }\r\n        /** we have to pop the takerLong/Short lists to free up space\r\n        * this involves this little trick, moving the last row to the row we are\r\n        * redeeming and writing it over the redeemed subcontract\r\n        * then we remove the duplicate.\r\n        */\r\n        Subcontract storage lastTaker = subcontracts[takerContracts[takerContracts.length - 1]];\r\n        lastTaker.index = index;\r\n        takerContracts[index] = takerContracts[takerContracts.length - 1];\r\n        takerContracts.pop();\r\n        delete subcontracts[subkid];\r\n        // we only take what is there. It goes to the oracle, so if he\u0027s a cheater, you can punish\r\n        /// him more by withholding this payment as well as the fraudulent PNL. If he\u0027s not a cheater\r\n        /// then you are just negligent for defaulting and probably were not paying attention, as\r\n        /// you should have know you couldn\u0027t cure your margin Friday afternoon before close.\r\n        if (isDefaulted) {\r\n            tMargin = subzero(tMargin, defPay);\r\n            balanceSend(defPay, assetSwap.feeAddress());\r\n        }\r\n        /// money is sent to AssetSwapContract\r\n        balanceSend(tMargin, tAddress);\r\n\r\n    }\r\n\r\n    /** Settle the rolled over taker sukcontracts\r\n    * @param assetRet the returns for a long contract for a taker for only one\r\n    * start day, as they are all starting on the prior settlement price\r\n    */\r\n    function settleRolling(int assetRet)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        require(settleNum \u003c 2e4, \"done with rolling settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// the first settlement function set the settleNum = 1e4, so that is subtracted to\r\n        /// see where we are in the total number of takers in the LP\u0027s book\r\n        uint loopCap = min(settleNum - 1e4 + 250, takerContracts.length);\r\n        for (uint i = (settleNum - 1e4); i \u003c loopCap; i++) {\r\n            Subcontract storage k = subcontracts[takerContracts[i]];\r\n            if (k.subkStatus == 1) {\r\n                takerRetTemp = int(k.takerSide) * assetRet * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp \u003c 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin \u003c k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n            }\r\n        }\r\n        settleNum += 250;\r\n        if ((settleNum - 1e4) \u003e= takerContracts.length)\r\n            settleNum = 2e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }\r\n\r\n    /// this is the fourth and the final of the settlement functions\r\n    function settleFinal()\r\n        external\r\n        onlyAdmin\r\n    {\r\n        require(settleNum == 3e4, \"not done with all the subcontracts\");\r\n        /// this take absolute value of (long - short) to update the LP\u0027s RM\r\n        if (margin[2] \u003e margin[1])\r\n            margin[3] = margin[2] - margin[1];\r\n        else\r\n            margin[3] = margin[1] - margin[2];\r\n        if (lpSettleDebitAcct \u003c 0)\r\n            margin[0] = subzero(margin[0], uint(-lpSettleDebitAcct));\r\n        else\r\n        /// if the lpSettleDebitAcct is positive, we add it, but first apply the burnFactor\r\n        /// to remove the burner\u0027s pnl in a pro-rata way\r\n            margin[0] = margin[0] + uint(lpSettleDebitAcct) * burnFactor / 1 ether;\r\n        if (bookStatus != 0) {\r\n            bookStatus = 3;\r\n            margin[3] = 0;\r\n        } else if (margin[0] \u003c margin[3]) {\r\n            // default scenario for LP\r\n            bookStatus = 3;\r\n            uint defPay = min(margin[0], margin[3] / 2);\r\n            margin[0] = subzero(margin[0], defPay);\r\n            balanceSend(defPay, assetSwap.feeAddress());\r\n            margin[3] = 0;\r\n        }\r\n        // resets for our next book settlement\r\n        lpSettleDebitAcct = 0;\r\n        lastBookSettleTime = now;\r\n        settleNum = 0;\r\n        delete tempContracts[1];\r\n        delete tempContracts[0];\r\n        burnFactor = 1 ether;\r\n    }\r\n\r\n    /** Create a new Taker long subcontract of the given parameters\r\n    * @param taker the address of the party on the other side of the contract\r\n    * @param rM the ETH amount in the required margin\r\n    * isTakerLong is +1 if taker is long, 0 if taker is short\r\n    * @return subkID the id of the newly created subcontract\r\n    */\r\n    function takeBook(address taker, uint rM, uint lastOracleSettle, uint8 _priceDay, uint isTakerLong)\r\n        external\r\n        payable\r\n        onlyAdmin\r\n        returns (bytes32 subkID)\r\n    {\r\n        require(bookStatus == 0, \"book is no longer taking positions\");\r\n        require((now + 28 days) \u003c endOfBookTime, \"book closing soon\");\r\n        require(rM \u003e= uint(lpMinTakeRM) * 1 ether, \"must be greater than book min\");\r\n        require(lastOracleSettle \u003c lastBookSettleTime, \"Cannot do during settle period\");\r\n        uint availableMargin = subzero(margin[0] / 2 + margin[2 - isTakerLong], margin[1 + isTakerLong]);\r\n        require(rM \u003c= availableMargin \u0026\u0026 (margin[0] - margin[3]) \u003e rM);\r\n        require(rM \u003c= availableMargin);\r\n        margin[1 + isTakerLong] += rM;\r\n        Subcontract memory order;\r\n        order.requiredMargin = rM;\r\n        order.takerMargin = msg.value;\r\n        order.taker = taker;\r\n        order.takerSide = int8(2 * isTakerLong - 1);\r\n        margin[3] += rM;\r\n        subkID = keccak256(abi.encodePacked(now, takerContracts.length));\r\n        order.index = uint16(takerContracts.length);\r\n        order.priceDay = _priceDay;\r\n        order.fundingRate = fundingRates[isTakerLong];\r\n        order.closeFee = bookCloseFee;\r\n        subcontracts[subkID] = order;\r\n        takerContracts.push(subkID);\r\n        tempContracts[0].push(subkID);\r\n        return subkID;\r\n    }\r\n\r\n    /** Withdrawing margin\r\n    * reverts if during the settle period, oracleSettleTime \u003e book settle time\r\n    * also must leave total margin greater than the required margin\r\n    */\r\n    function withdrawLPBook(uint amount, uint lastOracleSettle)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        require(margin[0] \u003e= amount, \"Cannot withdraw more than the margin\");\r\n         // if book is dead LP can take everything left, if not dead, can only take up to RM\r\n        if (bookStatus != 3) {\r\n            require(subzero(margin[0], amount) \u003e= margin[3], \"Cannot w/d more than excess margin\");\r\n            require(lastOracleSettle \u003c lastBookSettleTime, \"Cannot w/d during settle period\");\r\n        }\r\n        margin[0] = subzero(margin[0], amount);\r\n        balanceSend(amount, lp);\r\n    }\r\n\r\n    function withdrawTakerBook(bytes32 subkID, uint amount, uint lastOracleSettle, address sender)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        require(lastOracleSettle \u003c lastBookSettleTime, \"Cannot w/d during settle period\");\r\n        Subcontract storage k = subcontracts[subkID];\r\n        require(k.subkStatus \u003c 6, \"subk dead, must redeem\");\r\n        require(sender == k.taker, \"Must be taker to call this function\");\r\n        require(subzero(k.takerMargin, amount) \u003e= k.requiredMargin, \"cannot w/d more than excess margin\");\r\n        k.takerMargin = subzero(k.takerMargin, amount);\r\n        balanceSend(amount, k.taker);\r\n    }\r\n\r\n    function getSubkData1Book(bytes32 subkID)\r\n        external\r\n        view\r\n        returns (address takerAddress, uint takerMargin, uint requiredMargin)\r\n    {   Subcontract memory k = subcontracts[subkID];\r\n        takerAddress = k.taker;\r\n        takerMargin = k.takerMargin;\r\n        requiredMargin = k.requiredMargin;\r\n    }\r\n\r\n    function getSubkData2Book(bytes32 subkID)\r\n        external\r\n        view\r\n        returns (uint8 kStatus, uint8 priceDay, uint8 closeFee, int16 fundingRate, bool takerSide)\r\n    {   Subcontract memory k = subcontracts[subkID];\r\n        kStatus = k.subkStatus;\r\n        priceDay = k.priceDay;\r\n        closeFee = k.closeFee;\r\n        fundingRate = k.fundingRate;\r\n        if (k.takerSide == 1)\r\n            takerSide = true;\r\n    }\r\n\r\n    function getSettleInfoBook()\r\n        external\r\n        view\r\n        returns (uint totalLength, uint expiringLength, uint newLength, uint lastBookSettleUTC, uint settleNumber,\r\n            uint bookBalance, uint bookMaturityUTC)\r\n    {\r\n        totalLength = takerContracts.length;\r\n        expiringLength = tempContracts[1].length;\r\n        newLength = tempContracts[0].length;\r\n        lastBookSettleUTC = lastBookSettleTime;\r\n        settleNumber = settleNum;\r\n        bookMaturityUTC = endOfBookTime;\r\n        bookBalance = address(this).balance;\r\n    }\r\n\r\n    /** Settle the taker long sukcontracts\r\n    * priceDay Expiring returns use the return from the last settle to the priceDay, which\r\n    * for regular cancels is just 5, the most recent settlement price\r\n    * this is the first of 4 settlement functions\r\n    * */\r\n    function settleExpiring(int[5] memory assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 \u0026\u0026 settleNum \u003c 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i \u003c loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp \u003c 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum \u003e= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }\r\n\r\n    /// this is the third of the settlement functions\r\n    function settleNew(int[5] memory assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum \u003c 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i \u003c loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to \u0027active\u0027 which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp \u003c 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin \u003c k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum \u003e= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }\r\n\r\n    /// Function to send balances back to the Assetswap contract\r\n    function balanceSend(uint amount, address recipient)\r\n        internal\r\n    {\r\n        assetSwap.balanceInput.value(amount)(recipient);\r\n    }\r\n\r\n    /** Utility function to find the minimum of two unsigned values\r\n    * @notice returns the first parameter if they are equal\r\n    */\r\n    function min(uint a, uint b)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        if (a \u003c= b)\r\n            return a;\r\n        else\r\n            return b;\r\n    }\r\n\r\n    function subzero(uint _a, uint _b)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        if (_b \u003e= _a)\r\n            return 0;\r\n        else\r\n            return _a - _b;\r\n    }\r\n\r\n\r\n}\r\n"},"Oracle.sol":{"content":"pragma solidity 0.5.15;\r\n\r\nimport \"./AssetSwap.sol\";\r\n\r\n\r\ncontract Oracle {\r\n\r\n    constructor (uint ethPrice, uint spxPrice, uint btcPrice) public {\r\n        admins[msg.sender] = true;\r\n        prices[0][5] = ethPrice;\r\n        prices[1][5] = spxPrice;\r\n        prices[2][5] = btcPrice;\r\n        lastUpdateTime = now;\r\n        lastSettleTime = now;\r\n        currentDay = 5;\r\n        levRatio[0] = 250;  // ETH contract 2.5 leverage\r\n        levRatio[1] = 1000; /// SPX contract 10.0 leverage\r\n        levRatio[2] = 250;  // BTC contract 2.5 leverage\r\n    }\r\n\r\n    address[3] public assetSwaps;\r\n    uint[6][3] private prices;\r\n    uint public lastUpdateTime;\r\n    uint public lastSettleTime;\r\n    int[3] public levRatio;\r\n    uint8 public currentDay;\r\n    bool public nextUpdateSettle;\r\n    mapping(address =\u003e bool) public admins;\r\n    mapping(address =\u003e bool) public readers;\r\n\r\n    event PriceUpdated(\r\n        uint ethPrice,\r\n        uint spxPrice,\r\n        uint btcPrice,\r\n        uint eUTCTime,\r\n        uint eDayNumber,\r\n        bool eisCorrection\r\n    );\r\n\r\n    modifier onlyAdmin() {\r\n        require(admins[msg.sender]);\r\n        _;\r\n    }\r\n    /** Grant write priviledges to a user,\r\n    * mainly intended for when the admin wants to switch accounts, ie, paired with a removal\r\n    */\r\n\r\n    function addAdmin(address newAdmin)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        admins[newAdmin] = true;\r\n    }\r\n\r\n    /** Grant priviledges to a user accessing price data on the blockchain\r\n    * @param newReader the address. Any reader is thus approved by the oracle/admin\r\n    * useful for new contracts that use this oracle, in that the oracle would not\r\n    * need to create a new oracle contract for ETH prices\r\n    */\r\n    function addReaders(address newReader)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        readers[newReader] = true;\r\n    }\r\n    /** this can only be done once, so this oracle is solely for working with\r\n    * three AssetSwap contracts\r\n    * assetswap 0 is the ETH, at 2.5 leverage\r\n    * assetswap 1 is the SPX, at 10x leverage\r\n    * assetswap 2 is the BTC, at 2.5 leverage\r\n    */\r\n\r\n    function addAssetSwaps(address newAS0, address newAS1, address newAS2)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        require(assetSwaps[0] == address(0));\r\n        assetSwaps[0] = newAS0;\r\n        assetSwaps[1] = newAS1;\r\n        assetSwaps[2] = newAS2;\r\n        readers[newAS0] = true;\r\n        readers[newAS1] = true;\r\n        readers[newAS2] = true;\r\n    }\r\n\r\n    function removeAdmin(address toRemove)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        require(toRemove != msg.sender);\r\n        admins[toRemove] = false;\r\n    }\r\n    /** Quickly fix an erroneous price, or correct the fact that 50% movements are\r\n    * not allowed in the standard price input\r\n    * this must be called within 60 minutes of the initial price update occurence\r\n    */\r\n\r\n    function editPrice(uint _ethprice, uint _spxprice, uint _btcprice)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        require(now \u003c lastUpdateTime + 60 minutes);\r\n        prices[0][currentDay] = _ethprice;\r\n        prices[1][currentDay] = _spxprice;\r\n        prices[2][currentDay] = _btcprice;\r\n        emit PriceUpdated(_ethprice, _spxprice, _btcprice, now, currentDay, true);\r\n    }\r\n\r\n    function updatePrices(uint ethp, uint spxp, uint btcp, bool _newFinalDay)\r\n        external\r\n        onlyAdmin\r\n    {\r\n\r\n             /// no updates within 20 hours per day\r\n        require(now \u003e lastUpdateTime + 20 hours);\r\n            /** can\u0027t be executed if the next price should be a settlement price\r\n            * settlement prices are special because they need to update the asset returns\r\n            * and sent to the AssetSwap contracts\r\n            */\r\n        require(!nextUpdateSettle);\r\n         /// after settlement update, at least 48 hours until new prices are posted\r\n        require(now \u003e lastSettleTime + 48 hours, \"too soon after last settle\");\r\n          /// prevents faulty prices, as stale prices are a common source of bad prices.\r\n        require(ethp != prices[0][currentDay] \u0026\u0026 spxp != prices[1][currentDay] \u0026\u0026 btcp != prices[2][currentDay]);\r\n            /// extreme price movements are probably mistakes. They can be posted\r\n          /// but only via a \u0027price edit\u0027 that must be done within 60 minutes of the initial update\r\n        require((ethp * 10 \u003c prices[0][currentDay] * 15) \u0026\u0026 (ethp * 10 \u003e prices[0][currentDay] * 5));\r\n        require((spxp * 10 \u003c prices[1][currentDay] * 15) \u0026\u0026 (spxp * 10 \u003e prices[1][currentDay] * 5));\r\n        require((btcp * 10 \u003c prices[2][currentDay] * 15) \u0026\u0026 (btcp * 10 \u003e prices[2][currentDay] * 5));\r\n        if (currentDay == 5) {\r\n            currentDay = 1;\r\n            nextUpdateSettle = false;\r\n        } else {\r\n            currentDay += 1;\r\n            nextUpdateSettle = _newFinalDay;\r\n        }\r\n        if (currentDay == 4)\r\n            nextUpdateSettle = true;\r\n        updatePriceSingle(0, ethp);\r\n        updatePriceSingle(1, spxp);\r\n        updatePriceSingle(2, btcp);\r\n        emit PriceUpdated(ethp, spxp, btcp, now, currentDay, false);\r\n        lastUpdateTime = now;\r\n    }\r\n\r\n    function settlePrice(uint ethp, uint spxp, uint btcp)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        require(nextUpdateSettle);\r\n        require(now \u003e lastUpdateTime + 20 hours);\r\n        require(ethp != prices[0][currentDay] \u0026\u0026 spxp != prices[1][currentDay] \u0026\u0026 btcp != prices[2][currentDay]);\r\n        require((ethp * 10 \u003c prices[0][currentDay] * 15) \u0026\u0026 (ethp * 10 \u003e prices[0][currentDay] * 5));\r\n        require((spxp * 10 \u003c prices[1][currentDay] * 15) \u0026\u0026 (spxp * 10 \u003e prices[1][currentDay] * 5));\r\n        require((btcp * 10 \u003c prices[2][currentDay] * 15) \u0026\u0026 (btcp * 10 \u003e prices[2][currentDay] * 5));\r\n        currentDay = 5;\r\n        nextUpdateSettle = false;\r\n        updatePriceSingle(0, ethp);\r\n        updatePriceSingle(1, spxp);\r\n        updatePriceSingle(2, btcp);\r\n        int[5] memory assetReturnsNew;\r\n        int[5] memory assetReturnsExpiring;\r\n        int cap = 975 * 1 ether / 1000;\r\n        for (uint j = 0; j \u003c 3; j++) {\r\n                  /**  asset return from start day j to settle day (ie, day 5),\r\n                  * and also the prior settle day (day 0) to the end day.\r\n                  * returns are normalized from 0.975 ether to - 0.975 ether\r\n                  * where 0.9 ether is a 90% RM profit for the long taker,\r\n                  * 0.2 ether means a 20% of RM profit for the long taker.\r\n                  */\r\n            for (uint i = 0; i \u003c 5; i++) {\r\n                if (prices[0][i] != 0) {\r\n                    int assetRetFwd = int(prices[j][5] * 1 ether / prices[j][i]) - 1 ether;\r\n                    assetReturnsNew[i] = assetRetFwd * int(prices[0][i]) * levRatio[j] /\r\n                        int(prices[0][5]) / 100;\r\n                /** as funding rates are maxed out at 2.5% of RM, the return must\r\n                * max out at 97.5% of RM so that required margins cover all\r\n                * potential payment scenarios\r\n                */\r\n                    assetReturnsNew[i] = bound(assetReturnsNew[i], cap);\r\n                }\r\n                if (prices[0][i+1] != 0) {\r\n                    int assetRetBack = int(prices[j][i+1] * 1 ether / prices[j][0]) - 1 ether;\r\n                    assetReturnsExpiring[i] = assetRetBack * int(prices[0][0]) * levRatio[j] /\r\n                        int(prices[0][i+1]) / 100;\r\n\r\n                    assetReturnsExpiring[i] = bound(assetReturnsExpiring[i], cap);\r\n                }\r\n            }\r\n    /// this updates the AssetSwap contract with the vector of returns,\r\n    /// one for each day of the week\r\n            AssetSwap asw = AssetSwap(assetSwaps[j]);\r\n            asw.updateReturns(assetReturnsNew, assetReturnsExpiring);\r\n        }\r\n        lastSettleTime = now;\r\n        emit PriceUpdated(ethp, spxp, btcp, now, currentDay, false);\r\n        lastUpdateTime = now;\r\n    }\r\n    /** Return the entire current price array for a given asset\r\n    * @param _assetID the asset id of the desired asset\r\n    * @return _priceHist the price array in USD for the asset\r\n    * @dev only the admin and addresses granted readership may call this function\r\n    * While only an admin or reader can access this within the EVM\r\n    * anyone can access these prices outside the EVM\r\n    * eg, in javascript: OracleAddress.methods.getUsdPrices.cacheCall(0, { \u0027from\u0027: \u0027AdminAddress\u0027 }\r\n    */\r\n\r\n    function getUsdPrices(uint _assetID)\r\n        public\r\n        view\r\n        returns (uint[6] memory _priceHist)\r\n    {\r\n        require(admins[msg.sender] || readers[msg.sender]);\r\n        _priceHist = prices[_assetID];\r\n    }\r\n\r\n        /** Return only the latest prices\r\n        * @param _assetID the asset id of the desired asset\r\n        * @return _price the latest price of the given asset\r\n        * @dev only the admin or a designated reader may call this function within the EVM\r\n        */\r\n    function getCurrentPrice(uint _assetID)\r\n        public\r\n        view\r\n        returns (uint _price)\r\n    {\r\n        require(admins[msg.sender] || readers[msg.sender]);\r\n        _price = prices[_assetID][currentDay];\r\n    }\r\n\r\n    /**\r\n    * @return startDay relevant for trades done now\r\n    * pulls the day relevant for new AssetSwap subcontracts\r\n    * startDay 2 means the 2 slot (ie, the third) of prices will be the initial\r\n    * price for the subcontract. As 5 is the top slot, and rolls into slot 0\r\n    * the next week, the next pricing day is 1 when the current day == 5\r\n    * (this would be a weekend or Monday morning)\r\n    */\r\n    function getStartDay()\r\n        public\r\n        view\r\n        returns (uint8 _startDay)\r\n    {\r\n        if (nextUpdateSettle) {\r\n            _startDay = 5;\r\n        } else if (currentDay == 5) {\r\n            _startDay = 1;\r\n        } else {\r\n            _startDay = currentDay + 1;\r\n        }\r\n    }\r\n\r\n    function updatePriceSingle(uint _assetID, uint _price)\r\n        internal\r\n    {\r\n        if (currentDay == 1) {\r\n            uint[6] memory newPrices;\r\n            newPrices[0] = prices[_assetID][5];\r\n            newPrices[1] = _price;\r\n            prices[_assetID] = newPrices;\r\n        } else {\r\n            prices[_assetID][currentDay] = _price;\r\n        }\r\n    }\r\n\r\n    function bound(int a, int b)\r\n        internal\r\n        pure\r\n        returns (int)\r\n    {\r\n        if (a \u003e b)\r\n            a = b;\r\n        if (a \u003c -b)\r\n            a = -b;\r\n        return a;\r\n    }\r\n\r\n}\r\n"}}