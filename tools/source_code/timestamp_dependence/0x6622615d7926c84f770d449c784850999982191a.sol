{"BondService.sol":{"content":"pragma solidity 0.4.25;\n\nimport \"./SafeMath.sol\";\nimport \"./IToken.sol\";\nimport \"./ISettings.sol\";\nimport \"./ITBoxManager.sol\";\nimport \"./IOracle.sol\";\n\n\n/// @title BondService\ncontract BondService {\n    using SafeMath for uint256;\n\n    /// @notice The address of the admin account.\n    address public admin;\n\n    // The amount of Ether received from the commissions of the system.\n    uint256 private systemETH;\n\n    // Commission percentage charged from the issuer\n    uint256 public issuerFee;\n\n    // Commission percentage charged from the holder\n    uint256 public holderFee;\n\n    // The percentage divider\n    uint256 public divider = 100000;\n\n    // The minimum deposit amount\n    uint256 public minEther;\n\n    // The settings contract address\n    ISettings public settings;\n\n    /// @dev An array containing the Bond struct for all Bonds in existence. The ID\n    ///  of each Bond is actually an index into this array.\n    Bond[] public bonds;\n\n    /// @dev The main Bond struct. Every Bond is represented by a copy\n    ///  of this structure.\n    struct Bond {\n        // The address of the issuer of the Bond\n        address issuer;\n        // The address of the holder of the Bond\n        address         holder;\n        // The Ether amount packed in the Bond\n        uint256         deposit;\n        // The collateral percentage\n        uint256         percent;\n        // The number of TMV tokens withdrawn to holder\n        uint256         tmv;\n        // The expiration time in seconds\n        uint256         expiration;\n        // The percentage of the holder commission fee\n        uint256         yearFee;\n        // The percentage of the system commission fee\n        uint256         sysFee;\n        // The TBox ID created inside the Bond\n        uint256         tBoxId;\n        // The timestamp of the Bond creation\n        // Sets at the matching moment\n        uint256         createdAt;\n    }\n\n\n    /// @dev The BondCreated event is fired whenever a new Bond comes into existence.\n    event BondCreated(uint256 id, address who, uint256 deposit, uint256 percent, uint256 expiration, uint256 yearFee);\n\n    /// @dev The BondChanged event is fired whenever a Bond changing.\n    event BondChanged(uint256 id, uint256 deposit, uint256 percent, uint256 expiration, uint256 yearFee, address who);\n\n    /// @dev The BondClosed event is fired whenever a Bond is closed.\n    event BondClosed(uint256 id, address who);\n\n    /// @dev The BondMatched event is fired whenever a Bond is matched.\n    event BondMatched(uint256 id, address who, uint256 tBox, uint256 tmv, uint256 sysFee, address counteragent);\n\n    /// @dev The BondFinished event is fired whenever a Bond is finished.\n    event BondFinished(uint256 id, address issuer, address holder);\n\n    /// @dev The BondExpired event is fired whenever a Bond is expired.\n    event BondExpired(uint256 id, address issuer, address holder);\n\n    event BondHolderFeeUpdated(uint256 _value);\n    event BondIssuerFeeUpdated(uint256 _value);\n    event BondMinEtherUpdated(uint256 _value);\n    event IssuerRightsTransferred(address indexed from, address indexed to, uint indexed id);\n    event HolderRightsTransferred(address indexed from, address indexed to, uint indexed id);\n\n    /// @dev Defends against front-running attacks.\n    modifier validTx() {\n        require(tx.gasprice \u003c= settings.gasPriceLimit(), \"Gas price is greater than allowed\");\n        _;\n    }\n\n    /// @dev Access modifier for admin-only functionality.\n    modifier onlyAdmin() {\n        require(admin == msg.sender, \"You have no access\");\n        _;\n    }\n\n    /// @dev Access modifier for issuer-only functionality.\n    /// @param _id A Bond ID.\n    modifier onlyIssuer(uint256 _id) {\n        require(bonds[_id].issuer == msg.sender, \"You are not the issuer\");\n        _;\n    }\n\n    /// @dev Access modifier for holder-only functionality.\n    /// @param _id A Bond ID.\n    modifier onlyHolder(uint256 _id) {\n        require(bonds[_id].holder == msg.sender, \"You are not the holder\");\n        _;\n    }\n\n    /// @dev Access modifier for single-owner-only functionality.\n    /// @param _id A Bond ID.\n    modifier singleOwner(uint256 _id) {\n        bool _a = bonds[_id].issuer == msg.sender \u0026\u0026 bonds[_id].holder == address(0);\n        bool _b = bonds[_id].holder == msg.sender \u0026\u0026 bonds[_id].issuer == address(0);\n        require(_a || _b, \"You are not the single owner\");\n        _;\n    }\n\n    /// @dev Modifier to allow actions only when the bond is issuer\u0027s request\n    /// @param _id A Bond ID.\n    modifier issueRequest(uint256 _id) {\n        require(bonds[_id].issuer != address(0) \u0026\u0026 bonds[_id].holder == address(0), \"The bond isn\u0027t an emit request\");\n        _;\n    }\n\n    /// @dev Modifier to allow actions only when the bond is holder\u0027s request\n    /// @param _id A Bond ID.\n    modifier buyRequest(uint256 _id) {\n        require(bonds[_id].holder != address(0) \u0026\u0026 bonds[_id].issuer == address(0), \"The bond isn\u0027t a buy request\");\n        _;\n    }\n\n    /// @dev Modifier to allow actions only when the bond is matched\n    /// @param _id A Bond ID.\n    modifier matched(uint256 _id) {\n        require(bonds[_id].issuer != address(0) \u0026\u0026 bonds[_id].holder != address(0), \"Bond isn\u0027t matched\");\n        _;\n    }\n\n    /// @notice Settings address can\u0027t be changed later.\n    /// @dev The contract constructor sets the original `admin` of the contract to the sender\n    //   account and sets the settings contract with provided address.\n    /// @param _settings The address of the settings contract.\n    constructor(ISettings _settings) public {\n        admin = msg.sender;\n        settings = _settings;\n\n        issuerFee = 500; // 0.5%\n        emit BondIssuerFeeUpdated(issuerFee);\n\n        holderFee = 10000; // 10%\n        emit BondHolderFeeUpdated(holderFee);\n\n        minEther = 0.1 ether;\n        emit BondMinEtherUpdated(minEther);\n    }\n\n    /// @dev Creates issuer request.\n    /// @param _percent The collateral percentage.\n    /// @param _expiration The expiration in seconds.\n    /// @param _yearFee The percentage of the commission.\n    /// @return New Bond ID.\n    function leverage(uint256 _percent, uint256 _expiration, uint256 _yearFee) public payable returns (uint256) {\n        require(msg.value \u003e= minEther, \"Too small funds\");\n        require(_percent \u003e= ITBoxManager(settings.tBoxManager()).withdrawPercent(msg.value), \"Collateralization is not enough\");\n        require(_expiration \u003e= 1 days \u0026\u0026 _expiration \u003c= 365 days, \"Expiration out of range\");\n        require(_yearFee \u003c= 25000, \"Fee out of range\");\n\n        return createBond(msg.sender, address(0), _percent, _expiration, _yearFee);\n    }\n\n    /// @dev Creates holder request.\n    /// @param _expiration The expiration in seconds.\n    /// @param _yearFee The percentage of the commission.\n    /// @return New Bond ID.\n    function exchange(uint256 _expiration, uint256 _yearFee) public payable returns (uint256) {\n        require(msg.value \u003e= minEther, \"Too small funds\");\n        require(_expiration \u003e= 1 days \u0026\u0026 _expiration \u003c= 365 days, \"Expiration out of range\");\n        require(_yearFee \u003c= 25000, \"Fee out of range\");\n\n        return createBond(address(0), msg.sender, 0, _expiration, _yearFee);\n    }\n\n    /// @dev Creates Bond request.\n    /// @param _issuer The address of the issuer.\n    /// @param _holder The address of the holder.\n    /// @param _percent The collateral percentage.\n    /// @param _expiration The expiration in seconds.\n    /// @param _yearFee The percentage of the commission.\n    /// @return New Bond ID.\n    function createBond(\n        address _issuer,\n        address _holder,\n        uint256 _percent,\n        uint256 _expiration,\n        uint256 _yearFee\n    )\n    internal\n    returns(uint256)\n    {\n        Bond memory _bond = Bond(\n            _issuer,\n            _holder,\n            msg.value,\n            _percent,\n            0,\n            _expiration,\n            _yearFee,\n            0,\n            0,\n            0\n        );\n        uint256 _id = bonds.push(_bond).sub(1);\n        emit BondCreated(_id, msg.sender, msg.value, _percent, _expiration, _yearFee);\n        return _id;\n    }\n\n    /// @dev Closes the bond.\n    /// @param _id A Bond ID.\n    function close(uint256 _id) external singleOwner(_id) {\n        uint256 _eth = bonds[_id].deposit;\n        delete bonds[_id];\n        msg.sender.transfer(_eth);\n        emit BondClosed(_id, msg.sender);\n    }\n\n    /// @dev Changes the issuer request.\n    /// @param _id A Bond ID.\n    /// @param _deposit The collateral amount.\n    /// @param _percent The collateral percentage.\n    /// @param _expiration The expiration in seconds.\n    /// @param _yearFee The percentage of the commission.\n    function issuerChange(uint256 _id, uint256 _deposit, uint256 _percent, uint256 _expiration, uint256 _yearFee)\n        external\n        payable\n        singleOwner(_id)\n        onlyIssuer(_id)\n    {\n        changeDeposit(_id, _deposit);\n        changePercent(_id, _percent);\n        changeExpiration(_id, _expiration);\n        changeYearFee(_id, _yearFee);\n\n        emit BondChanged(_id, _deposit, _percent, _expiration, _yearFee, msg.sender);\n    }\n\n    /// @dev Changes the holder request.\n    /// @param _id A Bond ID.\n    /// @param _deposit The collateral amount.\n    /// @param _expiration The expiration in seconds.\n    /// @param _yearFee The percentage of the commission.\n    function holderChange(uint256 _id, uint256 _deposit, uint256 _expiration, uint256 _yearFee)\n        external\n        payable\n    {\n        require(bonds[_id].holder == msg.sender \u0026\u0026 bonds[_id].issuer == address(0), \"You are not the holder or bond is matched\");\n        changeDeposit(_id, _deposit);\n        changeExpiration(_id, _expiration);\n        changeYearFee(_id, _yearFee);\n        emit BondChanged(_id, _deposit, 0, _expiration, _yearFee, msg.sender);\n    }\n\n    function changeDeposit(uint256 _id, uint256 _deposit) internal {\n        uint256 _oldDeposit = bonds[_id].deposit;\n        if (_deposit != 0 \u0026\u0026 _oldDeposit != _deposit) {\n            require(_deposit \u003e= minEther, \"Too small funds\");\n            bonds[_id].deposit = _deposit;\n            if (_oldDeposit \u003e _deposit) {\n                msg.sender.transfer(_oldDeposit.sub(_deposit));\n            } else {\n                require(msg.value == _deposit.sub(_oldDeposit), \"Incorrect value\");\n            }\n        }\n    }\n\n    function changePercent(uint256 _id, uint256 _percent) internal {\n        uint256 _oldPercent = bonds[_id].percent;\n        if (_percent != 0 \u0026\u0026 _oldPercent != _percent) {\n            require(_percent \u003e= ITBoxManager(settings.tBoxManager()).withdrawPercent(bonds[_id].deposit), \"Collateralization is not enough\");\n            bonds[_id].percent = _percent;\n        }\n    }\n\n    function changeExpiration(uint256 _id, uint256 _expiration) internal {\n        uint256 _oldExpiration = bonds[_id].expiration;\n        if (_oldExpiration != _expiration) {\n            require(_expiration \u003e= 1 days \u0026\u0026 _expiration \u003c= 365 days, \"Expiration out of range\");\n            bonds[_id].expiration = _expiration;\n        }\n    }\n\n    function changeYearFee(uint256 _id, uint256 _yearFee) internal {\n        uint256 _oldYearFee = bonds[_id].yearFee;\n        if (_oldYearFee != _yearFee) {\n            require(_yearFee \u003c= 25000, \"Fee out of range\");\n            bonds[_id].yearFee = _yearFee;\n        }\n    }\n\n    /// @dev Uses to match the issuer request.\n    /// @param _id A Bond ID.\n    function takeIssueRequest(uint256 _id) external payable issueRequest(_id) validTx {\n\n        address _issuer = bonds[_id].issuer;\n        uint256 _eth = bonds[_id].deposit.mul(divider).div(bonds[_id].percent);\n\n        require(msg.value == _eth, \"Incorrect ETH value\");\n\n        uint256 _sysEth = _eth.mul(issuerFee).div(divider);\n        systemETH = systemETH.add(_sysEth);\n\n        uint256 _tmv = _eth.mul(rate()).div(precision());\n        uint256 _box = ITBoxManager(settings.tBoxManager()).create.value(bonds[_id].deposit)(_tmv);\n\n        bonds[_id].holder = msg.sender;\n        bonds[_id].tmv = _tmv;\n        bonds[_id].expiration = bonds[_id].expiration.add(now);\n        bonds[_id].sysFee = holderFee;\n        bonds[_id].tBoxId = _box;\n        bonds[_id].createdAt = now;\n\n        _issuer.transfer(_eth.sub(_sysEth));\n        IToken(settings.tmvAddress()).transfer(msg.sender, _tmv);\n        emit BondMatched(_id, msg.sender, _box, _tmv, holderFee, _issuer);\n    }\n\n    /// @dev Uses to match the holder request.\n    /// @param _id A Bond ID.\n    function takeBuyRequest(uint256 _id) external payable buyRequest(_id) validTx {\n\n        address _holder = bonds[_id].holder;\n\n        uint256 _sysEth = bonds[_id].deposit.mul(issuerFee).div(divider);\n        systemETH = systemETH.add(_sysEth);\n\n        uint256 _tmv = bonds[_id].deposit.mul(rate()).div(precision());\n        uint256 _box = ITBoxManager(settings.tBoxManager()).create.value(msg.value)(_tmv);\n\n        bonds[_id].issuer = msg.sender;\n        bonds[_id].tmv = _tmv;\n        bonds[_id].expiration = bonds[_id].expiration.add(now);\n        bonds[_id].sysFee = holderFee;\n        bonds[_id].tBoxId = _box;\n        bonds[_id].createdAt = now;\n\n        msg.sender.transfer(bonds[_id].deposit.sub(_sysEth));\n        IToken(settings.tmvAddress()).transfer(_holder, _tmv);\n        emit BondMatched(_id, msg.sender, _box, _tmv, holderFee, _holder);\n    }\n\n    /// @dev Finishes the bond.\n    /// @param _id A Bond ID.\n    function finish(uint256 _id) external onlyIssuer(_id) validTx {\n\n        Bond memory bond = bonds[_id];\n\n        // It\u0027s not necessary to check matching of the bond\n        // since the expiration period cannot exceed 365 days.\n        require(now \u003c bond.expiration, \"Bond expired\");\n\n        uint256 _secondsPast = now.sub(bond.createdAt);\n        (uint256 _eth, ) = getBox(bond.tBoxId);\n\n        uint256 _yearFee = bond.tmv\n        .mul(_secondsPast)\n        .mul(bond.yearFee)\n        .div(365 days)\n        .div(divider);\n        uint256 _sysTMV = _yearFee.mul(bond.sysFee).div(divider);\n\n        address _holder = bond.holder;\n\n        if (_sysTMV \u003e 0) {\n            IToken(settings.tmvAddress()).transferFrom(\n                msg.sender,\n                address(this),\n                _sysTMV\n            );\n        }\n        if (_yearFee \u003e 0) {\n            IToken(settings.tmvAddress()).transferFrom(\n                msg.sender,\n                _holder,\n                _yearFee.sub(_sysTMV)\n            );\n        }\n\n        if (_eth \u003e 0) {\n            ITBoxManager(settings.tBoxManager()).transferFrom(address(this), msg.sender, bond.tBoxId);\n        }\n        // when TBox no longer exists\n        delete bonds[_id];\n\n        emit BondFinished(_id, msg.sender, _holder);\n    }\n\n    /// @dev Executes expiration process of the bond.\n    /// @param _id A Bond ID.\n    function expire(uint256 _id) external matched(_id) validTx {\n        require(now \u003e bonds[_id].expiration, \"Bond hasn\u0027t expired\");\n\n        (uint256 _eth, uint256 _tmv) = getBox(bonds[_id].tBoxId);\n\n        if (_eth == 0) {\n            emit BondExpired(_id, bonds[_id].issuer, bonds[_id].holder);\n            delete bonds[_id];\n            return;\n        }\n\n        uint256 _collateralPercent = ITBoxManager(settings.tBoxManager()).collateralPercent(bonds[_id].tBoxId);\n        uint256 _targetCollateralPercent = settings.globalTargetCollateralization();\n        if (_collateralPercent \u003e _targetCollateralPercent) {\n            uint256 _ethTarget = _tmv.mul(_targetCollateralPercent).div(rate()); // mul and div by precision are omitted\n            uint256 _issuerEth = _eth.sub(_ethTarget);\n            uint256 _withdrawableEth = ITBoxManager(settings.tBoxManager()).withdrawableEth(\n                bonds[_id].tBoxId\n            );\n            if (_issuerEth \u003e _withdrawableEth) {\n                _issuerEth = _withdrawableEth;\n            }\n            ITBoxManager(settings.tBoxManager()).withdrawEth(\n                bonds[_id].tBoxId,\n                _issuerEth\n            );\n            bonds[_id].issuer.transfer(_issuerEth);\n        }\n\n        _eth = ITBoxManager(settings.tBoxManager()).withdrawableEth(\n            bonds[_id].tBoxId\n        );\n\n        uint256 _commission = _eth.mul(bonds[_id].sysFee).div(divider);\n\n        if (_commission \u003e 0) {\n            ITBoxManager(settings.tBoxManager()).withdrawEth(\n                bonds[_id].tBoxId,\n                _commission\n            );\n            systemETH = systemETH.add(_commission);\n        }\n\n        ITBoxManager(settings.tBoxManager()).transferFrom(\n            address(this),\n            bonds[_id].holder,\n            bonds[_id].tBoxId\n        );\n\n        emit BondExpired(_id, bonds[_id].issuer, bonds[_id].holder);\n\n        delete bonds[_id];\n    }\n\n    /// @dev Returns TBox parameters.\n    /// @param _id A Bond ID.\n    function getBox(uint256 _id) public view returns(uint256, uint256) {\n        return ITBoxManager(settings.tBoxManager()).boxes(_id);\n    }\n\n    /// @dev Needs to claim funds from the logic contract to execute finishing and expiration.\n    function() external payable {}\n\n    /// @dev Withdraws system fee.\n    /// @param _beneficiary The address to forward funds to.\n    function withdrawSystemETH(address _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n        require(systemETH \u003e 0, \"There is no available ETH\");\n\n        uint256 _systemETH = systemETH;\n        systemETH = 0;\n        _beneficiary.transfer(_systemETH);\n    }\n\n    /// @dev Reclaims ERC20 tokens.\n    /// @param _token The address of the ERC20 token.\n    /// @param _beneficiary The address to forward funds to.\n    function reclaimERC20(address _token, address _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n\n        uint256 _amount = IToken(_token).balanceOf(address(this));\n        require(_amount \u003e 0, \"There are no tokens\");\n        IToken(_token).transfer(_beneficiary, _amount);\n    }\n\n    /// @dev Sets issuer fee.\n    /// @param _value Commission percentage.\n    function setIssuerFee(uint256 _value) external onlyAdmin {\n        require(_value \u003c= 10000, \"Too much\");\n        issuerFee = _value;\n        emit BondIssuerFeeUpdated(_value);\n    }\n\n    /// @dev Sets holder fee.\n    /// @param _value Commission percentage.\n    function setHolderFee(uint256 _value) external onlyAdmin {\n        require(_value \u003c= 50000, \"Too much\");\n        holderFee = _value;\n        emit BondHolderFeeUpdated(_value);\n    }\n\n    /// @dev Sets minimum deposit amount.\n    /// @param _value The minimum deposit amount in wei.\n    function setMinEther(uint256 _value) external onlyAdmin {\n        require(_value \u003c= 100 ether, \"Too much\");\n        minEther = _value;\n        emit BondMinEtherUpdated(_value);\n    }\n\n    /// @dev Sets admin address.\n    /// @param _newAdmin The address of the new admin.\n    function changeAdmin(address _newAdmin) external onlyAdmin {\n        require(_newAdmin != address(0), \"Zero address, be careful\");\n        admin = _newAdmin;\n    }\n\n    /// @dev Returns precision using for USD and commission calculation.\n    function precision() public view returns(uint256) {\n        return ITBoxManager(settings.tBoxManager()).precision();\n    }\n\n    /// @dev Returns current oracle ETH/USD price with precision.\n    function rate() public view returns(uint256) {\n        return IOracle(settings.oracleAddress()).ethUsdPrice();\n    }\n\n    /// @dev Transfers issuer\u0027s rights of an Order.\n    function transferIssuerRights(address _to, uint256 _id) external onlyIssuer(_id) {\n        require(_to != address(0), \"Zero address, be careful\");\n        bonds[_id].issuer = _to;\n        emit IssuerRightsTransferred(msg.sender, _to, _id);\n    }\n\n    /// @dev Transfers holder\u0027s rights of an Order.\n    function transferHolderRights(address _to, uint256 _id) external onlyHolder(_id) {\n        require(_to != address(0), \"Zero address, be careful\");\n        bonds[_id].holder = _to;\n        emit HolderRightsTransferred(msg.sender, _to, _id);\n    }\n}\n"},"IOracle.sol":{"content":"pragma solidity 0.4.25;\n\n\n/// @title IOracle\n/// @dev Interface for getting the data from the oracle contract.\ninterface IOracle {\n    function ethUsdPrice() external view returns(uint256);\n}\n"},"ISettings.sol":{"content":"pragma solidity 0.4.25;\n\n\n/// @title ISettings\n/// @dev Interface for getting the data from settings contract.\ninterface ISettings {\n    function oracleAddress() external view returns(address);\n    function minDeposit() external view returns(uint256);\n    function sysFee() external view returns(uint256);\n    function userFee() external view returns(uint256);\n    function ratio() external view returns(uint256);\n    function globalTargetCollateralization() external view returns(uint256);\n    function tmvAddress() external view returns(uint256);\n    function maxStability() external view returns(uint256);\n    function minStability() external view returns(uint256);\n    function gasPriceLimit() external view returns(uint256);\n    function isFeeManager(address account) external view returns (bool);\n    function tBoxManager() external view returns(address);\n}\n"},"ITBoxManager.sol":{"content":"pragma solidity 0.4.25;\n\n\n/// @title ILogic\n/// @dev Interface for interaction with the TMV logic contract to manage Boxes.\ninterface ITBoxManager {\n    function create(uint256 withdraw) external payable returns (uint256);\n    function precision() external view returns (uint256);\n    function rate() external view returns (uint256);\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function close(uint256 id) external;\n    function withdrawPercent(uint256 _collateral) external view returns(uint256);\n    function boxes(uint256 id) external view returns(uint256, uint256);\n    function withdrawEth(uint256 _id, uint256 _amount) external;\n    function withdrawTmv(uint256 _id, uint256 _amount) external;\n    function withdrawableEth(uint256 id) external view returns(uint256);\n    function withdrawableTmv(uint256 collateral) external view returns(uint256);\n    function maxCapAmount(uint256 _id) external view returns (uint256);\n    function collateralPercent(uint256 _id) external view returns (uint256);\n    function capitalize(uint256 _id, uint256 _tmv) external;\n    function boxWithdrawableTmv(uint256 _id) external view returns(uint256);\n    function addEth(uint256 _id) external payable;\n    function capitalizeMax(uint256 _id) external payable;\n    function withdrawTmvMax(uint256 _id) external payable;\n    function addTmv(uint256 _id, uint256 _amount) external payable;\n}\n"},"IToken.sol":{"content":"pragma solidity 0.4.25;\n\n\n/// @title IToken\n/// @dev Interface for interaction with the TMV token contract.\ninterface IToken {\n    function burnLogic(address from, uint256 value) external;\n    function approve(address spender, uint256 value) external;\n    function balanceOf(address who) external view returns (uint256);\n    function mint(address to, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 tokenId) external;\n}\n\n"},"SafeMath.sol":{"content":"pragma solidity 0.4.25;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \u0027mul\u0027);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \u0027div\u0027);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \u0027sub\u0027);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \u0027add\u0027);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n"}}