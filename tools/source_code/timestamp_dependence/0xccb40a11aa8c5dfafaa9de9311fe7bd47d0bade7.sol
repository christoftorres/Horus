{"Claims.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\nimport \"./TokenFunctions.sol\";\r\nimport \"./ClaimsData.sol\";\r\nimport \"./MCR.sol\";\r\n\r\n\r\ncontract Claims is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    \r\n    TokenFunctions internal tf;\r\n    NXMToken internal tk;\r\n    TokenController internal tc;\r\n    ClaimsReward internal cr;\r\n    Pool1 internal p1;\r\n    ClaimsData internal cd;\r\n    TokenData internal td;\r\n    PoolData internal pd;\r\n    Pool2 internal p2;\r\n    QuotationData internal qd;\r\n    MCR internal m1;\r\n\r\n    uint private constant DECIMAL1E18 = uint(10) ** 18;\r\n    \r\n    /**\r\n     * @dev Sets the status of claim using claim id.\r\n     * @param claimId claim id.\r\n     * @param stat status to be set.\r\n     */ \r\n    function setClaimStatus(uint claimId, uint stat) external onlyInternal {\r\n        _setClaimStatus(claimId, stat);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets claim details of claim id = pending claim start + given index\r\n     */ \r\n    function getClaimFromNewStart(\r\n        uint index\r\n    )\r\n        external \r\n        view \r\n        returns (\r\n            uint coverId,\r\n            uint claimId,\r\n            int8 voteCA,\r\n            int8 voteMV,\r\n            uint statusnumber\r\n        ) \r\n    {\r\n        (coverId, claimId, voteCA, voteMV, statusnumber) = cd.getClaimFromNewStart(index, msg.sender);\r\n        // status = rewardStatus[statusnumber].claimStatusDesc;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets details of a claim submitted by the calling user, at a given index\r\n     */\r\n    function getUserClaimByIndex(\r\n        uint index\r\n    )\r\n        external\r\n        view \r\n        returns(\r\n            uint status,\r\n            uint coverId,\r\n            uint claimId\r\n        )\r\n    {\r\n        uint statusno;\r\n        (statusno, coverId, claimId) = cd.getUserClaimByIndex(index, msg.sender);\r\n        status = statusno;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets details of a given claim id.\r\n     * @param _claimId Claim Id.\r\n     * @return status Current status of claim id\r\n     * @return finalVerdict Decision made on the claim, 1 -\u003e acceptance, -1 -\u003e denial\r\n     * @return claimOwner Address through which claim is submitted\r\n     * @return coverId Coverid associated with the claim id\r\n     */\r\n    function getClaimbyIndex(uint _claimId) external view returns (\r\n        uint claimId,\r\n        uint status,\r\n        int8 finalVerdict,\r\n        address claimOwner,\r\n        uint coverId\r\n    )\r\n    {\r\n        uint stat;\r\n        claimId = _claimId;\r\n        (, coverId, finalVerdict, stat, , ) = cd.getClaim(_claimId);\r\n        claimOwner = qd.getCoverMemberAddress(coverId);\r\n        status = stat;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates total amount that has been used to assess a claim.\r\n     * Computaion:Adds acceptCA(tokens used for voting in favor of a claim)\r\n     * denyCA(tokens used for voting against a claim) *  current token price.\r\n     * @param claimId Claim Id.\r\n     * @param member Member type 0 -\u003e Claim Assessors, else members.\r\n     * @return tokens Total Amount used in Claims assessment.\r\n     */ \r\n    function getCATokens(uint claimId, uint member) external view returns(uint tokens) {\r\n        uint coverId;\r\n        (, coverId) = cd.getClaimCoverId(claimId);\r\n        bytes4 curr = qd.getCurrencyOfCover(coverId);\r\n        uint tokenx1e18 = m1.calculateTokenPrice(curr);\r\n        uint accept;\r\n        uint deny;\r\n        if (member == 0) {\r\n            (, accept, deny) = cd.getClaimsTokenCA(claimId);\r\n        } else {\r\n            (, accept, deny) = cd.getClaimsTokenMV(claimId);\r\n        }\r\n        tokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18); // amount (not in tokens)\r\n    }\r\n\r\n    /**\r\n     * Iupgradable Interface to update dependent contract address\r\n     */\r\n    function changeDependentContractAddress() public onlyInternal {\r\n        tk = NXMToken(ms.tokenAddress());\r\n        td = TokenData(ms.getLatestAddress(\"TD\"));\r\n        tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\r\n        tc = TokenController(ms.getLatestAddress(\"TC\"));\r\n        p1 = Pool1(ms.getLatestAddress(\"P1\"));\r\n        p2 = Pool2(ms.getLatestAddress(\"P2\"));\r\n        pd = PoolData(ms.getLatestAddress(\"PD\"));\r\n        cr = ClaimsReward(ms.getLatestAddress(\"CR\"));\r\n        cd = ClaimsData(ms.getLatestAddress(\"CD\"));\r\n        qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n        m1 = MCR(ms.getLatestAddress(\"MC\"));\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the pending claim start variable,\r\n     * the lowest claim id with a pending decision/payout.\r\n     */ \r\n    function changePendingClaimStart() public onlyInternal {\r\n\r\n        uint origstat;\r\n        uint state12Count;\r\n        uint pendingClaimStart = cd.pendingClaimStart();\r\n        uint actualClaimLength = cd.actualClaimLength();\r\n        for (uint i = pendingClaimStart; i \u003c actualClaimLength; i++) {\r\n            (, , , origstat, , state12Count) = cd.getClaim(i);\r\n\r\n            if (origstat \u003e 5 \u0026\u0026 ((origstat != 12) || (origstat == 12 \u0026\u0026 state12Count \u003e= 60)))\r\n                cd.setpendingClaimStart(i);\r\n            else\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Submits a claim for a given cover note.\r\n     * Adds claim to queue incase of emergency pause else directly submits the claim.\r\n     * @param coverId Cover Id.\r\n     */ \r\n    function submitClaim(uint coverId) public {\r\n        address qadd = qd.getCoverMemberAddress(coverId);\r\n        require(qadd == msg.sender);\r\n        uint8 cStatus;\r\n        (, cStatus, , , ) = qd.getCoverDetailsByCoverID2(coverId);\r\n        require(cStatus != uint8(QuotationData.CoverStatus.ClaimSubmitted), \"Claim already submitted\");\r\n        require(cStatus != uint8(QuotationData.CoverStatus.CoverExpired), \"Cover already expired\");\r\n        if (ms.isPause() == false) {\r\n            _addClaim(coverId, now, qadd);\r\n        } else {\r\n            cd.setClaimAtEmergencyPause(coverId, now, false);\r\n            qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.Requested));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Submits the Claims queued once the emergency pause is switched off.\r\n     */\r\n    function submitClaimAfterEPOff() public onlyInternal {\r\n        uint lengthOfClaimSubmittedAtEP = cd.getLengthOfClaimSubmittedAtEP();\r\n        uint firstClaimIndexToSubmitAfterEP = cd.getFirstClaimIndexToSubmitAfterEP();\r\n        uint coverId;\r\n        uint dateUpd;\r\n        bool submit;\r\n        address qadd;\r\n        for (uint i = firstClaimIndexToSubmitAfterEP; i \u003c lengthOfClaimSubmittedAtEP; i++) {\r\n            (coverId, dateUpd, submit) = cd.getClaimOfEmergencyPauseByIndex(i);\r\n            require(submit == false);\r\n            qadd = qd.getCoverMemberAddress(coverId);\r\n            _addClaim(coverId, dateUpd, qadd);\r\n            cd.setClaimSubmittedAtEPTrue(i, true);\r\n        }\r\n        cd.setFirstClaimIndexToSubmitAfterEP(lengthOfClaimSubmittedAtEP);\r\n    }\r\n\r\n    /**\r\n     * @dev Castes vote for members who have tokens locked under Claims Assessment\r\n     * @param claimId  claim id.\r\n     * @param verdict 1 for Accept,-1 for Deny.\r\n     */ \r\n    function submitCAVote(uint claimId, int8 verdict) public isMemberAndcheckPause {\r\n        require(checkVoteClosing(claimId) != 1); \r\n        require(cd.userClaimVotePausedOn(msg.sender).add(cd.pauseDaysCA()) \u003c now);  \r\n        uint tokens = tc.tokensLockedAtTime(msg.sender, \"CLA\", now.add(cd.claimDepositTime()));\r\n        require(tokens \u003e 0);\r\n        uint stat;\r\n        (, stat) = cd.getClaimStatusNumber(claimId);\r\n        require(stat == 0);\r\n        require(cd.getUserClaimVoteCA(msg.sender, claimId) == 0);\r\n        td.bookCATokens(msg.sender);\r\n        cd.addVote(msg.sender, tokens, claimId, verdict);\r\n        cd.callVoteEvent(msg.sender, claimId, \"CAV\", tokens, now, verdict);\r\n        uint voteLength = cd.getAllVoteLength();\r\n        cd.addClaimVoteCA(claimId, voteLength);\r\n        cd.setUserClaimVoteCA(msg.sender, claimId, voteLength);\r\n        cd.setClaimTokensCA(claimId, verdict, tokens);\r\n        tc.extendLockOf(msg.sender, \"CLA\", td.lockCADays());\r\n        int close = checkVoteClosing(claimId);\r\n        if (close == 1) {\r\n            cr.changeClaimStatus(claimId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Submits a member vote for assessing a claim.\r\n     * Tokens other than those locked under Claims\r\n     * Assessment can be used to cast a vote for a given claim id.\r\n     * @param claimId Selected claim id.\r\n     * @param verdict 1 for Accept,-1 for Deny.\r\n     */ \r\n    function submitMemberVote(uint claimId, int8 verdict) public isMemberAndcheckPause {\r\n        require(checkVoteClosing(claimId) != 1);\r\n        uint stat;\r\n        uint tokens = tc.totalBalanceOf(msg.sender);\r\n        (, stat) = cd.getClaimStatusNumber(claimId);\r\n        require(stat \u003e= 1 \u0026\u0026 stat \u003c= 5);\r\n        require(cd.getUserClaimVoteMember(msg.sender, claimId) == 0);\r\n        cd.addVote(msg.sender, tokens, claimId, verdict);\r\n        cd.callVoteEvent(msg.sender, claimId, \"MV\", tokens, now, verdict);\r\n        tc.lockForMemberVote(msg.sender, td.lockMVDays());\r\n        uint voteLength = cd.getAllVoteLength();\r\n        cd.addClaimVotemember(claimId, voteLength);\r\n        cd.setUserClaimVoteMember(msg.sender, claimId, voteLength);\r\n        cd.setClaimTokensMV(claimId, verdict, tokens);\r\n        int close = checkVoteClosing(claimId);\r\n        if (close == 1) {\r\n            cr.changeClaimStatus(claimId);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Pause Voting of All Pending Claims when Emergency Pause Start.\r\n    */ \r\n    function pauseAllPendingClaimsVoting() public onlyInternal {\r\n        uint firstIndex = cd.pendingClaimStart();\r\n        uint actualClaimLength = cd.actualClaimLength();\r\n        for (uint i = firstIndex; i \u003c actualClaimLength; i++) {\r\n            if (checkVoteClosing(i) == 0) {\r\n                uint dateUpd = cd.getClaimDateUpd(i);\r\n                cd.setPendingClaimDetails(i, (dateUpd.add(cd.maxVotingTime())).sub(now), false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Resume the voting phase of all Claims paused due to an emergency pause.\r\n     */\r\n    function startAllPendingClaimsVoting() public onlyInternal {\r\n        uint firstIndx = cd.getFirstClaimIndexToStartVotingAfterEP();\r\n        uint i;\r\n        uint lengthOfClaimVotingPause = cd.getLengthOfClaimVotingPause();\r\n        for (i = firstIndx; i \u003c lengthOfClaimVotingPause; i++) {\r\n            uint pendingTime;\r\n            uint claimID;\r\n            (claimID, pendingTime, ) = cd.getPendingClaimDetailsByIndex(i);\r\n            uint pTime = (now.sub(cd.maxVotingTime())).add(pendingTime);\r\n            cd.setClaimdateUpd(claimID, pTime);\r\n            cd.setPendingClaimVoteStatus(i, true);\r\n            uint coverid;\r\n            (, coverid) = cd.getClaimCoverId(claimID);\r\n            address qadd = qd.getCoverMemberAddress(coverid);\r\n            tf.extendCNEPOff(qadd, coverid, pendingTime.add(cd.claimDepositTime()));\r\n            p1.closeClaimsOraclise(claimID, uint64(pTime));\r\n        }\r\n        cd.setFirstClaimIndexToStartVotingAfterEP(i);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if voting of a claim should be closed or not.\r\n     * @param claimId Claim Id.\r\n     * @return close 1 -\u003e voting should be closed, 0 -\u003e if voting should not be closed,\r\n     * -1 -\u003e voting has already been closed.\r\n     */ \r\n    function checkVoteClosing(uint claimId) public view returns(int8 close) {\r\n        close = 0;\r\n        uint status;\r\n        (, status) = cd.getClaimStatusNumber(claimId);\r\n        uint dateUpd = cd.getClaimDateUpd(claimId);\r\n        if (status == 12 \u0026\u0026 dateUpd.add(cd.payoutRetryTime()) \u003c now) {\r\n            if (cd.getClaimState12Count(claimId) \u003c 60)\r\n                close = 1;\r\n        } \r\n        \r\n        if (status \u003e 5 \u0026\u0026 status != 12) {\r\n            close = -1;\r\n        }  else if (status != 12 \u0026\u0026 dateUpd.add(cd.maxVotingTime()) \u003c= now) {\r\n            close = 1;\r\n        } else if (status != 12 \u0026\u0026 dateUpd.add(cd.minVotingTime()) \u003e= now) {\r\n            close = 0;\r\n        } else if (status == 0 || (status \u003e= 1 \u0026\u0026 status \u003c= 5)) {\r\n            close = _checkVoteClosingFinal(claimId, status);\r\n        }\r\n        \r\n    }\r\n\r\n    /**\r\n     * @dev Checks if voting of a claim should be closed or not.\r\n     * Internally called by checkVoteClosing method\r\n     * for Claims whose status number is 0 or status number lie between 2 and 6.\r\n     * @param claimId Claim Id.\r\n     * @param status Current status of claim.\r\n     * @return close 1 if voting should be closed,0 in case voting should not be closed,\r\n     * -1 if voting has already been closed.\r\n     */\r\n    function _checkVoteClosingFinal(uint claimId, uint status) internal view returns(int8 close) {\r\n        close = 0;\r\n        uint coverId;\r\n        (, coverId) = cd.getClaimCoverId(claimId);\r\n        bytes4 curr = qd.getCurrencyOfCover(coverId);\r\n        uint tokenx1e18 = m1.calculateTokenPrice(curr);\r\n        uint accept;\r\n        uint deny;\r\n        (, accept, deny) = cd.getClaimsTokenCA(claimId);\r\n        uint caTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);\r\n        (, accept, deny) = cd.getClaimsTokenMV(claimId);\r\n        uint mvTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);\r\n        uint sumassured = qd.getCoverSumAssured(coverId).mul(DECIMAL1E18);\r\n        if (status == 0 \u0026\u0026 caTokens \u003e= sumassured.mul(10)) {\r\n            close = 1;\r\n        } else if (status \u003e= 1 \u0026\u0026 status \u003c= 5 \u0026\u0026 mvTokens \u003e= sumassured.mul(10)) {\r\n            close = 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the status of an existing claim id, based on current \r\n     * status and current conditions of the system\r\n     * @param claimId Claim Id.\r\n     * @param stat status number.  \r\n     */\r\n    function _setClaimStatus(uint claimId, uint stat) internal {\r\n\r\n        uint origstat;\r\n        uint state12Count;\r\n        uint dateUpd;\r\n        uint coverId;\r\n        (, coverId, , origstat, dateUpd, state12Count) = cd.getClaim(claimId);\r\n        (, origstat) = cd.getClaimStatusNumber(claimId);\r\n\r\n        if (stat == 12 \u0026\u0026 origstat == 12) {\r\n            cd.updateState12Count(claimId, 1);\r\n        }\r\n        cd.setClaimStatus(claimId, stat);\r\n\r\n        if (state12Count \u003e= 60 \u0026\u0026 stat == 12) {\r\n            cd.setClaimStatus(claimId, 13);\r\n            qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimDenied));\r\n        }\r\n        uint time = now;\r\n        cd.setClaimdateUpd(claimId, time);\r\n\r\n        if (stat \u003e= 2 \u0026\u0026 stat \u003c= 5) {\r\n            p1.closeClaimsOraclise(claimId, cd.maxVotingTime());\r\n        }\r\n\r\n        if (stat == 12 \u0026\u0026 (dateUpd.add(cd.payoutRetryTime()) \u003c= now) \u0026\u0026 (state12Count \u003c 60)) {\r\n            p1.closeClaimsOraclise(claimId, cd.payoutRetryTime());\r\n        } else if (stat == 12 \u0026\u0026 (dateUpd.add(cd.payoutRetryTime()) \u003e now) \u0026\u0026 (state12Count \u003c 60)) {\r\n            uint64 timeLeft = uint64((dateUpd.add(cd.payoutRetryTime())).sub(now));\r\n            p1.closeClaimsOraclise(claimId, timeLeft);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Submits a claim for a given cover note.\r\n     * Set deposits flag against cover.\r\n     */\r\n    function _addClaim(uint coverId, uint time, address add) internal {\r\n        tf.depositCN(coverId);\r\n        uint len = cd.actualClaimLength();\r\n        cd.addClaim(len, coverId, add, now);\r\n        cd.callClaimEvent(coverId, add, len, time);\r\n        qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimSubmitted));\r\n        bytes4 curr = qd.getCurrencyOfCover(coverId);\r\n        uint sumAssured = qd.getCoverSumAssured(coverId).mul(DECIMAL1E18);\r\n        pd.changeCurrencyAssetVarMin(curr, pd.getCurrencyAssetVarMin(curr).add(sumAssured));\r\n        p2.internalLiquiditySwap(curr);\r\n        p1.closeClaimsOraclise(len, cd.maxVotingTime());\r\n    }\r\n}\r\n"},"ClaimsData.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\nimport \"./Iupgradable.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\n\r\ncontract ClaimsData is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    struct Claim {\r\n        uint coverId;\r\n        uint dateUpd;\r\n    }\r\n\r\n    struct Vote {\r\n        address voter;\r\n        uint tokens;\r\n        uint claimId;\r\n        int8 verdict;\r\n        bool rewardClaimed;\r\n    }\r\n\r\n    struct ClaimsPause {\r\n        uint coverid;\r\n        uint dateUpd;\r\n        bool submit;\r\n    }\r\n\r\n    struct ClaimPauseVoting {\r\n        uint claimid;\r\n        uint pendingTime;\r\n        bool voting;\r\n    }\r\n\r\n    struct RewardDistributed {\r\n        uint lastCAvoteIndex;\r\n        uint lastMVvoteIndex;\r\n\r\n    }\r\n\r\n    struct ClaimRewardDetails {\r\n        uint percCA;\r\n        uint percMV;\r\n        uint tokenToBeDist;\r\n\r\n    }\r\n\r\n    struct ClaimTotalTokens {\r\n        uint accept;\r\n        uint deny;\r\n    }\r\n\r\n    struct ClaimRewardStatus {\r\n        uint percCA;\r\n        uint percMV;\r\n    }\r\n\r\n    ClaimRewardStatus[] internal rewardStatus;\r\n\r\n    Claim[] internal allClaims;\r\n    Vote[] internal allvotes;\r\n    ClaimsPause[] internal claimPause;\r\n    ClaimPauseVoting[] internal claimPauseVotingEP;\r\n\r\n    mapping(address =\u003e RewardDistributed) internal voterVoteRewardReceived;\r\n    mapping(uint =\u003e ClaimRewardDetails) internal claimRewardDetail;\r\n    mapping(uint =\u003e ClaimTotalTokens) internal claimTokensCA;\r\n    mapping(uint =\u003e ClaimTotalTokens) internal claimTokensMV;\r\n    mapping(uint =\u003e int8) internal claimVote;\r\n    mapping(uint =\u003e uint) internal claimsStatus;\r\n    mapping(uint =\u003e uint) internal claimState12Count;\r\n    mapping(uint =\u003e uint[]) internal claimVoteCA;\r\n    mapping(uint =\u003e uint[]) internal claimVoteMember;\r\n    mapping(address =\u003e uint[]) internal voteAddressCA;\r\n    mapping(address =\u003e uint[]) internal voteAddressMember;\r\n    mapping(address =\u003e uint[]) internal allClaimsByAddress;\r\n    mapping(address =\u003e mapping(uint =\u003e uint)) internal userClaimVoteCA;\r\n    mapping(address =\u003e mapping(uint =\u003e uint)) internal userClaimVoteMember;\r\n    mapping(address =\u003e uint) public userClaimVotePausedOn;\r\n\r\n    uint internal claimPauseLastsubmit;\r\n    uint internal claimStartVotingFirstIndex;\r\n    uint public pendingClaimStart;\r\n    uint public claimDepositTime;\r\n    uint public maxVotingTime;\r\n    uint public minVotingTime;\r\n    uint public payoutRetryTime;\r\n    uint public claimRewardPerc;\r\n    uint public minVoteThreshold;\r\n    uint public maxVoteThreshold;\r\n    uint public majorityConsensus;\r\n    uint public pauseDaysCA;\r\n   \r\n    event ClaimRaise(\r\n        uint indexed coverId,\r\n        address indexed userAddress,\r\n        uint claimId,\r\n        uint dateSubmit\r\n    );\r\n\r\n    event VoteCast(\r\n        address indexed userAddress,\r\n        uint indexed claimId,\r\n        bytes4 indexed typeOf,\r\n        uint tokens,\r\n        uint submitDate,\r\n        int8 verdict\r\n    );\r\n\r\n    constructor() public {\r\n        pendingClaimStart = 1;\r\n        maxVotingTime = 48 * 1 hours;\r\n        minVotingTime = 12 * 1 hours;\r\n        payoutRetryTime = 24 * 1 hours;\r\n        allvotes.push(Vote(address(0), 0, 0, 0, false));\r\n        allClaims.push(Claim(0, 0));\r\n        claimDepositTime = 7 days;\r\n        claimRewardPerc = 20;\r\n        minVoteThreshold = 5;\r\n        maxVoteThreshold = 10;\r\n        majorityConsensus = 70;\r\n        pauseDaysCA = 3 days;\r\n        _addRewardIncentive();\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the pending claim start variable, \r\n     * the lowest claim id with a pending decision/payout.\r\n     */ \r\n    function setpendingClaimStart(uint _start) external onlyInternal {\r\n        require(pendingClaimStart \u003c= _start);\r\n        pendingClaimStart = _start;\r\n    }\r\n\r\n    /** \r\n     * @dev Updates the max vote index for which claim assessor has received reward \r\n     * @param _voter address of the voter.\r\n     * @param caIndex last index till which reward was distributed for CA\r\n     */ \r\n    function setRewardDistributedIndexCA(address _voter, uint caIndex) external onlyInternal {\r\n        voterVoteRewardReceived[_voter].lastCAvoteIndex = caIndex;\r\n\r\n    }\r\n\r\n    /** \r\n     * @dev Used to pause claim assessor activity for 3 days \r\n     * @param user Member address whose claim voting ability needs to be paused\r\n     */ \r\n    function setUserClaimVotePausedOn(address user) external {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        userClaimVotePausedOn[user] = now;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the max vote index for which member has received reward \r\n     * @param _voter address of the voter.\r\n     * @param mvIndex last index till which reward was distributed for member \r\n     */ \r\n    function setRewardDistributedIndexMV(address _voter, uint mvIndex) external onlyInternal {\r\n\r\n        voterVoteRewardReceived[_voter].lastMVvoteIndex = mvIndex;\r\n    }\r\n\r\n    /**\r\n     * @param claimid claim id.\r\n     * @param percCA reward Percentage reward for claim assessor\r\n     * @param percMV reward Percentage reward for members\r\n     * @param tokens total tokens to be rewarded\r\n     */ \r\n    function setClaimRewardDetail(\r\n        uint claimid,\r\n        uint percCA,\r\n        uint percMV,\r\n        uint tokens\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        claimRewardDetail[claimid].percCA = percCA;\r\n        claimRewardDetail[claimid].percMV = percMV;\r\n        claimRewardDetail[claimid].tokenToBeDist = tokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the reward claim status against a vote id.\r\n     * @param _voteid vote Id.\r\n     * @param claimed true if reward for vote is claimed, else false.\r\n     */ \r\n    function setRewardClaimed(uint _voteid, bool claimed) external onlyInternal {\r\n        allvotes[_voteid].rewardClaimed = claimed;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the final vote\u0027s result(either accepted or declined)of a claim.\r\n     * @param _claimId Claim Id.\r\n     * @param _verdict 1 if claim is accepted,-1 if declined.\r\n     */ \r\n    function changeFinalVerdict(uint _claimId, int8 _verdict) external onlyInternal {\r\n        claimVote[_claimId] = _verdict;\r\n    }\r\n    \r\n    /**\r\n     * @dev Creates a new claim.\r\n     */ \r\n    function addClaim(\r\n        uint _claimId,\r\n        uint _coverId,\r\n        address _from,\r\n        uint _nowtime\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        allClaims.push(Claim(_coverId, _nowtime));\r\n        allClaimsByAddress[_from].push(_claimId);\r\n    }\r\n\r\n    /**\r\n     * @dev Add Vote\u0027s details of a given claim.\r\n     */ \r\n    function addVote(\r\n        address _voter,\r\n        uint _tokens,\r\n        uint claimId,\r\n        int8 _verdict\r\n    ) \r\n        external\r\n        onlyInternal\r\n    {\r\n        allvotes.push(Vote(_voter, _tokens, claimId, _verdict, false));\r\n    }\r\n\r\n    /** \r\n     * @dev Stores the id of the claim assessor vote given to a claim.\r\n     * Maintains record of all votes given by all the CA to a claim.\r\n     * @param _claimId Claim Id to which vote has given by the CA.\r\n     * @param _voteid Vote Id.\r\n     */\r\n    function addClaimVoteCA(uint _claimId, uint _voteid) external onlyInternal {\r\n        claimVoteCA[_claimId].push(_voteid);\r\n    }\r\n\r\n    /** \r\n     * @dev Sets the id of the vote.\r\n     * @param _from Claim assessor\u0027s address who has given the vote.\r\n     * @param _claimId Claim Id for which vote has been given by the CA.\r\n     * @param _voteid Vote Id which will be stored against the given _from and claimid.\r\n     */ \r\n    function setUserClaimVoteCA(\r\n        address _from,\r\n        uint _claimId,\r\n        uint _voteid\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        userClaimVoteCA[_from][_claimId] = _voteid;\r\n        voteAddressCA[_from].push(_voteid);\r\n    }\r\n\r\n    /**\r\n     * @dev Stores the tokens locked by the Claim Assessors during voting of a given claim.\r\n     * @param _claimId Claim Id.\r\n     * @param _vote 1 for accept and increases the tokens of claim as accept,\r\n     * -1 for deny and increases the tokens of claim as deny.\r\n     * @param _tokens Number of tokens.\r\n     */ \r\n    function setClaimTokensCA(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\r\n        if (_vote == 1)\r\n            claimTokensCA[_claimId].accept = claimTokensCA[_claimId].accept.add(_tokens);\r\n        if (_vote == -1)\r\n            claimTokensCA[_claimId].deny = claimTokensCA[_claimId].deny.add(_tokens);\r\n    }\r\n\r\n    /** \r\n     * @dev Stores the tokens locked by the Members during voting of a given claim.\r\n     * @param _claimId Claim Id.\r\n     * @param _vote 1 for accept and increases the tokens of claim as accept,\r\n     * -1 for deny and increases the tokens of claim as deny.\r\n     * @param _tokens Number of tokens.\r\n     */ \r\n    function setClaimTokensMV(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\r\n        if (_vote == 1)\r\n            claimTokensMV[_claimId].accept = claimTokensMV[_claimId].accept.add(_tokens);\r\n        if (_vote == -1)\r\n            claimTokensMV[_claimId].deny = claimTokensMV[_claimId].deny.add(_tokens);\r\n    }\r\n\r\n    /** \r\n     * @dev Stores the id of the member vote given to a claim.\r\n     * Maintains record of all votes given by all the Members to a claim.\r\n     * @param _claimId Claim Id to which vote has been given by the Member.\r\n     * @param _voteid Vote Id.\r\n     */ \r\n    function addClaimVotemember(uint _claimId, uint _voteid) external onlyInternal {\r\n        claimVoteMember[_claimId].push(_voteid);\r\n    }\r\n\r\n    /** \r\n     * @dev Sets the id of the vote.\r\n     * @param _from Member\u0027s address who has given the vote.\r\n     * @param _claimId Claim Id for which vote has been given by the Member.\r\n     * @param _voteid Vote Id which will be stored against the given _from and claimid.\r\n     */ \r\n    function setUserClaimVoteMember(\r\n        address _from,\r\n        uint _claimId,\r\n        uint _voteid\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        userClaimVoteMember[_from][_claimId] = _voteid;\r\n        voteAddressMember[_from].push(_voteid);\r\n\r\n    }\r\n\r\n    /** \r\n     * @dev Increases the count of failure until payout of a claim is successful.\r\n     */ \r\n    function updateState12Count(uint _claimId, uint _cnt) external onlyInternal {\r\n        claimState12Count[_claimId] = claimState12Count[_claimId].add(_cnt);\r\n    }\r\n\r\n    /** \r\n     * @dev Sets status of a claim.\r\n     * @param _claimId Claim Id.\r\n     * @param _stat Status number.\r\n     */\r\n    function setClaimStatus(uint _claimId, uint _stat) external onlyInternal {\r\n        claimsStatus[_claimId] = _stat;\r\n    }\r\n\r\n    /** \r\n     * @dev Sets the timestamp of a given claim at which the Claim\u0027s details has been updated.\r\n     * @param _claimId Claim Id of claim which has been changed.\r\n     * @param _dateUpd timestamp at which claim is updated.\r\n     */ \r\n    function setClaimdateUpd(uint _claimId, uint _dateUpd) external onlyInternal {\r\n        allClaims[_claimId].dateUpd = _dateUpd;\r\n    }\r\n\r\n    /** \r\n     @dev Queues Claims during Emergency Pause.\r\n     */ \r\n    function setClaimAtEmergencyPause(\r\n        uint _coverId,\r\n        uint _dateUpd,\r\n        bool _submit\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        claimPause.push(ClaimsPause(_coverId, _dateUpd, _submit));\r\n    }\r\n\r\n    /** \r\n     * @dev Set submission flag for Claims queued during emergency pause.\r\n     * Set to true after EP is turned off and the claim is submitted .\r\n     */ \r\n    function setClaimSubmittedAtEPTrue(uint _index, bool _submit) external onlyInternal {\r\n        claimPause[_index].submit = _submit;\r\n    }\r\n\r\n    /** \r\n     * @dev Sets the index from which claim needs to be \r\n     * submitted when emergency pause is swithched off.\r\n     */ \r\n    function setFirstClaimIndexToSubmitAfterEP(\r\n        uint _firstClaimIndexToSubmit\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        claimPauseLastsubmit = _firstClaimIndexToSubmit;\r\n    }\r\n\r\n    /** \r\n     * @dev Sets the pending vote duration for a claim in case of emergency pause.\r\n     */ \r\n    function setPendingClaimDetails(\r\n        uint _claimId,\r\n        uint _pendingTime,\r\n        bool _voting\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        claimPauseVotingEP.push(ClaimPauseVoting(_claimId, _pendingTime, _voting));\r\n    }\r\n\r\n    /** \r\n     * @dev Sets voting flag true after claim is reopened for voting after emergency pause.\r\n     */ \r\n    function setPendingClaimVoteStatus(uint _claimId, bool _vote) external onlyInternal {\r\n        claimPauseVotingEP[_claimId].voting = _vote;\r\n    }\r\n    \r\n    /** \r\n     * @dev Sets the index from which claim needs to be \r\n     * reopened when emergency pause is swithched off. \r\n     */ \r\n    function setFirstClaimIndexToStartVotingAfterEP(\r\n        uint _claimStartVotingFirstIndex\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        claimStartVotingFirstIndex = _claimStartVotingFirstIndex;\r\n    }\r\n\r\n    /** \r\n     * @dev Calls Vote Event.\r\n     */ \r\n    function callVoteEvent(\r\n        address _userAddress,\r\n        uint _claimId,\r\n        bytes4 _typeOf,\r\n        uint _tokens,\r\n        uint _submitDate,\r\n        int8 _verdict\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        emit VoteCast(\r\n            _userAddress,\r\n            _claimId,\r\n            _typeOf,\r\n            _tokens,\r\n            _submitDate,\r\n            _verdict\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev Calls Claim Event. \r\n     */ \r\n    function callClaimEvent(\r\n        uint _coverId,\r\n        address _userAddress,\r\n        uint _claimId,\r\n        uint _datesubmit\r\n    ) \r\n        external\r\n        onlyInternal\r\n    {\r\n        emit ClaimRaise(_coverId, _userAddress, _claimId, _datesubmit);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Uint Parameters by parameter code\r\n     * @param code whose details we want\r\n     * @return string value of the parameter\r\n     * @return associated amount (time or perc or value) to the code\r\n     */\r\n    function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\r\n        codeVal = code;\r\n        if (code == \"CAMAXVT\") {\r\n            val = maxVotingTime / (1 hours);\r\n\r\n        } else if (code == \"CAMINVT\") {\r\n\r\n            val = minVotingTime / (1 hours);\r\n\r\n        } else if (code == \"CAPRETRY\") {\r\n\r\n            val = payoutRetryTime / (1 hours);\r\n\r\n        } else if (code == \"CADEPT\") {\r\n\r\n            val = claimDepositTime / (1 days);\r\n\r\n        } else if (code == \"CAREWPER\") {\r\n\r\n            val = claimRewardPerc;\r\n\r\n        } else if (code == \"CAMINTH\") {\r\n\r\n            val = minVoteThreshold;\r\n\r\n        } else if (code == \"CAMAXTH\") {\r\n\r\n            val = maxVoteThreshold;\r\n\r\n        } else if (code == \"CACONPER\") {\r\n\r\n            val = majorityConsensus;\r\n\r\n        } else if (code == \"CAPAUSET\") {\r\n            val = pauseDaysCA / (1 days);\r\n        }\r\n    \r\n    }\r\n\r\n    /**\r\n     * @dev Get claim queued during emergency pause by index.\r\n     */ \r\n    function getClaimOfEmergencyPauseByIndex(\r\n        uint _index\r\n    ) \r\n        external\r\n        view\r\n        returns(\r\n            uint coverId,\r\n            uint dateUpd,\r\n            bool submit\r\n        )\r\n    {\r\n        coverId = claimPause[_index].coverid;\r\n        dateUpd = claimPause[_index].dateUpd;\r\n        submit = claimPause[_index].submit;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Claim\u0027s details of given claimid.   \r\n     */ \r\n    function getAllClaimsByIndex(\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint coverId,\r\n            int8 vote,\r\n            uint status,\r\n            uint dateUpd,\r\n            uint state12Count\r\n        )\r\n    {\r\n        return(\r\n            allClaims[_claimId].coverId,\r\n            claimVote[_claimId],\r\n            claimsStatus[_claimId],\r\n            allClaims[_claimId].dateUpd,\r\n            claimState12Count[_claimId]\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the vote id of a given claim of a given Claim Assessor.\r\n     */ \r\n    function getUserClaimVoteCA(\r\n        address _add,\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(uint idVote)\r\n    {\r\n        return userClaimVoteCA[_add][_claimId];\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the vote id of a given claim of a given member.\r\n     */\r\n    function getUserClaimVoteMember(\r\n        address _add,\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(uint idVote)\r\n    {\r\n        return userClaimVoteMember[_add][_claimId];\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the count of all votes.\r\n     */ \r\n    function getAllVoteLength() external view returns(uint voteCount) {\r\n        return allvotes.length.sub(1); //Start Index always from 1.\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the status number of a given claim.\r\n     * @param _claimId Claim id.\r\n     * @return statno Status Number. \r\n     */ \r\n    function getClaimStatusNumber(uint _claimId) external view returns(uint claimId, uint statno) {\r\n        return (_claimId, claimsStatus[_claimId]);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the reward percentage to be distributed for a given status id\r\n     * @param statusNumber the number of type of status\r\n     * @return percCA reward Percentage for claim assessor\r\n     * @return percMV reward Percentage for members\r\n     */\r\n    function getRewardStatus(uint statusNumber) external view returns(uint percCA, uint percMV) {\r\n        return (rewardStatus[statusNumber].percCA, rewardStatus[statusNumber].percMV);\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the number of tries that have been made for a successful payout of a Claim.\r\n     */ \r\n    function getClaimState12Count(uint _claimId) external view returns(uint num) {\r\n        num = claimState12Count[_claimId];\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the last update date of a claim.\r\n     */ \r\n    function getClaimDateUpd(uint _claimId) external view returns(uint dateupd) {\r\n        dateupd = allClaims[_claimId].dateUpd;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets all Claims created by a user till date.\r\n     * @param _member user\u0027s address.\r\n     * @return claimarr List of Claims id.\r\n     */ \r\n    function getAllClaimsByAddress(address _member) external view returns(uint[] memory claimarr) {\r\n        return allClaimsByAddress[_member];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the number of tokens that has been locked \r\n     * while giving vote to a claim by  Claim Assessors.\r\n     * @param _claimId Claim Id.\r\n     * @return accept Total number of tokens when CA accepts the claim.\r\n     * @return deny Total number of tokens when CA declines the claim.\r\n     */ \r\n    function getClaimsTokenCA(\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint accept,\r\n            uint deny\r\n        )\r\n    {\r\n        return (\r\n            _claimId,\r\n            claimTokensCA[_claimId].accept,\r\n            claimTokensCA[_claimId].deny\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the number of tokens that have been\r\n     * locked while assessing a claim as a member.\r\n     * @param _claimId Claim Id.\r\n     * @return accept Total number of tokens in acceptance of the claim.\r\n     * @return deny Total number of tokens against the claim.\r\n     */ \r\n    function getClaimsTokenMV(\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint accept,\r\n            uint deny\r\n        )\r\n    {\r\n        return (\r\n            _claimId,\r\n            claimTokensMV[_claimId].accept,\r\n            claimTokensMV[_claimId].deny\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total number of votes cast as Claims assessor for/against a given claim\r\n     */ \r\n    function getCaClaimVotesToken(uint _claimId) external view returns(uint claimId, uint cnt) {\r\n        claimId = _claimId;\r\n        cnt = 0;\r\n        for (uint i = 0; i \u003c claimVoteCA[_claimId].length; i++) {\r\n            cnt = cnt.add(allvotes[claimVoteCA[_claimId][i]].tokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total number of tokens cast as a member for/against a given claim  \r\n     */ \r\n    function getMemberClaimVotesToken(\r\n        uint _claimId\r\n    )   \r\n        external\r\n        view\r\n        returns(uint claimId, uint cnt)\r\n    {\r\n        claimId = _claimId;\r\n        cnt = 0;\r\n        for (uint i = 0; i \u003c claimVoteMember[_claimId].length; i++) {\r\n            cnt = cnt.add(allvotes[claimVoteMember[_claimId][i]].tokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Provides information of a vote when given its vote id.\r\n     * @param _voteid Vote Id.\r\n     */\r\n    function getVoteDetails(uint _voteid)\r\n    external view\r\n    returns(\r\n        uint tokens,\r\n        uint claimId,\r\n        int8 verdict,\r\n        bool rewardClaimed\r\n        )\r\n    {\r\n        return (\r\n            allvotes[_voteid].tokens,\r\n            allvotes[_voteid].claimId,\r\n            allvotes[_voteid].verdict,\r\n            allvotes[_voteid].rewardClaimed\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the voter\u0027s address of a given vote id.\r\n     */ \r\n    function getVoterVote(uint _voteid) external view returns(address voter) {\r\n        return allvotes[_voteid].voter;\r\n    }\r\n\r\n    /**\r\n     * @dev Provides information of a Claim when given its claim id.\r\n     * @param _claimId Claim Id.\r\n     */ \r\n    function getClaim(\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint coverId,\r\n            int8 vote,\r\n            uint status,\r\n            uint dateUpd,\r\n            uint state12Count\r\n        )\r\n    {\r\n        return (\r\n            _claimId,\r\n            allClaims[_claimId].coverId,\r\n            claimVote[_claimId],\r\n            claimsStatus[_claimId],\r\n            allClaims[_claimId].dateUpd,\r\n            claimState12Count[_claimId]\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total number of votes of a given claim.\r\n     * @param _claimId Claim Id.\r\n     * @param _ca if 1: votes given by Claim Assessors to a claim,\r\n     * else returns the number of votes of given by Members to a claim.\r\n     * @return len total number of votes for/against a given claim.\r\n     */ \r\n    function getClaimVoteLength(\r\n        uint _claimId,\r\n        uint8 _ca\r\n    )\r\n        external\r\n        view\r\n        returns(uint claimId, uint len)\r\n    {\r\n        claimId = _claimId;\r\n        if (_ca == 1)\r\n            len = claimVoteCA[_claimId].length;\r\n        else\r\n            len = claimVoteMember[_claimId].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the verdict of a vote using claim id and index.\r\n     * @param _ca 1 for vote given as a CA, else for vote given as a member.\r\n     * @return ver 1 if vote was given in favour,-1 if given in against.\r\n     */ \r\n    function getVoteVerdict(\r\n        uint _claimId,\r\n        uint _index,\r\n        uint8 _ca\r\n    )\r\n        external\r\n        view\r\n        returns(int8 ver)\r\n    {\r\n        if (_ca == 1)\r\n            ver = allvotes[claimVoteCA[_claimId][_index]].verdict;\r\n        else\r\n            ver = allvotes[claimVoteMember[_claimId][_index]].verdict;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Number of tokens of a vote using claim id and index.\r\n     * @param _ca 1 for vote given as a CA, else for vote given as a member.\r\n     * @return tok Number of tokens.\r\n     */ \r\n    function getVoteToken(\r\n        uint _claimId,\r\n        uint _index,\r\n        uint8 _ca\r\n    )   \r\n        external\r\n        view\r\n        returns(uint tok)\r\n    {\r\n        if (_ca == 1)\r\n            tok = allvotes[claimVoteCA[_claimId][_index]].tokens;\r\n        else\r\n            tok = allvotes[claimVoteMember[_claimId][_index]].tokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Voter\u0027s address of a vote using claim id and index.\r\n     * @param _ca 1 for vote given as a CA, else for vote given as a member.\r\n     * @return voter Voter\u0027s address.\r\n     */ \r\n    function getVoteVoter(\r\n        uint _claimId,\r\n        uint _index,\r\n        uint8 _ca\r\n    )\r\n        external\r\n        view\r\n        returns(address voter)\r\n    {\r\n        if (_ca == 1)\r\n            voter = allvotes[claimVoteCA[_claimId][_index]].voter;\r\n        else\r\n            voter = allvotes[claimVoteMember[_claimId][_index]].voter;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets total number of Claims created by a user till date.\r\n     * @param _add User\u0027s address.\r\n     */ \r\n    function getUserClaimCount(address _add) external view returns(uint len) {\r\n        len = allClaimsByAddress[_add].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates number of Claims that are in pending state.\r\n     */ \r\n    function getClaimLength() external view returns(uint len) {\r\n        len = allClaims.length.sub(pendingClaimStart);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Number of all the Claims created till date.\r\n     */ \r\n    function actualClaimLength() external view returns(uint len) {\r\n        len = allClaims.length;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets details of a claim.\r\n     * @param _index claim id = pending claim start + given index\r\n     * @param _add User\u0027s address.\r\n     * @return coverid cover against which claim has been submitted.\r\n     * @return claimId Claim  Id.\r\n     * @return voteCA verdict of vote given as a Claim Assessor.  \r\n     * @return voteMV verdict of vote given as a Member.\r\n     * @return statusnumber Status of claim.\r\n     */ \r\n    function getClaimFromNewStart(\r\n        uint _index,\r\n        address _add\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint coverid,\r\n            uint claimId,\r\n            int8 voteCA,\r\n            int8 voteMV,\r\n            uint statusnumber\r\n        )\r\n    {\r\n        uint i = pendingClaimStart.add(_index);\r\n        coverid = allClaims[i].coverId;\r\n        claimId = i;\r\n        if (userClaimVoteCA[_add][i] \u003e 0)\r\n            voteCA = allvotes[userClaimVoteCA[_add][i]].verdict;\r\n        else\r\n            voteCA = 0;\r\n\r\n        if (userClaimVoteMember[_add][i] \u003e 0)\r\n            voteMV = allvotes[userClaimVoteMember[_add][i]].verdict;\r\n        else\r\n            voteMV = 0;\r\n\r\n        statusnumber = claimsStatus[i];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets details of a claim of a user at a given index.  \r\n     */ \r\n    function getUserClaimByIndex(\r\n        uint _index,\r\n        address _add\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint status,\r\n            uint coverid,\r\n            uint claimId\r\n        )\r\n    {\r\n        claimId = allClaimsByAddress[_add][_index];\r\n        status = claimsStatus[claimId];\r\n        coverid = allClaims[claimId].coverId;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Id of all the votes given to a claim.\r\n     * @param _claimId Claim Id.\r\n     * @return ca id of all the votes given by Claim assessors to a claim.\r\n     * @return mv id of all the votes given by members to a claim.\r\n     */ \r\n    function getAllVotesForClaim(\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint[] memory ca,\r\n            uint[] memory mv\r\n        )\r\n    {\r\n        return (_claimId, claimVoteCA[_claimId], claimVoteMember[_claimId]);\r\n    }\r\n\r\n    /** \r\n     * @dev Gets Number of tokens deposit in a vote using\r\n     * Claim assessor\u0027s address and claim id.\r\n     * @return tokens Number of deposited tokens.\r\n     */ \r\n    function getTokensClaim(\r\n        address _of,\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint tokens\r\n        )\r\n    {\r\n        return (_claimId, allvotes[userClaimVoteCA[_of][_claimId]].tokens);\r\n    }\r\n\r\n    /**\r\n     * @param _voter address of the voter.\r\n     * @return lastCAvoteIndex last index till which reward was distributed for CA\r\n     * @return lastMVvoteIndex last index till which reward was distributed for member\r\n     */ \r\n    function getRewardDistributedIndex(\r\n        address _voter\r\n    ) \r\n        external\r\n        view\r\n        returns(\r\n            uint lastCAvoteIndex,\r\n            uint lastMVvoteIndex\r\n        )\r\n    {\r\n        return (\r\n            voterVoteRewardReceived[_voter].lastCAvoteIndex,\r\n            voterVoteRewardReceived[_voter].lastMVvoteIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @param claimid claim id.\r\n     * @return perc_CA reward Percentage for claim assessor\r\n     * @return perc_MV reward Percentage for members\r\n     * @return tokens total tokens to be rewarded \r\n     */ \r\n    function getClaimRewardDetail(\r\n        uint claimid\r\n    ) \r\n        external\r\n        view\r\n        returns(\r\n            uint percCA,\r\n            uint percMV,\r\n            uint tokens\r\n        )\r\n    {\r\n        return (\r\n            claimRewardDetail[claimid].percCA,\r\n            claimRewardDetail[claimid].percMV,\r\n            claimRewardDetail[claimid].tokenToBeDist\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets cover id of a claim.\r\n     */ \r\n    function getClaimCoverId(uint _claimId) external view returns(uint claimId, uint coverid) {\r\n        return (_claimId, allClaims[_claimId].coverId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets total number of tokens staked during voting by Claim Assessors.\r\n     * @param _claimId Claim Id.\r\n     * @param _verdict 1 to get total number of accept tokens, -1 to get total number of deny tokens.\r\n     * @return token token Number of tokens(either accept or deny on the basis of verdict given as parameter).\r\n     */ \r\n    function getClaimVote(uint _claimId, int8 _verdict) external view returns(uint claimId, uint token) {\r\n        claimId = _claimId;\r\n        token = 0;\r\n        for (uint i = 0; i \u003c claimVoteCA[_claimId].length; i++) {\r\n            if (allvotes[claimVoteCA[_claimId][i]].verdict == _verdict)\r\n                token = token.add(allvotes[claimVoteCA[_claimId][i]].tokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets total number of tokens staked during voting by Members.\r\n     * @param _claimId Claim Id.\r\n     * @param _verdict 1 to get total number of accept tokens,\r\n     *  -1 to get total number of deny tokens.\r\n     * @return token token Number of tokens(either accept or \r\n     * deny on the basis of verdict given as parameter).\r\n     */ \r\n    function getClaimMVote(uint _claimId, int8 _verdict) external view returns(uint claimId, uint token) {\r\n        claimId = _claimId;\r\n        token = 0;\r\n        for (uint i = 0; i \u003c claimVoteMember[_claimId].length; i++) {\r\n            if (allvotes[claimVoteMember[_claimId][i]].verdict == _verdict)\r\n                token = token.add(allvotes[claimVoteMember[_claimId][i]].tokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param _voter address  of voteid\r\n     * @param index index to get voteid in CA\r\n     */ \r\n    function getVoteAddressCA(address _voter, uint index) external view returns(uint) {\r\n        return voteAddressCA[_voter][index];\r\n    }\r\n\r\n    /**\r\n     * @param _voter address  of voter\r\n     * @param index index to get voteid in member vote\r\n     */ \r\n    function getVoteAddressMember(address _voter, uint index) external view returns(uint) {\r\n        return voteAddressMember[_voter][index];\r\n    }\r\n\r\n    /**\r\n     * @param _voter address  of voter   \r\n     */ \r\n    function getVoteAddressCALength(address _voter) external view returns(uint) {\r\n        return voteAddressCA[_voter].length;\r\n    }\r\n\r\n    /**\r\n     * @param _voter address  of voter   \r\n     */ \r\n    function getVoteAddressMemberLength(address _voter) external view returns(uint) {\r\n        return voteAddressMember[_voter].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Final result of voting of a claim.\r\n     * @param _claimId Claim id.\r\n     * @return verdict 1 if claim is accepted, -1 if declined.\r\n     */ \r\n    function getFinalVerdict(uint _claimId) external view returns(int8 verdict) {\r\n        return claimVote[_claimId];\r\n    }\r\n\r\n    /**\r\n     * @dev Get number of Claims queued for submission during emergency pause.\r\n     */ \r\n    function getLengthOfClaimSubmittedAtEP() external view returns(uint len) {\r\n        len = claimPause.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the index from which claim needs to be \r\n     * submitted when emergency pause is swithched off.\r\n     */ \r\n    function getFirstClaimIndexToSubmitAfterEP() external view returns(uint indexToSubmit) {\r\n        indexToSubmit = claimPauseLastsubmit;\r\n    }\r\n    \r\n    /**\r\n     * @dev Gets number of Claims to be reopened for voting post emergency pause period.\r\n     */ \r\n    function getLengthOfClaimVotingPause() external view returns(uint len) {\r\n        len = claimPauseVotingEP.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets claim details to be reopened for voting after emergency pause.\r\n     */ \r\n    function getPendingClaimDetailsByIndex(\r\n        uint _index\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint pendingTime,\r\n            bool voting\r\n        )\r\n    {\r\n        claimId = claimPauseVotingEP[_index].claimid;\r\n        pendingTime = claimPauseVotingEP[_index].pendingTime;\r\n        voting = claimPauseVotingEP[_index].voting;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the index from which claim needs to be reopened when emergency pause is swithched off.\r\n     */ \r\n    function getFirstClaimIndexToStartVotingAfterEP() external view returns(uint firstindex) {\r\n        firstindex = claimStartVotingFirstIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates Uint Parameters of a code\r\n     * @param code whose details we want to update\r\n     * @param val value to set\r\n     */\r\n    function updateUintParameters(bytes8 code, uint val) public {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        if (code == \"CAMAXVT\") {\r\n            _setMaxVotingTime(val * 1 hours);\r\n\r\n        } else if (code == \"CAMINVT\") {\r\n\r\n            _setMinVotingTime(val * 1 hours);\r\n\r\n        } else if (code == \"CAPRETRY\") {\r\n\r\n            _setPayoutRetryTime(val * 1 hours);\r\n\r\n        } else if (code == \"CADEPT\") {\r\n\r\n            _setClaimDepositTime(val * 1 days);\r\n\r\n        } else if (code == \"CAREWPER\") {\r\n\r\n            _setClaimRewardPerc(val);\r\n\r\n        } else if (code == \"CAMINTH\") {\r\n\r\n            _setMinVoteThreshold(val);\r\n\r\n        } else if (code == \"CAMAXTH\") {\r\n\r\n            _setMaxVoteThreshold(val);\r\n\r\n        } else if (code == \"CACONPER\") {\r\n\r\n            _setMajorityConsensus(val);\r\n\r\n        } else if (code == \"CAPAUSET\") {\r\n            _setPauseDaysCA(val * 1 days);\r\n        } else {\r\n\r\n            revert(\"Invalid param code\");\r\n        }\r\n    \r\n    }\r\n\r\n    /**\r\n     * @dev Iupgradable Interface to update dependent contract address\r\n     */\r\n    function changeDependentContractAddress() public onlyInternal {}\r\n\r\n    /**\r\n     * @dev Adds status under which a claim can lie.\r\n     * @param percCA reward percentage for claim assessor\r\n     * @param percMV reward percentage for members\r\n     */\r\n    function _pushStatus(uint percCA, uint percMV) internal {\r\n        rewardStatus.push(ClaimRewardStatus(percCA, percMV));\r\n    }\r\n\r\n    /**\r\n     * @dev adds reward incentive for all possible claim status for Claim assessors and members\r\n     */\r\n    function _addRewardIncentive() internal {\r\n        _pushStatus(0, 0); //0  Pending-Claim Assessor Vote\r\n        _pushStatus(0, 0); //1 Pending-Claim Assessor Vote Denied, Pending Member Vote\r\n        _pushStatus(0, 0); //2 Pending-CA Vote Threshold not Reached Accept, Pending Member Vote\r\n        _pushStatus(0, 0); //3 Pending-CA Vote Threshold not Reached Deny, Pending Member Vote\r\n        _pushStatus(0, 0); //4 Pending-CA Consensus not reached Accept, Pending Member Vote\r\n        _pushStatus(0, 0); //5 Pending-CA Consensus not reached Deny, Pending Member Vote\r\n        _pushStatus(100, 0); //6 Final-Claim Assessor Vote Denied\r\n        _pushStatus(100, 0); //7 Final-Claim Assessor Vote Accepted\r\n        _pushStatus(0, 100); //8 Final-Claim Assessor Vote Denied, MV Accepted\r\n        _pushStatus(0, 100); //9 Final-Claim Assessor Vote Denied, MV Denied\r\n        _pushStatus(0, 0); //10 Final-Claim Assessor Vote Accept, MV Nodecision\r\n        _pushStatus(0, 0); //11 Final-Claim Assessor Vote Denied, MV Nodecision\r\n        _pushStatus(0, 0); //12 Claim Accepted Payout Pending\r\n        _pushStatus(0, 0); //13 Claim Accepted No Payout \r\n        _pushStatus(0, 0); //14 Claim Accepted Payout Done\r\n    }\r\n\r\n    /**\r\n     * @dev Sets Maximum time(in seconds) for which claim assessment voting is open\r\n     */ \r\n    function _setMaxVotingTime(uint _time) internal {\r\n        maxVotingTime = _time;\r\n    }\r\n\r\n    /**\r\n     *  @dev Sets Minimum time(in seconds) for which claim assessment voting is open\r\n     */ \r\n    function _setMinVotingTime(uint _time) internal {\r\n        minVotingTime = _time;\r\n    }\r\n\r\n    /**\r\n     *  @dev Sets Minimum vote threshold required\r\n     */ \r\n    function _setMinVoteThreshold(uint val) internal {\r\n        minVoteThreshold = val;\r\n    }\r\n\r\n    /**\r\n     *  @dev Sets Maximum vote threshold required\r\n     */ \r\n    function _setMaxVoteThreshold(uint val) internal {\r\n        maxVoteThreshold = val;\r\n    }\r\n    \r\n    /**\r\n     *  @dev Sets the value considered as Majority Consenus in voting\r\n     */ \r\n    function _setMajorityConsensus(uint val) internal {\r\n        majorityConsensus = val;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the payout retry time\r\n     */ \r\n    function _setPayoutRetryTime(uint _time) internal {\r\n        payoutRetryTime = _time;\r\n    }\r\n\r\n    /**\r\n     *  @dev Sets percentage of reward given for claim assessment\r\n     */ \r\n    function _setClaimRewardPerc(uint _val) internal {\r\n\r\n        claimRewardPerc = _val;\r\n    }\r\n  \r\n    /** \r\n     * @dev Sets the time for which claim is deposited.\r\n     */ \r\n    function _setClaimDepositTime(uint _time) internal {\r\n\r\n        claimDepositTime = _time;\r\n    }\r\n\r\n    /**\r\n     *  @dev Sets number of days claim assessment will be paused\r\n     */ \r\n    function _setPauseDaysCA(uint val) internal {\r\n        pauseDaysCA = val;\r\n    }\r\n}\r\n"},"ClaimsReward.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\n//Claims Reward Contract contains the functions for calculating number of tokens\r\n// that will get rewarded, unlocked or burned depending upon the status of claim.\r\n\r\npragma solidity 0.5.7;\r\n\r\nimport \"./ClaimsData.sol\";\r\nimport \"./Governance.sol\";\r\nimport \"./Claims.sol\";\r\nimport \"./Pool1.sol\";\r\n\r\n\r\ncontract ClaimsReward is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    NXMToken internal tk;\r\n    TokenController internal tc;\r\n    TokenFunctions internal tf;\r\n    TokenData internal td;\r\n    QuotationData internal qd;\r\n    Claims internal c1;\r\n    ClaimsData internal cd;\r\n    Pool1 internal p1;\r\n    Pool2 internal p2;\r\n    PoolData internal pd;\r\n    Governance internal gv;\r\n\r\n    uint private constant DECIMAL1E18 = uint(10) ** 18;\r\n  \r\n    function changeDependentContractAddress() public onlyInternal {\r\n        c1 = Claims(ms.getLatestAddress(\"CL\"));\r\n        cd = ClaimsData(ms.getLatestAddress(\"CD\"));\r\n        tk = NXMToken(ms.tokenAddress());\r\n        tc = TokenController(ms.getLatestAddress(\"TC\"));\r\n        td = TokenData(ms.getLatestAddress(\"TD\"));\r\n        tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\r\n        p1 = Pool1(ms.getLatestAddress(\"P1\"));\r\n        p2 = Pool2(ms.getLatestAddress(\"P2\"));\r\n        pd = PoolData(ms.getLatestAddress(\"PD\"));\r\n        qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n        gv = Governance(ms.getLatestAddress(\"GV\"));\r\n    }\r\n\r\n    /// @dev Decides the next course of action for a given claim.\r\n    function changeClaimStatus(uint claimid) public checkPause onlyInternal {\r\n\r\n        uint coverid;\r\n        (, coverid) = cd.getClaimCoverId(claimid);\r\n\r\n        uint status;\r\n        (, status) = cd.getClaimStatusNumber(claimid);\r\n\r\n        // when current status is \"Pending-Claim Assessor Vote\"\r\n        if (status == 0) {\r\n            _changeClaimStatusCA(claimid, coverid, status);\r\n        } else if (status \u003e= 1 \u0026\u0026 status \u003c= 5) { \r\n            _changeClaimStatusMV(claimid, coverid, status);\r\n        } else if (status == 12) { // when current status is \"Claim Accepted Payout Pending\"\r\n            bool succ = p1.sendClaimPayout(coverid, claimid, qd.getCoverSumAssured(coverid).mul(DECIMAL1E18), \r\n            qd.getCoverMemberAddress(coverid), qd.getCurrencyOfCover(coverid));\r\n            if (succ) \r\n                c1.setClaimStatus(claimid, 14);\r\n        }\r\n        c1.changePendingClaimStart();\r\n    }\r\n\r\n    /// @dev Amount of tokens to be rewarded to a user for a particular vote id.\r\n    /// @param check 1 -\u003e CA vote, else member vote\r\n    /// @param voteid vote id for which reward has to be Calculated\r\n    /// @param flag if 1 calculate even if claimed,else don\u0027t calculate if already claimed\r\n    /// @return tokenCalculated reward to be given for vote id\r\n    /// @return lastClaimedCheck true if final verdict is still pending for that voteid\r\n    /// @return tokens number of tokens locked under that voteid\r\n    /// @return perc percentage of reward to be given.\r\n    function getRewardToBeGiven(\r\n        uint check,\r\n        uint voteid,\r\n        uint flag\r\n    ) \r\n        public\r\n        view\r\n        returns (\r\n            uint tokenCalculated,\r\n            bool lastClaimedCheck,\r\n            uint tokens,\r\n            uint perc\r\n        )\r\n\r\n    {\r\n        uint claimId;\r\n        int8 verdict;\r\n        bool claimed;\r\n        uint tokensToBeDist;\r\n        uint totalTokens;\r\n        (tokens, claimId, verdict, claimed) = cd.getVoteDetails(voteid);\r\n        lastClaimedCheck = false;\r\n        int8 claimVerdict = cd.getFinalVerdict(claimId);\r\n        if (claimVerdict == 0)\r\n            lastClaimedCheck = true;\r\n\r\n        if (claimVerdict == verdict \u0026\u0026 (claimed == false || flag == 1)) {\r\n            \r\n            if (check == 1) {\r\n                (perc, , tokensToBeDist) = cd.getClaimRewardDetail(claimId);\r\n            } else {\r\n                (, perc, tokensToBeDist) = cd.getClaimRewardDetail(claimId);\r\n            }\r\n                \r\n            if (perc \u003e 0) {\r\n                if (check == 1) {\r\n                    if (verdict == 1) {\r\n                        (, totalTokens, ) = cd.getClaimsTokenCA(claimId);\r\n                    } else {\r\n                        (, , totalTokens) = cd.getClaimsTokenCA(claimId);\r\n                    }\r\n                } else {\r\n                    if (verdict == 1) {\r\n                        (, totalTokens, ) = cd.getClaimsTokenMV(claimId);\r\n                    }else {\r\n                        (, , totalTokens) = cd.getClaimsTokenMV(claimId);\r\n                    }\r\n                }\r\n                tokenCalculated = (perc.mul(tokens).mul(tokensToBeDist)).div(totalTokens.mul(100));\r\n                \r\n                \r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Transfers all tokens held by contract to a new contract in case of upgrade.\r\n    function upgrade(address _newAdd) public onlyInternal {\r\n        uint amount = tk.balanceOf(address(this));\r\n        if (amount \u003e 0)\r\n            require(tk.transfer(_newAdd, amount));\r\n        \r\n    }\r\n\r\n    /// @dev Total reward in token due for claim by a user.\r\n    /// @return total total number of tokens\r\n    function getRewardToBeDistributedByUser(address _add) public view returns(uint total) {\r\n        uint lengthVote = cd.getVoteAddressCALength(_add);\r\n        uint lastIndexCA;\r\n        uint lastIndexMV;\r\n        uint tokenForVoteId;\r\n        uint voteId;\r\n        (lastIndexCA, lastIndexMV) = cd.getRewardDistributedIndex(_add);\r\n\r\n        for (uint i = lastIndexCA; i \u003c lengthVote; i++) {\r\n            voteId = cd.getVoteAddressCA(_add, i);\r\n            (tokenForVoteId, , , ) = getRewardToBeGiven(1, voteId, 0);\r\n            total = total.add(tokenForVoteId);\r\n        }\r\n\r\n        lengthVote = cd.getVoteAddressMemberLength(_add);\r\n\r\n        for (uint j = lastIndexMV; j \u003c lengthVote; j++) {\r\n            voteId = cd.getVoteAddressMember(_add, j);\r\n            (tokenForVoteId, , , ) = getRewardToBeGiven(0, voteId, 0);\r\n            total = total.add(tokenForVoteId);\r\n        }\r\n        return (total);\r\n    }\r\n\r\n    /// @dev Gets reward amount and claiming status for a given claim id.\r\n    /// @return reward amount of tokens to user.\r\n    /// @return claimed true if already claimed false if yet to be claimed.\r\n    function getRewardAndClaimedStatus(uint check, uint claimId) public view returns(uint reward, bool claimed) {\r\n        uint voteId;\r\n        uint claimid;\r\n        uint lengthVote;\r\n\r\n        if (check == 1) {\r\n            lengthVote = cd.getVoteAddressCALength(msg.sender);\r\n            for (uint i = 0; i \u003c lengthVote; i++) {\r\n                voteId = cd.getVoteAddressCA(msg.sender, i);\r\n                (, claimid, , claimed) = cd.getVoteDetails(voteId);\r\n                if (claimid == claimId) break;\r\n            }\r\n        } else {\r\n            lengthVote = cd.getVoteAddressMemberLength(msg.sender);\r\n            for (uint j = 0; j \u003c lengthVote; j++) {\r\n                voteId = cd.getVoteAddressMember(msg.sender, j);\r\n                (, claimid, , claimed) = cd.getVoteDetails(voteId);\r\n                if (claimid == claimId) break;\r\n            }\r\n        }\r\n        (reward, , , ) = getRewardToBeGiven(check, voteId, 1);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Function used to claim all pending rewards on a list of proposals.\r\n     */\r\n    function claimAllPendingReward(uint records) public isMemberAndcheckPause {\r\n        _claimRewardToBeDistributed(records);\r\n        _claimStakeCommission(records);\r\n        tf.unlockStakerUnlockableTokens(msg.sender); \r\n        uint gvReward = gv.claimReward(msg.sender, records);\r\n        if (gvReward \u003e 0) {\r\n            require(tk.transfer(msg.sender, gvReward));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Function used to get pending rewards of a particular user address.\r\n     * @param _add user address.\r\n     * @return total reward amount of the user\r\n     */\r\n    function getAllPendingRewardOfUser(address _add) public view returns(uint total) {\r\n        uint caReward = getRewardToBeDistributedByUser(_add);\r\n        uint commissionEarned = td.getStakerTotalEarnedStakeCommission(_add);\r\n        uint commissionReedmed = td.getStakerTotalReedmedStakeCommission(_add);\r\n        uint unlockableStakedTokens = tf.getStakerAllUnlockableStakedTokens(_add);\r\n        uint governanceReward = gv.getPendingReward(_add);\r\n        total = caReward.add(unlockableStakedTokens).add(commissionEarned.\r\n        sub(commissionReedmed)).add(governanceReward);\r\n    }\r\n\r\n    /// @dev Rewards/Punishes users who  participated in Claims assessment.\r\n    //             Unlocking and burning of the tokens will also depend upon the status of claim.\r\n    /// @param claimid Claim Id.\r\n    function _rewardAgainstClaim(uint claimid, uint coverid, uint sumAssured, uint status) internal {\r\n        uint premiumNXM = qd.getCoverPremiumNXM(coverid);\r\n        bytes4 curr = qd.getCurrencyOfCover(coverid);\r\n        uint distributableTokens = premiumNXM.mul(cd.claimRewardPerc()).div(100);//  20% of premium\r\n            \r\n        uint percCA;\r\n        uint percMV;\r\n\r\n        (percCA, percMV) = cd.getRewardStatus(status);\r\n        cd.setClaimRewardDetail(claimid, percCA, percMV, distributableTokens);\r\n        if (percCA \u003e 0 || percMV \u003e 0) {\r\n            tc.mint(address(this), distributableTokens);\r\n        }\r\n\r\n        if (status == 6 || status == 9 || status == 11) {\r\n            cd.changeFinalVerdict(claimid, -1);\r\n            td.setDepositCN(coverid, false); // Unset flag\r\n            tf.burnDepositCN(coverid); // burn Deposited CN\r\n            \r\n            pd.changeCurrencyAssetVarMin(curr, pd.getCurrencyAssetVarMin(curr).sub(sumAssured));\r\n            p2.internalLiquiditySwap(curr);\r\n            \r\n        } else if (status == 7 || status == 8 || status == 10) {\r\n            cd.changeFinalVerdict(claimid, 1);\r\n            td.setDepositCN(coverid, false); // Unset flag\r\n            tf.unlockCN(coverid);\r\n            p1.sendClaimPayout(coverid, claimid, sumAssured, qd.getCoverMemberAddress(coverid), curr); //send payout\r\n        } \r\n    }\r\n\r\n    /// @dev Computes the result of Claim Assessors Voting for a given claim id.\r\n    function _changeClaimStatusCA(uint claimid, uint coverid, uint status) internal {\r\n        // Check if voting should be closed or not\r\n        if (c1.checkVoteClosing(claimid) == 1) {\r\n            uint caTokens = c1.getCATokens(claimid, 0); // converted in cover currency. \r\n            uint accept;\r\n            uint deny;\r\n            uint acceptAndDeny;\r\n            bool rewardOrPunish;\r\n            uint sumAssured;\r\n            (, accept) = cd.getClaimVote(claimid, 1);\r\n            (, deny) = cd.getClaimVote(claimid, -1);\r\n            acceptAndDeny = accept.add(deny);\r\n            accept = accept.mul(100);\r\n            deny = deny.mul(100);\r\n\r\n            if (caTokens == 0) {\r\n                status = 3;\r\n            } else {\r\n                sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\r\n                // Min threshold reached tokens used for voting \u003e 5* sum assured  \r\n                if (caTokens \u003e sumAssured.mul(5)) {\r\n\r\n                    if (accept.div(acceptAndDeny) \u003e 70) {\r\n                        status = 7;\r\n                        qd.changeCoverStatusNo(coverid, uint8(QuotationData.CoverStatus.ClaimAccepted));\r\n                        rewardOrPunish = true;\r\n                    } else if (deny.div(acceptAndDeny) \u003e 70) {\r\n                        status = 6;\r\n                        qd.changeCoverStatusNo(coverid, uint8(QuotationData.CoverStatus.ClaimDenied));\r\n                        rewardOrPunish = true;\r\n                    } else if (accept.div(acceptAndDeny) \u003e deny.div(acceptAndDeny)) {\r\n                        status = 4;\r\n                    } else {\r\n                        status = 5;\r\n                    }\r\n\r\n                } else {\r\n\r\n                    if (accept.div(acceptAndDeny) \u003e deny.div(acceptAndDeny)) {\r\n                        status = 2;\r\n                    } else {\r\n                        status = 3;\r\n                    }\r\n                }\r\n            }\r\n\r\n            c1.setClaimStatus(claimid, status);\r\n\r\n            if (rewardOrPunish)\r\n                _rewardAgainstClaim(claimid, coverid, sumAssured, status);\r\n        }\r\n    }\r\n\r\n    /// @dev Computes the result of Member Voting for a given claim id.\r\n    function _changeClaimStatusMV(uint claimid, uint coverid, uint status) internal {\r\n\r\n        // Check if voting should be closed or not\r\n        if (c1.checkVoteClosing(claimid) == 1) {\r\n            uint8 coverStatus;\r\n            uint statusOrig = status;\r\n            uint mvTokens = c1.getCATokens(claimid, 1); // converted in cover currency. \r\n\r\n            // If tokens used for acceptance \u003e50%, claim is accepted\r\n            uint sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\r\n            uint thresholdUnreached = 0;\r\n            // Minimum threshold for member voting is reached only when \r\n            // value of tokens used for voting \u003e 5* sum assured of claim id\r\n            if (mvTokens \u003c sumAssured.mul(5))\r\n                thresholdUnreached = 1;\r\n\r\n            uint accept;\r\n            (, accept) = cd.getClaimMVote(claimid, 1);\r\n            uint deny;\r\n            (, deny) = cd.getClaimMVote(claimid, -1);\r\n\r\n            if (accept.add(deny) \u003e 0) {\r\n                if (accept.mul(100).div(accept.add(deny)) \u003e= 50 \u0026\u0026 statusOrig \u003e 1 \u0026\u0026 \r\n                    statusOrig \u003c= 5 \u0026\u0026 thresholdUnreached == 0) {\r\n                    status = 8;\r\n                    coverStatus = uint8(QuotationData.CoverStatus.ClaimAccepted);\r\n                } else if (deny.mul(100).div(accept.add(deny)) \u003e= 50 \u0026\u0026 statusOrig \u003e 1 \u0026\u0026\r\n                    statusOrig \u003c= 5 \u0026\u0026 thresholdUnreached == 0) {\r\n                    status = 9;\r\n                    coverStatus = uint8(QuotationData.CoverStatus.ClaimDenied);\r\n                }\r\n            }\r\n            \r\n            if (thresholdUnreached == 1 \u0026\u0026 (statusOrig == 2 || statusOrig == 4)) {\r\n                status = 10;\r\n                coverStatus = uint8(QuotationData.CoverStatus.ClaimAccepted);\r\n            } else if (thresholdUnreached == 1 \u0026\u0026 (statusOrig == 5 || statusOrig == 3 || statusOrig == 1)) {\r\n                status = 11;\r\n                coverStatus = uint8(QuotationData.CoverStatus.ClaimDenied);\r\n            }\r\n\r\n            c1.setClaimStatus(claimid, status);\r\n            qd.changeCoverStatusNo(coverid, uint8(coverStatus));\r\n            // Reward/Punish Claim Assessors and Members who participated in Claims assessment\r\n            _rewardAgainstClaim(claimid, coverid, sumAssured, status);\r\n        }\r\n    }\r\n\r\n    /// @dev Allows a user to claim all pending  Claims assessment rewards.\r\n    function _claimRewardToBeDistributed(uint _records) internal {\r\n        uint lengthVote = cd.getVoteAddressCALength(msg.sender);\r\n        uint voteid;\r\n        uint lastIndex;\r\n        (lastIndex, ) = cd.getRewardDistributedIndex(msg.sender);\r\n        uint total = 0;\r\n        uint tokenForVoteId = 0;\r\n        bool lastClaimedCheck;\r\n        uint _days = td.lockCADays();\r\n        bool claimed;   \r\n        uint counter = 0;\r\n        uint claimId;\r\n        uint perc;\r\n        uint i;\r\n        uint lastClaimed = lengthVote;\r\n\r\n        for (i = lastIndex; i \u003c lengthVote \u0026\u0026 counter \u003c _records; i++) {\r\n            voteid = cd.getVoteAddressCA(msg.sender, i);\r\n            (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\r\n            if (lastClaimed == lengthVote \u0026\u0026 lastClaimedCheck == true)\r\n                lastClaimed = i;\r\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\r\n\r\n            if (perc \u003e 0 \u0026\u0026 !claimed) {\r\n                counter++;\r\n                cd.setRewardClaimed(voteid, true);\r\n            } else if (perc == 0 \u0026\u0026 cd.getFinalVerdict(claimId) != 0 \u0026\u0026 !claimed) {\r\n                (perc, , ) = cd.getClaimRewardDetail(claimId);\r\n                if (perc == 0)\r\n                    counter++;\r\n                cd.setRewardClaimed(voteid, true);\r\n            }\r\n            if (tokenForVoteId \u003e 0)\r\n                total = tokenForVoteId.add(total);\r\n        }\r\n        if(lastClaimed == lengthVote)\r\n            cd.setRewardDistributedIndexCA(msg.sender, i);\r\n        else\r\n            cd.setRewardDistributedIndexCA(msg.sender, lastClaimed);\r\n        lengthVote = cd.getVoteAddressMemberLength(msg.sender);\r\n        lastClaimed = lengthVote;\r\n        _days = _days.mul(counter);\r\n        if (tc.tokensLockedAtTime(msg.sender, \"CLA\", now) \u003e 0)\r\n            tc.reduceLock(msg.sender, \"CLA\", _days);\r\n        (, lastIndex) = cd.getRewardDistributedIndex(msg.sender);\r\n        lastClaimed = lengthVote;\r\n        counter = 0;\r\n        for (i = lastIndex; i \u003c lengthVote \u0026\u0026 counter \u003c _records; i++) {\r\n            voteid = cd.getVoteAddressMember(msg.sender, i);\r\n            (tokenForVoteId, lastClaimedCheck, , ) = getRewardToBeGiven(0, voteid, 0);\r\n            if (lastClaimed == lengthVote \u0026\u0026 lastClaimedCheck == true)\r\n                lastClaimed = i;\r\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\r\n            if (claimed == false \u0026\u0026 cd.getFinalVerdict(claimId) != 0){\r\n                cd.setRewardClaimed(voteid, true);\r\n                counter++;\r\n            }\r\n            if (tokenForVoteId \u003e 0)\r\n                total = tokenForVoteId.add(total);\r\n        }\r\n        if (total \u003e 0)\r\n            require(tk.transfer(msg.sender, total));\r\n        if(lastClaimed == lengthVote) \r\n            cd.setRewardDistributedIndexMV(msg.sender, i);\r\n        else\r\n            cd.setRewardDistributedIndexMV(msg.sender, lastClaimed);\r\n    }\r\n\r\n    /**\r\n     * @dev Function used to claim the commission earned by the staker.\r\n     */\r\n    function _claimStakeCommission(uint _records) internal {\r\n        uint total=0;\r\n        uint len = td.getStakerStakedContractLength(msg.sender);\r\n        uint lastCompletedStakeCommission = td.lastCompletedStakeCommission(msg.sender);\r\n        uint commissionEarned;\r\n        uint commissionRedeemed;\r\n        uint maxCommission;\r\n        uint lastCommisionRedeemed = len;\r\n        uint counter;\r\n        uint i;\r\n\r\n        for (i = lastCompletedStakeCommission; i \u003c len \u0026\u0026 counter \u003c _records; i++) {\r\n            commissionRedeemed = td.getStakerRedeemedStakeCommission(msg.sender, i);\r\n            commissionEarned = td.getStakerEarnedStakeCommission(msg.sender, i);\r\n            maxCommission = td.getStakerInitialStakedAmountOnContract(\r\n                msg.sender, i).mul(td.stakerMaxCommissionPer()).div(100);\r\n            if (lastCommisionRedeemed == len \u0026\u0026 maxCommission != commissionEarned)\r\n                lastCommisionRedeemed = i;\r\n            td.pushRedeemedStakeCommissions(msg.sender, i, commissionEarned.sub(commissionRedeemed));\r\n            total = total.add(commissionEarned.sub(commissionRedeemed));\r\n            counter++;\r\n        }\r\n            if(lastCommisionRedeemed == len)\r\n                td.setLastCompletedStakeCommissionIndex(msg.sender, i);\r\n            else\r\n                td.setLastCompletedStakeCommissionIndex(msg.sender, lastCommisionRedeemed); \r\n\r\n        if (total \u003e 0) \r\n            require(tk.transfer(msg.sender, total)); //solhint-disable-line\r\n        \r\n    }\r\n}\r\n"},"Governance.sol":{"content":"// /* Copyright (C) 2017 GovBlocks.io\r\n\r\n//   This program is free software: you can redistribute it and/or modify\r\n//     it under the terms of the GNU General Public License as published by\r\n//     the Free Software Foundation, either version 3 of the License, or\r\n//     (at your option) any later version.\r\n\r\n//   This program is distributed in the hope that it will be useful,\r\n//     but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n//     GNU General Public License for more details.\r\n\r\n//   You should have received a copy of the GNU General Public License\r\n//     along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\nimport \"./ProposalCategory.sol\";\r\nimport \"./MemberRoles.sol\";\r\nimport \"./IGovernance.sol\";\r\n\r\n\r\ncontract Governance is IGovernance, Iupgradable {\r\n\r\n    using SafeMath for uint;\r\n\r\n    enum ProposalStatus { \r\n        Draft,\r\n        AwaitingSolution,\r\n        VotingStarted,\r\n        Accepted,\r\n        Rejected,\r\n        Majority_Not_Reached_But_Accepted,\r\n        Denied\r\n    }\r\n\r\n    struct ProposalData {\r\n        uint propStatus;\r\n        uint finalVerdict;\r\n        uint category;\r\n        // uint totalVoteValue;\r\n        // uint majVoteValue;\r\n        uint commonIncentive;\r\n        uint dateUpd;\r\n        address owner;\r\n    }\r\n\r\n    struct ProposalVote {\r\n        address voter;\r\n        // uint64 solutionChosen;\r\n        uint proposalId;\r\n        uint dateAdd;\r\n        // uint voteValue;\r\n    }\r\n\r\n    struct VoteTally {\r\n        mapping(uint=\u003euint) memberVoteValue;\r\n        mapping(uint=\u003euint) abVoteValue;\r\n        uint voters;\r\n    }\r\n\r\n    struct DelegateVote {\r\n        address follower;\r\n        address leader;\r\n        uint lastUpd;\r\n    }\r\n\r\n    // ProposalStruct[] internal allProposal;\r\n    ProposalVote[] internal allVotes;\r\n    DelegateVote[] public allDelegation;\r\n\r\n    mapping(uint =\u003e ProposalData) internal allProposalData;\r\n    mapping(uint =\u003e bytes[]) internal allProposalSolutions;\r\n    mapping(address =\u003e uint[]) internal allVotesByMember;\r\n    mapping(uint =\u003e mapping(address =\u003e bool)) public rewardClaimed; //voteid-\u003emember-\u003ereward claimed\r\n    mapping (address =\u003e mapping(uint =\u003e uint)) public memberProposalVote;\r\n    mapping (address =\u003e uint) public followerDelegation;\r\n    mapping (address =\u003e uint) internal followerCount;\r\n    mapping (address =\u003e uint[]) internal leaderDelegation;\r\n    mapping (uint =\u003e VoteTally) public proposalVoteTally;\r\n    mapping (address =\u003e bool) public isOpenForDelegation;\r\n    mapping (address =\u003e uint) public lastRewardClaimed;\r\n    \r\n\r\n    bool internal constructorCheck;\r\n    uint public tokenHoldingTime;\r\n    uint internal roleIdAllowedToCatgorize;\r\n    uint internal maxVoteWeigthPer;\r\n    uint internal specialResolutionMajPerc;\r\n    uint internal maxFollowers;\r\n    uint internal totalProposals;\r\n    uint internal maxDraftTime;\r\n\r\n    MemberRoles internal memberRole;\r\n    ProposalCategory internal proposalCategory;\r\n    TokenController internal tokenInstance;\r\n    MemberRoles internal mr;\r\n\r\n    modifier onlyProposalOwner(uint _proposalId) {\r\n        require(msg.sender == allProposalData[_proposalId].owner, \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier voteNotStarted(uint _proposalId) {\r\n        require(allProposalData[_proposalId].propStatus \u003c uint(ProposalStatus.VotingStarted));\r\n        _;\r\n    }\r\n\r\n    modifier isAllowed(uint _categoryId) {\r\n        require(allowedToCreateProposal(_categoryId), \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier isAllowedToCategorize() {\r\n        require(memberRole.checkRole(msg.sender, roleIdAllowedToCatgorize), \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier checkPendingRewards {\r\n        require(getPendingReward(msg.sender) == 0, \"Claim pending rewards\");\r\n        _;\r\n    }\r\n\r\n    event ProposalCategorized(\r\n        uint indexed proposalId,\r\n        address indexed categorizedBy,\r\n        uint categoryId\r\n    );\r\n    \r\n    /**\r\n     * @dev to remove delegation of an address.\r\n     * @param _add address to undelegate.\r\n     */\r\n    function removeDelegation(address _add) external onlyInternal {\r\n        _unDelegate(_add);\r\n    }\r\n\r\n    /// @dev Creates a new proposal\r\n    /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n    /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal\u0027s Objective\r\n    function createProposal(\r\n        string calldata _proposalTitle, \r\n        string calldata _proposalSD, \r\n        string calldata _proposalDescHash, \r\n        uint _categoryId\r\n    ) \r\n        external isAllowed(_categoryId)\r\n    {\r\n        require(ms.isMember(msg.sender), \"Not Member\");\r\n\r\n        _createProposal(_proposalTitle, _proposalSD, _proposalDescHash, _categoryId);\r\n    }\r\n\r\n    /// @dev Edits the details of an existing proposal\r\n    /// @param _proposalId Proposal id that details needs to be updated\r\n    /// @param _proposalDescHash Proposal description hash having long and short description of proposal.\r\n    function updateProposal(\r\n        uint _proposalId, \r\n        string calldata _proposalTitle, \r\n        string calldata _proposalSD, \r\n        string calldata _proposalDescHash\r\n    ) \r\n        external onlyProposalOwner(_proposalId)\r\n    {\r\n        require(\r\n            allProposalSolutions[_proposalId].length \u003c 2,\r\n            \"Solution submitted\"\r\n        );\r\n        allProposalData[_proposalId].propStatus = uint(ProposalStatus.Draft);\r\n        allProposalData[_proposalId].category = 0;\r\n        allProposalData[_proposalId].commonIncentive = 0;\r\n        emit Proposal(\r\n            allProposalData[_proposalId].owner,\r\n            _proposalId,\r\n            now,\r\n            _proposalTitle, \r\n            _proposalSD, \r\n            _proposalDescHash\r\n        );\r\n    }\r\n\r\n    /// @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\r\n    function categorizeProposal(\r\n        uint _proposalId,\r\n        uint _categoryId,\r\n        uint _incentive\r\n    )\r\n        external\r\n        voteNotStarted(_proposalId) isAllowedToCategorize\r\n    {\r\n        _categorizeProposal(_proposalId, _categoryId, _incentive);\r\n    }\r\n\r\n    /// @dev Initiates add solution\r\n    //To implement the governance interface\r\n    function addSolution(uint, string calldata, bytes calldata) external {\r\n    }\r\n\r\n    /// @dev Opens proposal for voting\r\n    //To implement the governance interface\r\n    function openProposalForVoting(uint) external {\r\n    }\r\n\r\n    /// @dev Submit proposal with solution\r\n    /// @param _proposalId Proposal id\r\n    /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n    function submitProposalWithSolution(\r\n        uint _proposalId, \r\n        string calldata _solutionHash, \r\n        bytes calldata _action\r\n    ) \r\n        external\r\n        onlyProposalOwner(_proposalId)\r\n    {\r\n        _proposalSubmission(_proposalId, _solutionHash, _action);\r\n    }\r\n\r\n    /// @dev Creates a new proposal with solution\r\n    /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n    /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal\u0027s Objective\r\n    /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n    function createProposalwithSolution(\r\n        string calldata _proposalTitle, \r\n        string calldata _proposalSD, \r\n        string calldata _proposalDescHash,\r\n        uint _categoryId, \r\n        string calldata _solutionHash, \r\n        bytes calldata _action\r\n    ) \r\n        external isAllowed(_categoryId)\r\n    {\r\n\r\n        uint proposalId = totalProposals;\r\n\r\n        _createProposal(_proposalTitle, _proposalSD, _proposalDescHash, _categoryId);\r\n\r\n        _proposalSubmission(\r\n            proposalId,\r\n            _solutionHash,\r\n            _action\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev used to submit vote on a proposal.\r\n     * @param _proposalId to vote upon.\r\n     * @param _solutionChosen is the chosen vote.\r\n     */\r\n    function submitVote(uint _proposalId, uint _solutionChosen) external {\r\n        // require(addressProposalVote[msg.sender][_proposalId] == 0, \"Already voted\");\r\n\r\n        require(allProposalData[_proposalId].propStatus == \r\n        uint(Governance.ProposalStatus.VotingStarted), \"Not allowed\");\r\n\r\n        require(_solutionChosen \u003c= allProposalSolutions[_proposalId].length, \"Solution doesn\u0027t exist\");\r\n\r\n\r\n        _submitVote(_proposalId, _solutionChosen);\r\n    }\r\n\r\n    /**\r\n     * @dev used to close a proposal.\r\n     * @param _proposalId of proposal to be closed.\r\n     */\r\n    function closeProposal(uint _proposalId) external {\r\n        uint category = allProposalData[_proposalId].category;\r\n        \r\n        \r\n        uint _memberRole;\r\n        if (allProposalData[_proposalId].dateUpd.add(maxDraftTime) \u003c= now \u0026\u0026 \r\n            allProposalData[_proposalId].propStatus \u003c uint(ProposalStatus.VotingStarted)) {\r\n            _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n        } else {\r\n            require(canCloseProposal(_proposalId) == 1, \"Cannot close\");\r\n            (, _memberRole, , , , , ) = proposalCategory.category(allProposalData[_proposalId].category);\r\n            if (_memberRole == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n                _closeABVote(_proposalId, category, _memberRole);\r\n            } else {\r\n                _closeMemberVote(_proposalId, category);\r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    /**\r\n     * @dev to claim reward on a list of proposal.\r\n     * @param _memberAddress to claim reward of.\r\n     * @param _maxRecords maximum number of records to claim reward for.\r\n     _proposals list of proposals of which reward will be claimed.\r\n     * @return amount of pending reward.\r\n     */\r\n    function claimReward(address _memberAddress, uint _maxRecords) \r\n        external returns(uint pendingDAppReward) \r\n    {\r\n        \r\n        uint voteId;\r\n        address leader;\r\n        uint lastUpd;\r\n\r\n        require(msg.sender == ms.getLatestAddress(\"CR\"));\r\n\r\n        uint delegationId = followerDelegation[_memberAddress];\r\n        if (delegationId \u003e 0 \u0026\u0026 allDelegation[delegationId].leader != address(0)) {\r\n            leader = allDelegation[delegationId].leader;\r\n            lastUpd = allDelegation[delegationId].lastUpd;\r\n        } else\r\n            leader = _memberAddress;\r\n\r\n        uint proposalId;\r\n        uint totalVotes = allVotesByMember[leader].length;\r\n        uint lastClaimed = totalVotes;\r\n        uint j;\r\n        uint i;\r\n        for (i = lastRewardClaimed[_memberAddress];i \u003c totalVotes \u0026\u0026 j \u003c _maxRecords; i++) {\r\n            voteId = allVotesByMember[leader][i];\r\n            proposalId = allVotes[voteId].proposalId;\r\n            if (proposalVoteTally[proposalId].voters \u003e 0 \u0026\u0026 (allVotes[voteId].dateAdd \u003e (\r\n                lastUpd + tokenHoldingTime) || leader == _memberAddress)) {\r\n                if (allProposalData[proposalId].propStatus \u003e uint(ProposalStatus.VotingStarted)) {\r\n                    if (!rewardClaimed[voteId][_memberAddress]) {\r\n                        pendingDAppReward += allProposalData[proposalId].commonIncentive / \r\n                        proposalVoteTally[proposalId].voters;\r\n                        rewardClaimed[voteId][_memberAddress] = true;\r\n                        j++;\r\n                    }\r\n                } else {\r\n                    if(lastClaimed == totalVotes) {\r\n                        lastClaimed = i;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(lastClaimed == totalVotes) {\r\n            lastRewardClaimed[_memberAddress] = i;\r\n        } else {\r\n            lastRewardClaimed[_memberAddress] = lastClaimed;\r\n        }\r\n\r\n        if (j \u003e 0) {\r\n            emit RewardClaimed(\r\n                _memberAddress,\r\n                pendingDAppReward\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Used to set delegation acceptance status of individual user\r\n     * @param _status delegation acceptance status\r\n     */\r\n    function setDelegationStatus(bool _status) external isMemberAndcheckPause checkPendingRewards {\r\n        isOpenForDelegation[msg.sender] = _status;\r\n    }\r\n\r\n    /**\r\n     * @dev to delegate vote to an address.\r\n     * @param _add is the address to delegate vote to.\r\n     */\r\n    function delegateVote(address _add) external isMemberAndcheckPause checkPendingRewards {\r\n        //Ensure that NXMaster has initialized.\r\n        require(ms.masterInitialized());\r\n\r\n        //Check if given address is not a follower\r\n        require(allDelegation[followerDelegation[_add]].leader == address(0));\r\n\r\n        if (followerDelegation[msg.sender] \u003e 0) {\r\n            require(SafeMath.add(allDelegation[followerDelegation[msg.sender]].lastUpd, tokenHoldingTime) \u003c now);\r\n        }\r\n\r\n        require(!alreadyDelegated(msg.sender), \"Already a leader\");\r\n        require(!memberRole.checkRole(msg.sender, uint(MemberRoles.Role.Owner)));\r\n        require(!memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)));\r\n\r\n\r\n        require(followerCount[_add] \u003c maxFollowers);\r\n        \r\n        if (allVotesByMember[msg.sender].length \u003e 0) {\r\n            uint memberLastVoteId = SafeMath.sub(allVotesByMember[msg.sender].length, 1);\r\n            require(SafeMath.add(allVotes[allVotesByMember[msg.sender][memberLastVoteId]].dateAdd, tokenHoldingTime)\r\n            \u003c now);\r\n        }\r\n\r\n        // require(getPendingReward(msg.sender) == 0);\r\n\r\n        require(ms.isMember(_add));\r\n\r\n        require(isOpenForDelegation[_add]);\r\n\r\n        allDelegation.push(DelegateVote(msg.sender, _add, now));\r\n        followerDelegation[msg.sender] = allDelegation.length - 1;\r\n        leaderDelegation[_add].push(allDelegation.length - 1);\r\n        followerCount[_add]++;\r\n        lastRewardClaimed[msg.sender] = allVotesByMember[_add].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Undelegates the sender\r\n     */\r\n    function unDelegate() external isMemberAndcheckPause checkPendingRewards {\r\n        _unDelegate(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Uint Parameters of a code\r\n     * @param code whose details we want\r\n     * @return string value of the code\r\n     * @return associated amount (time or perc or value) to the code\r\n     */\r\n    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint val) {\r\n\r\n        codeVal = code;\r\n\r\n        if (code == \"GOVHOLD\") {\r\n\r\n            val = tokenHoldingTime / (1 days);\r\n\r\n        } else if (code == \"MAXFOL\") {\r\n\r\n            val = maxFollowers;\r\n\r\n        } else if (code == \"MAXDRFT\") {\r\n\r\n            val = maxDraftTime / (1 days);\r\n\r\n        } else if (code == \"MAXAB\") {\r\n\r\n            val = mr.maxABCount();\r\n\r\n        } else if (code == \"EPTIME\") {\r\n            val = ms.pauseTime() / (1 days);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Gets all details of a propsal\r\n     * @param _proposalId whose details we want\r\n     * @return proposalId\r\n     * @return category\r\n     * @return status\r\n     * @return finalVerdict\r\n     * @return totalReward\r\n     */\r\n    function proposal(uint _proposalId)\r\n        external\r\n        view\r\n        returns(\r\n            uint proposalId,\r\n            uint category,\r\n            uint status,\r\n            uint finalVerdict,\r\n            uint totalRewar\r\n        )\r\n    {\r\n        return(\r\n            _proposalId,\r\n            allProposalData[_proposalId].category,\r\n            allProposalData[_proposalId].propStatus,\r\n            allProposalData[_proposalId].finalVerdict,\r\n            allProposalData[_proposalId].commonIncentive\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets some details of a propsal\r\n     * @param _proposalId whose details we want\r\n     * @return proposalId\r\n     * @return number of all proposal solutions\r\n     * @return amount of votes \r\n     */\r\n    function proposalDetails(uint _proposalId) external view returns(uint, uint, uint) {\r\n        return(\r\n            _proposalId,\r\n            allProposalSolutions[_proposalId].length,\r\n            proposalVoteTally[_proposalId].voters\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets solution action on a proposal\r\n     * @param _proposalId whose details we want\r\n     * @param _solution whose details we want\r\n     * @return action of a solution on a proposal\r\n     */\r\n    function getSolutionAction(uint _proposalId, uint _solution) external view returns(uint, bytes memory) {\r\n        return (\r\n            _solution,\r\n            allProposalSolutions[_proposalId][_solution]\r\n        );\r\n    }\r\n   \r\n    /**\r\n     * @dev get length of propsal\r\n     * @return length of propsal\r\n     */\r\n    function getProposalLength() external view returns(uint) {\r\n        return totalProposals;\r\n    }\r\n\r\n    /**\r\n     * @dev get followers of an address\r\n     * @return get followers of an address\r\n     */\r\n    function getFollowers(address _add) external view returns(uint[] memory) {\r\n        return leaderDelegation[_add];\r\n    }\r\n\r\n    /**\r\n     * @dev get pending reward of a member\r\n     * @param _memberAddress in concern\r\n     * @return amount of pending reward\r\n     */\r\n    function getPendingReward(address _memberAddress)\r\n        public view returns(uint pendingDAppReward)\r\n    {\r\n        uint delegationId = followerDelegation[_memberAddress];\r\n        address leader;\r\n        uint lastUpd;\r\n        if (delegationId \u003e 0 \u0026\u0026 allDelegation[delegationId].leader != address(0)) {\r\n            leader = allDelegation[delegationId].leader;\r\n            lastUpd = allDelegation[delegationId].lastUpd;\r\n        } else\r\n            leader = _memberAddress;\r\n\r\n        uint proposalId;\r\n        for (uint i = lastRewardClaimed[_memberAddress];i \u003c allVotesByMember[leader].length; i++) {\r\n            if (allVotes[allVotesByMember[leader][i]].dateAdd \u003e (\r\n                lastUpd + tokenHoldingTime) || leader == _memberAddress) {\r\n                if (!rewardClaimed[allVotesByMember[leader][i]][_memberAddress]) {\r\n                    proposalId = allVotes[allVotesByMember[leader][i]].proposalId;\r\n                    if (proposalVoteTally[proposalId].voters \u003e 0 \u0026\u0026 allProposalData[proposalId].propStatus\r\n                    \u003e uint(ProposalStatus.VotingStarted)) {\r\n                        pendingDAppReward += allProposalData[proposalId].commonIncentive / \r\n                        proposalVoteTally[proposalId].voters;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Updates Uint Parameters of a code\r\n     * @param code whose details we want to update\r\n     * @param val value to set\r\n     */\r\n    function updateUintParameters(bytes8 code, uint val) public {\r\n\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        if (code == \"GOVHOLD\") {\r\n\r\n            tokenHoldingTime = val * 1 days;\r\n\r\n        } else if (code == \"MAXFOL\") {\r\n\r\n            maxFollowers = val;\r\n\r\n        } else if (code == \"MAXDRFT\") {\r\n\r\n            maxDraftTime = val * 1 days;\r\n\r\n        } else if (code == \"MAXAB\") {\r\n\r\n            mr.changeMaxABCount(val);\r\n\r\n        } else if (code == \"EPTIME\") {\r\n            ms.updatePauseTime(val * 1 days);\r\n\r\n        } else {\r\n            revert(\"Invalid code\");\r\n        }\r\n    }\r\n\r\n    /// @dev updates all dependency addresses to latest ones from Master\r\n    function changeDependentContractAddress() public {\r\n        if (!constructorCheck) {\r\n            _initiateGovernance();\r\n        }\r\n        tokenInstance = TokenController(ms.dAppLocker());\r\n        memberRole = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n        proposalCategory = ProposalCategory(ms.getLatestAddress(\"PC\"));\r\n        mr = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n    }\r\n\r\n    /// @dev checks if the msg.sender is allowed to create a proposal under certain category\r\n    function allowedToCreateProposal(uint category) public view returns(bool check) {\r\n        if (category == 0)\r\n            return true;\r\n        uint[] memory mrAllowed;\r\n        (, , , , mrAllowed, , ) = proposalCategory.category(category);\r\n        for (uint i = 0; i \u003c mrAllowed.length; i++) {\r\n            if (mrAllowed[i] == 0 || memberRole.checkRole(msg.sender, mrAllowed[i]))\r\n                return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to know if an address is already delegated\r\n     * @param _add in concern\r\n     * @return bool value if the address is delegated or not\r\n     */\r\n    function alreadyDelegated(address _add) public view returns(bool delegated) {\r\n        for (uint i=0; i \u003c leaderDelegation[_add].length; i++) {\r\n            if (allDelegation[leaderDelegation[_add][i]].leader == _add) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev pause a proposal\r\n    //To implement govblocks interface\r\n    function pauseProposal(uint) public {\r\n    }\r\n\r\n    /// @dev resume a proposal\r\n    //To implement govblocks interface\r\n    function resumeProposal(uint) public {\r\n    }\r\n\r\n    /// @dev Checks If the proposal voting time is up and it\u0027s ready to close \r\n    ///      i.e. Closevalue is 1 if proposal is ready to be closed, 2 if already closed, 0 otherwise!\r\n    /// @param _proposalId Proposal id to which closing value is being checked\r\n    function canCloseProposal(uint _proposalId) \r\n        public \r\n        view \r\n        returns(uint)\r\n    {\r\n        uint dateUpdate;\r\n        uint pStatus;\r\n        uint _closingTime;\r\n        uint _roleId;\r\n        uint majority;\r\n        pStatus = allProposalData[_proposalId].propStatus;\r\n        dateUpdate = allProposalData[_proposalId].dateUpd;\r\n        (, _roleId, majority, , , _closingTime, ) = proposalCategory.category(allProposalData[_proposalId].category);\r\n        if (\r\n            pStatus == uint(ProposalStatus.VotingStarted)\r\n        ) {\r\n            uint numberOfMembers = memberRole.numberOfMembers(_roleId);\r\n            if (_roleId == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n                uint totalABVoted = proposalVoteTally[_proposalId].abVoteValue[1] + \r\n                proposalVoteTally[_proposalId].abVoteValue[0];\r\n                if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100).div(numberOfMembers) \u003e= majority  \r\n                || totalABVoted == numberOfMembers || dateUpdate.add(_closingTime) \u003c= now) {\r\n\r\n                    return 1;\r\n                }\r\n            } else {\r\n                if (numberOfMembers == proposalVoteTally[_proposalId].voters \r\n                || dateUpdate.add(_closingTime) \u003c= now)\r\n                    return  1;\r\n            }\r\n        } else if (pStatus \u003e uint(ProposalStatus.VotingStarted)) {\r\n            return  2;\r\n        } else {\r\n            return  0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev get roleId of member allowed to categorize the proposal\r\n     * @return roleId\r\n     */\r\n    function allowedToCatgorize() public view returns(uint roleId) {\r\n        return roleIdAllowedToCatgorize;\r\n    }\r\n\r\n    /**\r\n     * @dev get vote tally data\r\n     * @param _proposalId in concern\r\n     * @param _solution of a proposal id\r\n     * @return member vote value\r\n     * @return advisory board vote value\r\n     * @return amount of votes\r\n     */\r\n    function voteTallyData(uint _proposalId, uint _solution) public view returns(uint, uint, uint) {\r\n        return (proposalVoteTally[_proposalId].memberVoteValue[_solution],\r\n            proposalVoteTally[_proposalId].abVoteValue[_solution], proposalVoteTally[_proposalId].voters);\r\n    }\r\n\r\n    /**\r\n     * @dev to create a proposal\r\n     * @param _proposalTitle of proposal\r\n     * @param _proposalSD is short description of proposal\r\n     * @param _proposalDescHash IPFS hash value of propsal\r\n     * @param _categoryId of proposal\r\n     */\r\n    function _createProposal(\r\n        string memory _proposalTitle,\r\n        string memory _proposalSD,\r\n        string memory _proposalDescHash,\r\n        uint _categoryId\r\n    )\r\n        internal\r\n    {\r\n        require(proposalCategory.categoryABReq(_categoryId) == 0 || _categoryId == 0);\r\n        uint _proposalId = totalProposals;\r\n        allProposalData[_proposalId].owner = msg.sender;\r\n        allProposalData[_proposalId].dateUpd = now;\r\n        allProposalSolutions[_proposalId].push(\"\");\r\n        totalProposals++;\r\n        if (_categoryId \u003e 0)\r\n            _categorizeProposal(_proposalId, _categoryId, 0);        \r\n\r\n        emit Proposal(\r\n            msg.sender,\r\n            _proposalId,\r\n            now,\r\n            _proposalTitle,\r\n            _proposalSD,\r\n            _proposalDescHash\r\n        );\r\n        // emit ProposalCreated(_proposalId, _categoryId, address(ms), _proposalDescHash);\r\n    }\r\n\r\n    /**\r\n     * @dev to categorize a proposal\r\n     * @param _proposalId of proposal\r\n     * @param _categoryId of proposal\r\n     * @param _incentive is commonIncentive\r\n     */\r\n    function _categorizeProposal(\r\n        uint _proposalId,\r\n        uint _categoryId,\r\n        uint _incentive\r\n    )\r\n        internal\r\n    {\r\n        require(\r\n            _categoryId \u003e 0 \u0026\u0026 _categoryId \u003c proposalCategory.totalCategories(),\r\n            \"Invalid category\"\r\n        );\r\n        allProposalData[_proposalId].category = _categoryId;\r\n        allProposalData[_proposalId].commonIncentive = _incentive;\r\n        allProposalData[_proposalId].propStatus = uint(ProposalStatus.AwaitingSolution);\r\n\r\n        emit ProposalCategorized(_proposalId, msg.sender, _categoryId);\r\n    }\r\n\r\n    /**\r\n     * @dev add solution to a proposalId\r\n     * @param _proposalId in concern\r\n     * @param _action on that solution\r\n     * @param _solutionHash string value\r\n     */\r\n    function _addSolution(uint _proposalId, bytes memory _action, string memory _solutionHash)\r\n        internal\r\n    {\r\n        allProposalSolutions[_proposalId].push(_action);\r\n        emit Solution(_proposalId, msg.sender, allProposalSolutions[_proposalId].length - 1, _solutionHash, now);\r\n    }\r\n\r\n    /// @dev When creating or submitting proposal with solution, This function open the proposal for voting\r\n    function _proposalSubmission(\r\n        uint _proposalId,\r\n        string memory _solutionHash,\r\n        bytes memory _action\r\n    )\r\n        internal\r\n    {\r\n\r\n        _addSolution(\r\n            _proposalId,\r\n            _action,\r\n            _solutionHash\r\n        );\r\n\r\n        _openProposalForVoting(\r\n            _proposalId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev for submitting vote on a proposal\r\n     * @param _proposalId of proposal in concern\r\n     * @param _solution for that proposal\r\n     */\r\n    function _submitVote(uint _proposalId, uint _solution) internal {\r\n\r\n        uint delegationId = followerDelegation[msg.sender];\r\n        uint mrSequence;\r\n        uint majority;\r\n        uint closingTime;\r\n        (, mrSequence, majority, , , closingTime, ) = proposalCategory.category(allProposalData[_proposalId].category);\r\n\r\n        require(allProposalData[_proposalId].dateUpd.add(closingTime) \u003e now, \"Closed\");\r\n\r\n        require(memberProposalVote[msg.sender][_proposalId] == 0, \"Voted\");\r\n        require((delegationId == 0) || (delegationId \u003e 0 \u0026\u0026 allDelegation[delegationId].leader == address(0) \u0026\u0026 \r\n        _checkLastUpd(allDelegation[delegationId].lastUpd)));\r\n\r\n        require(memberRole.checkRole(msg.sender, mrSequence), \"Not Authorized\");\r\n        uint totalVotes = allVotes.length;\r\n\r\n        allVotesByMember[msg.sender].push(totalVotes);\r\n        memberProposalVote[msg.sender][_proposalId] = totalVotes;\r\n\r\n        // addressProposalVote[msg.sender][_proposalId] = totalVotes;\r\n        allVotes.push(ProposalVote(msg.sender, _proposalId, now));\r\n\r\n        emit Vote(msg.sender, _proposalId, totalVotes, now, _solution);\r\n        if (mrSequence == uint(MemberRoles.Role.Owner)) {\r\n            if (_solution == 1)\r\n                _callIfMajReach(_proposalId, uint(ProposalStatus.Accepted), allProposalData[_proposalId].category, 1);\r\n            else\r\n                _updateProposalStatus(_proposalId, uint(ProposalStatus.Rejected));\r\n        \r\n        } else {\r\n            uint numberOfMembers = memberRole.numberOfMembers(mrSequence);\r\n            _setVoteTally(_proposalId, _solution, mrSequence);\r\n\r\n            if (mrSequence == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n                uint totalABVoted = proposalVoteTally[_proposalId].abVoteValue[1] + \r\n            proposalVoteTally[_proposalId].abVoteValue[0];\r\n                if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100).div(numberOfMembers) \r\n                \u003e= majority || totalABVoted == numberOfMembers) {\r\n                    emit VoteCast(_proposalId);\r\n                }\r\n            } else {\r\n                if (numberOfMembers == proposalVoteTally[_proposalId].voters)\r\n                    emit VoteCast(_proposalId);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev to set vote tally of a proposal\r\n     * @param _proposalId of proposal in concern\r\n     * @param _solution of proposal in concern\r\n     * @param mrSequence number of members for a role\r\n     */\r\n    function _setVoteTally(uint _proposalId, uint _solution, uint mrSequence) internal\r\n    {\r\n        uint category = allProposalData[_proposalId].category;\r\n        uint voteWeight;\r\n        uint voteWeightAB;\r\n        uint voters = 1;\r\n        uint isSpecialResolution = proposalCategory.isSpecialResolution(category);\r\n        uint tokenBalance = tokenInstance.totalBalanceOf(msg.sender);\r\n        uint totalSupply = tokenInstance.totalSupply();\r\n        if (isSpecialResolution == 1) {\r\n            voteWeight = tokenBalance + 10**18;\r\n        } else {\r\n            voteWeight = (_minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100))) + 10**18;\r\n        }\r\n        if (memberRole.checkRole(msg.sender, 1) \u0026\u0026 (proposalCategory.categoryABReq(category) \u003e 0) || \r\n            mrSequence == uint(MemberRoles.Role.AdvisoryBoard))\r\n            voteWeightAB = 1;\r\n        uint delegationId;\r\n        tokenInstance.lockForMemberVote(msg.sender, tokenHoldingTime);\r\n        for (uint i = 0; i \u003c leaderDelegation[msg.sender].length; i++) {\r\n            delegationId = leaderDelegation[msg.sender][i];\r\n            if (allDelegation[delegationId].leader == msg.sender \u0026\u0026 \r\n            _checkLastUpd(allDelegation[delegationId].lastUpd)) {\r\n                if (memberRole.checkRole(allDelegation[delegationId].follower, mrSequence)) {\r\n                    tokenBalance = tokenInstance.totalBalanceOf(allDelegation[delegationId].follower);\r\n                    tokenInstance.lockForMemberVote(allDelegation[delegationId].follower, tokenHoldingTime);\r\n                    voters++;\r\n                    if (isSpecialResolution == 1) {\r\n                        voteWeight += tokenBalance + 10**18;\r\n                    } else {\r\n                        voteWeight += (_minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100))) + 10**18;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (mrSequence == uint(MemberRoles.Role.Member) || mrSequence == uint(MemberRoles.Role.Owner)) {\r\n            proposalVoteTally[_proposalId].memberVoteValue[_solution] += voteWeight;\r\n            proposalVoteTally[_proposalId].voters += voters;\r\n        }\r\n        proposalVoteTally[_proposalId].abVoteValue[_solution] += voteWeightAB;\r\n    }\r\n\r\n    /**\r\n     * @dev get minimum of two numbers\r\n     * @param a one of the two numbers\r\n     * @param b one of the two numbers\r\n     * @return minimum number out of the two\r\n     */\r\n    function _minOf(uint a, uint b) internal pure returns(uint res) {\r\n        res = a;\r\n        if (res \u003e b)\r\n            res = b;\r\n    }\r\n    \r\n    /**\r\n     * @dev check the time since last update has exceeded token holding time or not\r\n     * @param _lastUpd is last update time\r\n     * @return the bool which tells if the time since last update has exceeded token holding time or not\r\n     */\r\n    function _checkLastUpd(uint _lastUpd) internal view returns(bool) {\r\n        return (now - _lastUpd) \u003e tokenHoldingTime;\r\n    }\r\n\r\n    /// @dev Checks if the vote count against any solution passes the threshold value or not.\r\n    function _checkForThreshold(uint _proposalId, uint _category) internal view returns(bool check) {\r\n        uint categoryQuorumPerc;\r\n        (, , , categoryQuorumPerc, , , ) = proposalCategory.category(_category);\r\n        uint totalTokenVoted = proposalVoteTally[_proposalId].memberVoteValue[0]\r\n        +proposalVoteTally[_proposalId].memberVoteValue[1];\r\n        check = totalTokenVoted.mul(100).div(tokenInstance.totalSupply() + \r\n        memberRole.numberOfMembers(uint(MemberRoles.Role.Member))) \u003e= categoryQuorumPerc;\r\n    }\r\n    \r\n    /**\r\n     * @dev this function is called when vote majority is reached\r\n     * @param _proposalId of proposal in concern\r\n     * @param _status of proposal in concern\r\n     * @param category of proposal in concern\r\n     * @param max vote value of proposal in concern\r\n     */\r\n    function _callIfMajReach (uint _proposalId, uint _status, uint category, uint max) internal {\r\n        bytes2 contractName;\r\n        address actionAddress;\r\n        allProposalData[_proposalId].finalVerdict = max;\r\n        (, actionAddress, contractName, ) = proposalCategory.categoryAction(category);\r\n        _updateProposalStatus(_proposalId, _status);\r\n        if (contractName == \"MS\") {\r\n            actionAddress = address(ms);\r\n        } else if (contractName != \"EX\") {\r\n            actionAddress = ms.getLatestAddress(contractName);\r\n        }\r\n        (bool actionStatus, ) = actionAddress.call(allProposalSolutions[_proposalId][max]);//solhint-disable-line\r\n        if (actionStatus) { //solhint-disable-line\r\n            emit ActionSuccess(_proposalId);\r\n        }\r\n        emit ProposalAccepted(_proposalId);\r\n    }\r\n\r\n    /**\r\n     * @dev to update proposal status\r\n     * @param _proposalId of proposal in concern\r\n     * @param _status of proposal to set\r\n     */\r\n    function _updateProposalStatus(uint _proposalId, uint _status) internal {\r\n        allProposalData[_proposalId].dateUpd = now;\r\n        allProposalData[_proposalId].propStatus = _status;\r\n    }\r\n\r\n    /**\r\n     * @dev to undelegate a follower\r\n     * @param _follower is address of follower to undelegate\r\n     */\r\n    function _unDelegate(address _follower) internal {\r\n        uint followerId = followerDelegation[_follower];\r\n        if (followerId \u003e 0) {\r\n\r\n            followerCount[allDelegation[followerId].leader]--;\r\n            allDelegation[followerId].leader = address(0);\r\n            allDelegation[followerId].lastUpd = now;\r\n\r\n            lastRewardClaimed[msg.sender] = allVotesByMember[msg.sender].length;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to close member voting\r\n     * @param _proposalId of proposal in concern\r\n     * @param category of proposal in concern\r\n     */\r\n    function _closeMemberVote(uint _proposalId, uint category) internal {\r\n        uint totalVoteValue;\r\n        uint majorityVote;\r\n        if (proposalCategory.isSpecialResolution(category) == 1) {\r\n            uint acceptedVotePerc = proposalVoteTally[_proposalId].memberVoteValue[1].mul(100)\r\n            .div(tokenInstance.totalSupply()\r\n            + (memberRole.numberOfMembers(uint(MemberRoles.Role.Member))) * 10**18);\r\n            if (acceptedVotePerc \u003e= specialResolutionMajPerc) {\r\n                _callIfMajReach(_proposalId, uint(ProposalStatus.Accepted), category, 1);\r\n            } else {\r\n                _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n            }\r\n        } else {\r\n            if (_checkForThreshold(_proposalId, category)) {\r\n                totalVoteValue = proposalVoteTally[_proposalId].memberVoteValue[0] + \r\n                proposalVoteTally[_proposalId].memberVoteValue[1];\r\n                (, , majorityVote, , , , ) = proposalCategory.category(category);\r\n                if (SafeMath.div(SafeMath.mul(proposalVoteTally[_proposalId].memberVoteValue[1], 100), totalVoteValue) \r\n                \u003e= majorityVote) {\r\n                    _callIfMajReach(_proposalId, uint(ProposalStatus.Accepted), category, 1);\r\n                } else {\r\n                    _updateProposalStatus(_proposalId, uint(ProposalStatus.Rejected));\r\n                }\r\n            } else {\r\n                uint abMaj = proposalCategory.categoryABReq(category);\r\n                // uint abMem = memberRole.numberOfMembers(uint(MemberRoles.Role.AdvisoryBoard));\r\n                if (abMaj \u003e 0 \u0026\u0026 proposalVoteTally[_proposalId].abVoteValue[1].mul(100)\r\n                .div(memberRole.numberOfMembers(uint(MemberRoles.Role.AdvisoryBoard))) \u003e= abMaj) {\r\n                    _callIfMajReach(_proposalId, uint(ProposalStatus.Accepted), category, 1);\r\n                } else {\r\n                    _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n                }\r\n            }\r\n        }\r\n\r\n        if (proposalVoteTally[_proposalId].voters \u003e 0) {\r\n            tokenInstance.mint(ms.getLatestAddress(\"CR\"), allProposalData[_proposalId].commonIncentive);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to close advisory board voting\r\n     * @param _proposalId of proposal in concern\r\n     * @param category of proposal in concern\r\n     * @param _roleId of group of members involved in voting\r\n     */\r\n    function _closeABVote(uint _proposalId, uint category, uint _roleId) internal {\r\n        uint _majorityVote;\r\n        // uint abMem = memberRole.numberOfMembers(_roleId);\r\n        (, , _majorityVote, , , , ) = proposalCategory.category(category);\r\n        if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100)\r\n        .div(memberRole.numberOfMembers(_roleId)) \u003e= _majorityVote) {\r\n            _callIfMajReach(_proposalId, uint(ProposalStatus.Accepted), category, 1);\r\n        } else {\r\n            _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev to open proposal for voting\r\n     * @param _proposalId of proposal in concern\r\n     */\r\n    function _openProposalForVoting(uint _proposalId) internal {\r\n\r\n        require(allProposalData[_proposalId].category != 0, \"Proposal not categorized\");        \r\n        _updateProposalStatus(_proposalId, uint(ProposalStatus.VotingStarted));\r\n        uint closingTime;\r\n        (, , , , , closingTime, ) = proposalCategory.category(allProposalData[_proposalId].category);\r\n        emit CloseProposalOnTime(_proposalId, SafeMath.add(closingTime, now));\r\n    }\r\n\r\n    /**\r\n     * @dev to initiate the governance process\r\n     */\r\n    function _initiateGovernance() internal {\r\n        allVotes.push(ProposalVote(address(0), 0, 0));\r\n        totalProposals = 1;\r\n        // allProposal.push(ProposalStruct(address(0), now));\r\n        allDelegation.push(DelegateVote(address(0), address(0), now));\r\n        tokenHoldingTime = 1 * 7 days;\r\n        maxDraftTime = 2 * 7 days;\r\n        maxVoteWeigthPer = 5;\r\n        maxFollowers = 40;\r\n        constructorCheck = true;\r\n        roleIdAllowedToCatgorize = uint(MemberRoles.Role.AdvisoryBoard);\r\n        specialResolutionMajPerc = 75;\r\n    }\r\n\r\n}"},"Governed.sol":{"content":"/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IMaster {\r\n    function getLatestAddress(bytes2 _module) public view returns(address);\r\n}\r\n\r\n\r\ncontract Governed {\r\n\r\n    address public masterAddress; // Name of the dApp, needs to be set by contracts inheriting this contract\r\n\r\n    /// @dev modifier that allows only the authorized addresses to execute the function\r\n    modifier onlyAuthorizedToGovern() {\r\n        IMaster ms = IMaster(masterAddress);\r\n        require(ms.getLatestAddress(\"GV\") == msg.sender, \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    /// @dev checks if an address is authorized to govern\r\n    function isAuthorizedToGovern(address _toCheck) public view returns(bool) {\r\n        IMaster ms = IMaster(masterAddress);\r\n        return (ms.getLatestAddress(\"GV\") == _toCheck);\r\n    } \r\n\r\n}"},"IERC1132.sol":{"content":"pragma solidity 0.5.7;\r\n\r\n/**\r\n * @title ERC1132 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/1132\r\n */\r\n\r\ncontract IERC1132 {\r\n    /**\r\n     * @dev Reasons why a user\u0027s tokens have been locked\r\n     */\r\n    mapping(address =\u003e bytes32[]) public lockReason;\r\n\r\n    /**\r\n     * @dev locked token structure\r\n     */\r\n    struct LockToken {\r\n        uint256 amount;\r\n        uint256 validity;\r\n        bool claimed;\r\n    }\r\n\r\n    /**\r\n     * @dev Holds number \u0026 validity of tokens locked for a given reason for\r\n     *      a specified address\r\n     */\r\n    mapping(address =\u003e mapping(bytes32 =\u003e LockToken)) public locked;\r\n\r\n    /**\r\n     * @dev Records data of all the tokens Locked\r\n     */\r\n    event Locked(\r\n        address indexed _of,\r\n        bytes32 indexed _reason,\r\n        uint256 _amount,\r\n        uint256 _validity\r\n    );\r\n\r\n    /**\r\n     * @dev Records data of all the tokens unlocked\r\n     */\r\n    event Unlocked(\r\n        address indexed _of,\r\n        bytes32 indexed _reason,\r\n        uint256 _amount\r\n    );\r\n    \r\n    /**\r\n     * @dev Locks a specified amount of tokens against an address,\r\n     *      for a specified reason and time\r\n     * @param _reason The reason to lock tokens\r\n     * @param _amount Number of tokens to be locked\r\n     * @param _time Lock time in seconds\r\n     */\r\n    function lock(bytes32 _reason, uint256 _amount, uint256 _time)\r\n        public returns (bool);\r\n  \r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason\r\n     *\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     */\r\n    function tokensLocked(address _of, bytes32 _reason)\r\n        public view returns (uint256 amount);\r\n    \r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason at a specific time\r\n     *\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     * @param _time The timestamp to query the lock tokens for\r\n     */\r\n    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n        public view returns (uint256 amount);\r\n    \r\n    /**\r\n     * @dev Returns total tokens held by an address (locked + transferable)\r\n     * @param _of The address to query the total balance of\r\n     */\r\n    function totalBalanceOf(address _of)\r\n        public view returns (uint256 amount);\r\n    \r\n    /**\r\n     * @dev Extends lock for a specified reason and time\r\n     * @param _reason The reason to lock tokens\r\n     * @param _time Lock extension time in seconds\r\n     */\r\n    function extendLock(bytes32 _reason, uint256 _time)\r\n        public returns (bool);\r\n    \r\n    /**\r\n     * @dev Increase number of tokens locked for a specified reason\r\n     * @param _reason The reason to lock tokens\r\n     * @param _amount Number of tokens to be increased\r\n     */\r\n    function increaseLockAmount(bytes32 _reason, uint256 _amount)\r\n        public returns (bool);\r\n\r\n    /**\r\n     * @dev Returns unlockable tokens for a specified address for a specified reason\r\n     * @param _of The address to query the the unlockable token count of\r\n     * @param _reason The reason to query the unlockable tokens for\r\n     */\r\n    function tokensUnlockable(address _of, bytes32 _reason)\r\n        public view returns (uint256 amount);\r\n \r\n    /**\r\n     * @dev Unlocks the unlockable tokens of a specified address\r\n     * @param _of Address of user, claiming back unlockable tokens\r\n     */\r\n    function unlock(address _of)\r\n        public returns (uint256 unlockableTokens);\r\n\r\n    /**\r\n     * @dev Gets the unlockable tokens of a specified address\r\n     * @param _of The address to query the the unlockable token count of\r\n     */\r\n    function getUnlockableTokens(address _of)\r\n        public view returns (uint256 unlockableTokens);\r\n\r\n}"},"IERC20.sol":{"content":"pragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value)\r\n        external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value)\r\n        external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external view returns (uint256);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n"},"IGovernance.sol":{"content":"/* Copyright (C) 2017 GovBlocks.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IGovernance { \r\n\r\n    event Proposal(\r\n        address indexed proposalOwner,\r\n        uint256 indexed proposalId,\r\n        uint256 dateAdd,\r\n        string proposalTitle,\r\n        string proposalSD,\r\n        string proposalDescHash\r\n    );\r\n\r\n    event Solution(\r\n        uint256 indexed proposalId,\r\n        address indexed solutionOwner,\r\n        uint256 indexed solutionId,\r\n        string solutionDescHash,\r\n        uint256 dateAdd\r\n    );\r\n\r\n    event Vote(\r\n        address indexed from,\r\n        uint256 indexed proposalId,\r\n        uint256 indexed voteId,\r\n        uint256 dateAdd,\r\n        uint256 solutionChosen\r\n    );\r\n\r\n    event RewardClaimed(\r\n        address indexed member,\r\n        uint gbtReward\r\n    );\r\n\r\n    /// @dev VoteCast event is called whenever a vote is cast that can potentially close the proposal. \r\n    event VoteCast (uint256 proposalId);\r\n\r\n    /// @dev ProposalAccepted event is called when a proposal is accepted so that a server can listen that can \r\n    ///      call any offchain actions\r\n    event ProposalAccepted (uint256 proposalId);\r\n\r\n    /// @dev CloseProposalOnTime event is called whenever a proposal is created or updated to close it on time.\r\n    event CloseProposalOnTime (\r\n        uint256 indexed proposalId,\r\n        uint256 time\r\n    );\r\n\r\n    /// @dev ActionSuccess event is called whenever an onchain action is executed.\r\n    event ActionSuccess (\r\n        uint256 proposalId\r\n    );\r\n\r\n    /// @dev Creates a new proposal\r\n    /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n    /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal\u0027s Objective\r\n    function createProposal(\r\n        string calldata _proposalTitle,\r\n        string calldata _proposalSD,\r\n        string calldata _proposalDescHash,\r\n        uint _categoryId\r\n    ) \r\n        external;\r\n\r\n    /// @dev Edits the details of an existing proposal and creates new version\r\n    /// @param _proposalId Proposal id that details needs to be updated\r\n    /// @param _proposalDescHash Proposal description hash having long and short description of proposal.\r\n    function updateProposal(\r\n        uint _proposalId, \r\n        string calldata _proposalTitle, \r\n        string calldata _proposalSD, \r\n        string calldata _proposalDescHash\r\n    ) \r\n        external;\r\n\r\n    /// @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\r\n    function categorizeProposal(\r\n        uint _proposalId, \r\n        uint _categoryId,\r\n        uint _incentives\r\n    ) \r\n        external;\r\n\r\n    /// @dev Initiates add solution \r\n    /// @param _solutionHash Solution hash having required data against adding solution\r\n    function addSolution(\r\n        uint _proposalId,\r\n        string calldata _solutionHash, \r\n        bytes calldata _action\r\n    ) \r\n        external; \r\n\r\n    /// @dev Opens proposal for voting\r\n    function openProposalForVoting(uint _proposalId) external;\r\n\r\n    /// @dev Submit proposal with solution\r\n    /// @param _proposalId Proposal id\r\n    /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n    function submitProposalWithSolution(\r\n        uint _proposalId, \r\n        string calldata _solutionHash, \r\n        bytes calldata _action\r\n    ) \r\n        external;\r\n\r\n    /// @dev Creates a new proposal with solution and votes for the solution\r\n    /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n    /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal\u0027s Objective\r\n    /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n    function createProposalwithSolution(\r\n        string calldata _proposalTitle, \r\n        string calldata _proposalSD, \r\n        string calldata _proposalDescHash,\r\n        uint _categoryId, \r\n        string calldata _solutionHash, \r\n        bytes calldata _action\r\n    ) \r\n        external;\r\n\r\n    /// @dev Casts vote\r\n    /// @param _proposalId Proposal id\r\n    /// @param _solutionChosen solution chosen while voting. _solutionChosen[0] is the chosen solution\r\n    function submitVote(uint _proposalId, uint _solutionChosen) external;\r\n\r\n    function closeProposal(uint _proposalId) external;\r\n\r\n    function claimReward(address _memberAddress, uint _maxRecords) external returns(uint pendingDAppReward); \r\n\r\n    function proposal(uint _proposalId)\r\n        external\r\n        view\r\n        returns(\r\n            uint proposalId,\r\n            uint category,\r\n            uint status,\r\n            uint finalVerdict,\r\n            uint totalReward\r\n        );\r\n\r\n    function canCloseProposal(uint _proposalId) public view returns(uint closeValue);\r\n\r\n    function pauseProposal(uint _proposalId) public;\r\n    \r\n    function resumeProposal(uint _proposalId) public;\r\n    \r\n    function allowedToCatgorize() public view returns(uint roleId);\r\n\r\n}"},"IMemberRoles.sol":{"content":"/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IMemberRoles {\r\n\r\n    event MemberRole(uint256 indexed roleId, bytes32 roleName, string roleDescription);\r\n    \r\n    /// @dev Adds new member role\r\n    /// @param _roleName New role name\r\n    /// @param _roleDescription New description hash\r\n    /// @param _authorized Authorized member against every role id\r\n    function addRole(bytes32 _roleName, string memory _roleDescription, address _authorized) public;\r\n\r\n    /// @dev Assign or Delete a member from specific role.\r\n    /// @param _memberAddress Address of Member\r\n    /// @param _roleId RoleId to update\r\n    /// @param _active active is set to be True if we want to assign this role to member, False otherwise!\r\n    function updateRole(address _memberAddress, uint _roleId, bool _active) public;\r\n\r\n    /// @dev Change Member Address who holds the authority to Add/Delete any member from specific role.\r\n    /// @param _roleId roleId to update its Authorized Address\r\n    /// @param _authorized New authorized address against role id\r\n    function changeAuthorized(uint _roleId, address _authorized) public;\r\n\r\n    /// @dev Return number of member roles\r\n    function totalRoles() public view returns(uint256);\r\n\r\n    /// @dev Gets the member addresses assigned by a specific role\r\n    /// @param _memberRoleId Member role id\r\n    /// @return roleId Role id\r\n    /// @return allMemberAddress Member addresses of specified role id\r\n    function members(uint _memberRoleId) public view returns(uint, address[] memory allMemberAddress);\r\n\r\n    /// @dev Gets all members\u0027 length\r\n    /// @param _memberRoleId Member role id\r\n    /// @return memberRoleData[_memberRoleId].memberAddress.length Member length\r\n    function numberOfMembers(uint _memberRoleId) public view returns(uint);\r\n    \r\n    /// @dev Return member address who holds the right to add/remove any member from specific role.\r\n    function authorized(uint _memberRoleId) public view returns(address);\r\n\r\n    /// @dev Get All role ids array that has been assigned to a member so far.\r\n    function roles(address _memberAddress) public view returns(uint[] memory assignedRoles);\r\n\r\n    /// @dev Returns true if the given role id is assigned to a member.\r\n    /// @param _memberAddress Address of member\r\n    /// @param _roleId Checks member\u0027s authenticity with the roleId.\r\n    /// i.e. Returns true if this roleId is assigned to member\r\n    function checkRole(address _memberAddress, uint _roleId) public view returns(bool);   \r\n}"},"INXMMaster.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract INXMMaster {\r\n\r\n    address public tokenAddress;\r\n\r\n    address public owner;\r\n\r\n\r\n    uint public pauseTime;\r\n\r\n    function delegateCallBack(bytes32 myid) external;\r\n\r\n    function masterInitialized() public view returns(bool);\r\n    \r\n    function isInternal(address _add) public view returns(bool);\r\n\r\n    function isPause() public view returns(bool check);\r\n\r\n    function isOwner(address _add) public view returns(bool);\r\n\r\n    function isMember(address _add) public view returns(bool);\r\n    \r\n    function checkIsAuthToGoverned(address _add) public view returns(bool);\r\n\r\n    function updatePauseTime(uint _time) public;\r\n\r\n    function dAppLocker() public view returns(address _add);\r\n\r\n    function dAppToken() public view returns(address _add);\r\n\r\n    function getLatestAddress(bytes2 _contractName) public view returns(address payable contractAddress);\r\n}"},"IProposalCategory.sol":{"content":"/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IProposalCategory {\r\n\r\n    event Category(\r\n        uint indexed categoryId,\r\n        string categoryName,\r\n        string actionHash\r\n    );\r\n\r\n    /// @dev Adds new category\r\n    /// @param _name Category name\r\n    /// @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n    /// @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n    /// @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n    /// @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n    /// @param _closingTime Vote closing time for Each voting layer\r\n    /// @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n    /// @param _contractAddress address of contract to call after proposal is accepted\r\n    /// @param _contractName name of contract to be called after proposal is accepted\r\n    /// @param _incentives rewards to distributed after proposal is accepted\r\n    function addCategory(\r\n        string calldata _name, \r\n        uint _memberRoleToVote,\r\n        uint _majorityVotePerc, \r\n        uint _quorumPerc, \r\n        uint[] calldata _allowedToCreateProposal,\r\n        uint _closingTime,\r\n        string calldata _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint[] calldata _incentives\r\n    ) \r\n        external;\r\n\r\n    /// @dev gets category details\r\n    function category(uint _categoryId)\r\n        external\r\n        view\r\n        returns(\r\n            uint categoryId,\r\n            uint memberRoleToVote,\r\n            uint majorityVotePerc,\r\n            uint quorumPerc,\r\n            uint[] memory allowedToCreateProposal,\r\n            uint closingTime,\r\n            uint minStake\r\n        );\r\n    \r\n    ///@dev gets category action details\r\n    function categoryAction(uint _categoryId)\r\n        external\r\n        view\r\n        returns(\r\n            uint categoryId,\r\n            address contractAddress,\r\n            bytes2 contractName,\r\n            uint defaultIncentive\r\n        );\r\n    \r\n    /// @dev Gets Total number of categories added till now\r\n    function totalCategories() external view returns(uint numberOfCategories);\r\n\r\n    /// @dev Updates category details\r\n    /// @param _categoryId Category id that needs to be updated\r\n    /// @param _name Category name\r\n    /// @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n    /// @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n    /// @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n    /// @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n    /// @param _closingTime Vote closing time for Each voting layer\r\n    /// @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n    /// @param _contractAddress address of contract to call after proposal is accepted\r\n    /// @param _contractName name of contract to be called after proposal is accepted\r\n    /// @param _incentives rewards to distributed after proposal is accepted\r\n    function updateCategory(\r\n        uint _categoryId, \r\n        string memory _name, \r\n        uint _memberRoleToVote, \r\n        uint _majorityVotePerc, \r\n        uint _quorumPerc,\r\n        uint[] memory _allowedToCreateProposal,\r\n        uint _closingTime,\r\n        string memory _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint[] memory _incentives\r\n    )\r\n        public;\r\n\r\n}"},"Iupgradable.sol":{"content":"pragma solidity 0.5.7;\r\n\r\nimport \"./INXMMaster.sol\";\r\n\r\n\r\ncontract Iupgradable {\r\n\r\n    INXMMaster public ms;\r\n    address public nxMasterAddress;\r\n\r\n    modifier onlyInternal {\r\n        require(ms.isInternal(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier isMemberAndcheckPause {\r\n        require(ms.isPause() == false \u0026\u0026 ms.isMember(msg.sender) == true);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(ms.isOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier checkPause {\r\n        require(ms.isPause() == false);\r\n        _;\r\n    }\r\n\r\n    modifier isMember {\r\n        require(ms.isMember(msg.sender), \"Not member\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Iupgradable Interface to update dependent contract address\r\n     */\r\n    function  changeDependentContractAddress() public;\r\n\r\n    /**\r\n     * @dev change master address\r\n     * @param _masterAddress is the new address\r\n     */\r\n    function changeMasterAddress(address _masterAddress) public {\r\n        if (address(ms) != address(0)) {\r\n            require(address(ms) == msg.sender, \"Not master\");\r\n        }\r\n        ms = INXMMaster(_masterAddress);\r\n        nxMasterAddress = _masterAddress;\r\n    }\r\n\r\n}\r\n"},"MCR.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\nimport \"./PoolData.sol\";\r\nimport \"./QuotationData.sol\";\r\nimport \"./TokenData.sol\";\r\nimport \"./NXMToken.sol\";\r\nimport \"./Pool1.sol\";\r\nimport \"./MemberRoles.sol\";\r\nimport \"./ProposalCategory.sol\";\r\n\r\n\r\ncontract MCR is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    Pool1 internal p1;\r\n    PoolData internal pd;\r\n    NXMToken internal tk;\r\n    QuotationData internal qd;\r\n    MemberRoles internal mr;\r\n    TokenData internal td;\r\n    ProposalCategory internal proposalCategory;\r\n\r\n    uint private constant DECIMAL1E18 = uint(10) ** 18;\r\n    uint private constant DECIMAL1E05 = uint(10) ** 5;\r\n    uint private constant DECIMAL1E19 = uint(10) ** 19;\r\n\r\n    event MCREvent(\r\n        uint indexed date,\r\n        uint blockNumber,\r\n        bytes4[] allCurr,\r\n        uint[] allCurrRates,\r\n        uint mcrEtherx100,\r\n        uint mcrPercx100,\r\n        uint vFull\r\n    );\r\n\r\n    /** \r\n     * @dev Adds new MCR data.\r\n     * @param mcrP  Minimum Capital Requirement in percentage.\r\n     * @param vF Pool1 fund value in Ether used in the last full daily calculation of the Capital model.\r\n     * @param onlyDate  Date(yyyymmdd) at which MCR details are getting added.\r\n     */ \r\n    function addMCRData(\r\n        uint mcrP,\r\n        uint mcrE,\r\n        uint vF,\r\n        bytes4[] calldata curr,\r\n        uint[] calldata _threeDayAvg,\r\n        uint64 onlyDate\r\n    )\r\n        external\r\n        checkPause\r\n    {\r\n        require(proposalCategory.constructorCheck());\r\n        require(pd.isnotarise(msg.sender));\r\n        uint _days = (uint(now).sub(mr.launchedOn())).div(1 days);\r\n        if (mr.launched() \u0026\u0026 pd.capReached() != 1 \u0026\u0026 _days \u003c= 30) {\r\n            \r\n            if (mcrP \u003e= 10000)\r\n                pd.setCapReached(1);  \r\n            if (pd.capReached() != 1 \u0026\u0026 _days == 30)\r\n                pd.setCapReached(2);\r\n\r\n        }\r\n        uint len = pd.getMCRDataLength();\r\n        _addMCRData(len, onlyDate, curr, mcrE, mcrP, vF, _threeDayAvg);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds MCR Data for last failed attempt.\r\n     */  \r\n    function addLastMCRData(uint64 date) external checkPause  onlyInternal {\r\n        uint64 lastdate = uint64(pd.getLastMCRDate());\r\n        uint64 failedDate = uint64(date);\r\n        if (failedDate \u003e= lastdate) {\r\n            uint mcrP;\r\n            uint mcrE;\r\n            uint vF;\r\n            (mcrP, mcrE, vF, ) = pd.getLastMCR();\r\n            uint len = pd.getAllCurrenciesLen();\r\n            pd.pushMCRData(mcrP, mcrE, vF, date);\r\n            for (uint j = 0; j \u003c len; j++) {\r\n                bytes4 currName = pd.getCurrenciesByIndex(j);\r\n                pd.updateCAAvgRate(currName, pd.getCAAvgRate(currName));\r\n            }\r\n\r\n            emit MCREvent(date, block.number, new bytes4[](0), new uint[](0), mcrE, mcrP, vF);\r\n            // Oraclize call for next MCR calculation\r\n            _callOracliseForMCR();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Iupgradable Interface to update dependent contract address\r\n     */\r\n    function changeDependentContractAddress() public onlyInternal {\r\n        qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n        p1 = Pool1(ms.getLatestAddress(\"P1\"));\r\n        pd = PoolData(ms.getLatestAddress(\"PD\"));\r\n        tk = NXMToken(ms.tokenAddress());\r\n        mr = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n        td = TokenData(ms.getLatestAddress(\"TD\"));\r\n        proposalCategory = ProposalCategory(ms.getLatestAddress(\"PC\"));\r\n    }\r\n\r\n    /** \r\n     * @dev Gets total sum assured(in ETH).\r\n     * @return amount of sum assured\r\n     */  \r\n    function getAllSumAssurance() public view returns(uint amount) {\r\n        uint len = pd.getAllCurrenciesLen();\r\n        for (uint i = 0; i \u003c len; i++) {\r\n            bytes4 currName = pd.getCurrenciesByIndex(i);\r\n            if (currName == \"ETH\") {\r\n                amount = amount.add(qd.getTotalSumAssured(currName));\r\n            } else {\r\n                if (pd.getCAAvgRate(currName) \u003e 0)\r\n                    amount = amount.add((qd.getTotalSumAssured(currName).mul(100)).div(pd.getCAAvgRate(currName)));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates V(Tp) and MCR%(Tp), i.e, Pool Fund Value in Ether \r\n     * and MCR% used in the Token Price Calculation.\r\n     * @return vtp  Pool Fund Value in Ether used for the Token Price Model\r\n     * @return mcrtp MCR% used in the Token Price Model. \r\n     */ \r\n    function _calVtpAndMCRtp(uint poolBalance) public view returns(uint vtp, uint mcrtp) {\r\n        vtp = 0;\r\n        IERC20 erc20;\r\n        uint currTokens = 0;\r\n        uint i;\r\n        for (i = 1; i \u003c pd.getAllCurrenciesLen(); i++) {\r\n            bytes4 currency = pd.getCurrenciesByIndex(i);\r\n            erc20 = IERC20(pd.getCurrencyAssetAddress(currency));\r\n            currTokens = erc20.balanceOf(address(p1));\r\n            if (pd.getCAAvgRate(currency) \u003e 0)\r\n                vtp = vtp.add((currTokens.mul(100)).div(pd.getCAAvgRate(currency)));\r\n        }\r\n\r\n        vtp = vtp.add(poolBalance).add(p1.getInvestmentAssetBalance());\r\n        uint mcrFullperc;\r\n        uint vFull;\r\n        (mcrFullperc, , vFull, ) = pd.getLastMCR();\r\n        if (vFull \u003e 0) {\r\n            mcrtp = (mcrFullperc.mul(vtp)).div(vFull);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the Token Price of NXM in a given currency.\r\n     * @param curr Currency name.\r\n     \r\n     */\r\n    function calculateStepTokenPrice(\r\n        bytes4 curr,\r\n        uint mcrtp\r\n    ) \r\n        public\r\n        view\r\n        onlyInternal\r\n        returns(uint tokenPrice)\r\n    {\r\n        return _calculateTokenPrice(curr, mcrtp);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the Token Price of NXM in a given currency \r\n     * with provided token supply for dynamic token price calculation\r\n     * @param curr Currency name.\r\n     */ \r\n    function calculateTokenPrice (bytes4 curr) public view returns(uint tokenPrice) {\r\n        uint mcrtp;\r\n        (, mcrtp) = _calVtpAndMCRtp(address(p1).balance); \r\n        return _calculateTokenPrice(curr, mcrtp);\r\n    }\r\n    \r\n    function calVtpAndMCRtp() public view returns(uint vtp, uint mcrtp) {\r\n        return _calVtpAndMCRtp(address(p1).balance);\r\n    }\r\n\r\n    function calculateVtpAndMCRtp(uint poolBalance) public view returns(uint vtp, uint mcrtp) {\r\n        return _calVtpAndMCRtp(poolBalance);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets max numbers of tokens that can be sold at the moment.\r\n     */ \r\n    function getMaxSellTokens() public view returns(uint maxTokens) {\r\n        uint baseMin = pd.getCurrencyAssetBaseMin(\"ETH\");\r\n        uint maxTokensAccPoolBal;\r\n        if (address(p1).balance \u003e baseMin.mul(50).div(100)) {\r\n            maxTokensAccPoolBal = address(p1).balance.sub(\r\n            (baseMin.mul(50)).div(100));        \r\n        }\r\n        maxTokensAccPoolBal = (maxTokensAccPoolBal.mul(DECIMAL1E18)).div(\r\n            (calculateTokenPrice(\"ETH\").mul(975)).div(1000));\r\n        uint lastMCRPerc = pd.getLastMCRPerc();\r\n        if (lastMCRPerc \u003e 10000)\r\n            maxTokens = (((uint(lastMCRPerc).sub(10000)).mul(2000)).mul(DECIMAL1E18)).div(10000);\r\n        // require (false,\u0027rofl\u0027); \r\n        if (maxTokens \u003e maxTokensAccPoolBal)\r\n            maxTokens = maxTokensAccPoolBal;     \r\n    }\r\n\r\n    /** \r\n     * @dev Calls oraclize query to calculate MCR details after 24 hours.\r\n     */ \r\n    function _callOracliseForMCR() internal {\r\n        p1.mcrOraclise(pd.mcrTime());\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the Token Price of NXM in a given currency \r\n     * with provided token supply for dynamic token price calculation\r\n     * @param _curr Currency name.  \r\n     * @return tokenPrice Token price.\r\n     */ \r\n    function _calculateTokenPrice(\r\n        bytes4 _curr,\r\n        uint mcrtp\r\n    )\r\n        internal\r\n        view\r\n        returns(uint tokenPrice)\r\n    {\r\n        uint getA;\r\n        uint getC;\r\n        uint getCAAvgRate;\r\n        uint tokenExponentValue = td.tokenExponent();\r\n        // uint max = (mcrtp.mul(mcrtp).mul(mcrtp).mul(mcrtp));\r\n        uint max = mcrtp ** tokenExponentValue;\r\n        uint dividingFactor = tokenExponentValue.mul(4); \r\n        (getA, getC, getCAAvgRate) = pd.getTokenPriceDetails(_curr);\r\n        uint mcrEth = pd.getLastMCREther();\r\n        getC = getC.mul(DECIMAL1E18);\r\n        tokenPrice = (mcrEth.mul(DECIMAL1E18).mul(max).div(getC)).div(10 ** dividingFactor);\r\n        tokenPrice = tokenPrice.add(getA.mul(DECIMAL1E18).div(DECIMAL1E05));\r\n        tokenPrice = tokenPrice.mul(getCAAvgRate * 10); \r\n        tokenPrice = (tokenPrice).div(10**3);\r\n    } \r\n    \r\n    /**\r\n     * @dev Adds MCR Data. Checks if MCR is within valid \r\n     * thresholds in order to rule out any incorrect calculations \r\n     */  \r\n    function _addMCRData(\r\n        uint len,\r\n        uint64 newMCRDate,\r\n        bytes4[] memory curr,\r\n        uint mcrE,\r\n        uint mcrP,\r\n        uint vF,\r\n        uint[] memory _threeDayAvg\r\n    ) \r\n        internal\r\n    {\r\n        uint vtp = 0;\r\n        uint lower = 0;\r\n        uint lowerThreshold = 0;\r\n        uint upperThreshold = 0;\r\n        if (len \u003e 1) {\r\n            (vtp, ) = _calVtpAndMCRtp(address(p1).balance);\r\n            if (vtp \u003e= vF) {\r\n                upperThreshold = vtp.mul(100).div(pd.minCap());\r\n            } else {\r\n                upperThreshold = vF.mul(100).div(pd.minCap());\r\n            }\r\n\r\n            if (vtp \u003e 0) {\r\n                lower = (getAllSumAssurance().mul(100).mul(DECIMAL1E18)).div(pd.shockParameter());\r\n            }\r\n            if (lower \u003e 0) {\r\n                lowerThreshold = vtp.div(lower);\r\n            }\r\n        }\r\n        if (len == 1 || (mcrP.div(100)) \u003e= lowerThreshold \r\n            \u0026\u0026 (mcrP.div(100)) \u003c= upperThreshold) {\r\n            vtp = pd.getLastMCRDate(); // due to stack to deep error,we are reusing already declared variable\r\n            pd.pushMCRData(mcrP, mcrE, vF, newMCRDate);\r\n            for (uint i = 0; i \u003c curr.length; i++) {\r\n                pd.updateCAAvgRate(curr[i], _threeDayAvg[i]);\r\n            }\r\n            emit MCREvent(newMCRDate, block.number, curr, _threeDayAvg, mcrE, mcrP, vF);\r\n            // Oraclize call for next MCR calculation\r\n            if (vtp \u003c newMCRDate) {\r\n                _callOracliseForMCR();\r\n            }\r\n        } else {\r\n            p1.mcrOracliseFail(newMCRDate, pd.mcrFailTime());\r\n        }\r\n    }\r\n\r\n}\r\n"},"MemberRoles.sol":{"content":"/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\nimport \"./TokenFunctions.sol\";\r\nimport \"./IMemberRoles.sol\";\r\nimport \"./Governed.sol\";\r\nimport \"./TokenController.sol\";\r\nimport \"./ClaimsReward.sol\";\r\nimport \"./TokenData.sol\";\r\nimport \"./Governance.sol\";\r\nimport \"./QuotationData.sol\";\r\n\r\n\r\ncontract MemberRoles is IMemberRoles, Governed, Iupgradable {\r\n\r\n    TokenController public dAppToken;\r\n    TokenData internal td;\r\n    QuotationData internal qd;\r\n    ClaimsReward internal cr;\r\n    Governance internal gv;\r\n    TokenFunctions internal tf;\r\n    NXMToken public tk;\r\n\r\n    struct MemberRoleDetails {\r\n        uint memberCounter;\r\n        mapping(address =\u003e bool) memberActive;\r\n        address[] memberAddress;\r\n        address authorized;\r\n    }\r\n\r\n    enum Role {UnAssigned, AdvisoryBoard, Member, Owner}\r\n\r\n    MemberRoleDetails[] internal memberRoleData;\r\n    bool internal constructorCheck;\r\n    uint public maxABCount;\r\n    bool public launched;\r\n    uint public launchedOn;\r\n\r\n    modifier checkRoleAuthority(uint _memberRoleId) {\r\n        if (memberRoleData[_memberRoleId].authorized != address(0))\r\n            require(msg.sender == memberRoleData[_memberRoleId].authorized);\r\n        else\r\n            require(isAuthorizedToGovern(msg.sender), \"Not Authorized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev to swap advisory board member\r\n     * @param _newABAddress is address of new AB member\r\n     * @param _removeAB is advisory board member to be removed\r\n     */\r\n    function swapABMember (\r\n        address _newABAddress,\r\n        address _removeAB\r\n    )\r\n    external\r\n    checkRoleAuthority(uint(Role.AdvisoryBoard)) {\r\n\r\n        _updateRole(_newABAddress, uint(Role.AdvisoryBoard), true);\r\n        _updateRole(_removeAB, uint(Role.AdvisoryBoard), false);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev to swap the owner address\r\n     * @param _newOwnerAddress is the new owner address\r\n     */\r\n    function swapOwner (\r\n        address _newOwnerAddress\r\n    )\r\n    external {\r\n        require(msg.sender == address(ms));\r\n        _updateRole(ms.owner(), uint(Role.Owner), false);\r\n        _updateRole(_newOwnerAddress, uint(Role.Owner), true);\r\n    }\r\n\r\n    /**\r\n     * @dev is used to add initital advisory board members\r\n     * @param abArray is the list of initial advisory board members\r\n     */\r\n    function addInitialABMembers(address[] calldata abArray) external onlyOwner {\r\n\r\n        //Ensure that NXMaster has initialized.\r\n        require(ms.masterInitialized());\r\n\r\n        require(maxABCount \u003e= \r\n            SafeMath.add(numberOfMembers(uint(Role.AdvisoryBoard)), abArray.length)\r\n        );\r\n        //AB count can\u0027t exceed maxABCount\r\n        for (uint i = 0; i \u003c abArray.length; i++) {\r\n            require(checkRole(abArray[i], uint(MemberRoles.Role.Member)));\r\n            _updateRole(abArray[i], uint(Role.AdvisoryBoard), true);   \r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to change max number of AB members allowed\r\n     * @param _val is the new value to be set\r\n     */\r\n    function changeMaxABCount(uint _val) external onlyInternal {\r\n        maxABCount = _val;\r\n    }\r\n\r\n    /**\r\n     * @dev Iupgradable Interface to update dependent contract address\r\n     */\r\n    function changeDependentContractAddress() public {\r\n        td = TokenData(ms.getLatestAddress(\"TD\"));\r\n        cr = ClaimsReward(ms.getLatestAddress(\"CR\"));\r\n        qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n        gv = Governance(ms.getLatestAddress(\"GV\"));\r\n        tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\r\n        tk = NXMToken(ms.tokenAddress());\r\n        dAppToken = TokenController(ms.getLatestAddress(\"TC\"));\r\n    }\r\n\r\n    /**\r\n     * @dev to change the master address\r\n     * @param _masterAddress is the new master address\r\n     */\r\n    function changeMasterAddress(address _masterAddress) public {\r\n        if (masterAddress != address(0))\r\n            require(masterAddress == msg.sender);\r\n        masterAddress = _masterAddress;\r\n        ms = INXMMaster(_masterAddress);\r\n        nxMasterAddress = _masterAddress;\r\n        \r\n    }\r\n    \r\n    /**\r\n     * @dev to initiate the member roles\r\n     * @param _firstAB is the address of the first AB member\r\n     * @param memberAuthority is the authority (role) of the member\r\n     */\r\n    function memberRolesInitiate (address _firstAB, address memberAuthority) public {\r\n        require(!constructorCheck);\r\n        _addInitialMemberRoles(_firstAB, memberAuthority);\r\n        constructorCheck = true;\r\n    }\r\n\r\n    /// @dev Adds new member role\r\n    /// @param _roleName New role name\r\n    /// @param _roleDescription New description hash\r\n    /// @param _authorized Authorized member against every role id\r\n    function addRole( //solhint-disable-line\r\n        bytes32 _roleName,\r\n        string memory _roleDescription,\r\n        address _authorized\r\n    )\r\n    public\r\n    onlyAuthorizedToGovern {\r\n        _addRole(_roleName, _roleDescription, _authorized);\r\n    }\r\n\r\n    /// @dev Assign or Delete a member from specific role.\r\n    /// @param _memberAddress Address of Member\r\n    /// @param _roleId RoleId to update\r\n    /// @param _active active is set to be True if we want to assign this role to member, False otherwise!\r\n    function updateRole( //solhint-disable-line\r\n        address _memberAddress,\r\n        uint _roleId,\r\n        bool _active\r\n    )\r\n    public\r\n    checkRoleAuthority(_roleId) {\r\n        _updateRole(_memberAddress, _roleId, _active);\r\n    }\r\n\r\n    /**\r\n     * @dev to add members before launch\r\n     * @param userArray is list of addresses of members\r\n     * @param tokens is list of tokens minted for each array element\r\n     */\r\n    function addMembersBeforeLaunch(address[] memory userArray, uint[] memory tokens) public onlyOwner {\r\n        require(!launched);\r\n\r\n        for (uint i=0; i \u003c userArray.length; i++) {\r\n            require(!ms.isMember(userArray[i]));\r\n            dAppToken.addToWhitelist(userArray[i]);\r\n            _updateRole(userArray[i], uint(Role.Member), true);\r\n            dAppToken.mint(userArray[i], tokens[i]);\r\n        }\r\n        launched = true;\r\n        launchedOn = now;\r\n\r\n    }\r\n\r\n   /** \r\n     * @dev Called by user to pay joining membership fee\r\n     */ \r\n    function payJoiningFee(address _userAddress) public payable {\r\n        require(_userAddress != address(0));\r\n        require(!ms.isPause(), \"Emergency Pause Applied\");\r\n        if (msg.sender == address(ms.getLatestAddress(\"QT\"))) {\r\n            require(td.walletAddress() != address(0), \"No walletAddress present\");\r\n            dAppToken.addToWhitelist(_userAddress);\r\n            _updateRole(_userAddress, uint(Role.Member), true);            \r\n            td.walletAddress().transfer(msg.value); \r\n        } else {\r\n            require(!qd.refundEligible(_userAddress));\r\n            require(!ms.isMember(_userAddress));\r\n            require(msg.value == td.joiningFee());\r\n            qd.setRefundEligible(_userAddress, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to perform kyc verdict\r\n     * @param _userAddress whose kyc is being performed\r\n     * @param verdict of kyc process\r\n     */\r\n    function kycVerdict(address payable _userAddress, bool verdict) public {\r\n\r\n        require(msg.sender == qd.kycAuthAddress());\r\n        require(!ms.isPause());\r\n        require(_userAddress != address(0));\r\n        require(!ms.isMember(_userAddress));\r\n        require(qd.refundEligible(_userAddress));\r\n        if (verdict) {\r\n            qd.setRefundEligible(_userAddress, false);\r\n            uint fee = td.joiningFee();\r\n            dAppToken.addToWhitelist(_userAddress);\r\n            _updateRole(_userAddress, uint(Role.Member), true);\r\n            td.walletAddress().transfer(fee); //solhint-disable-line\r\n            \r\n        } else {\r\n            qd.setRefundEligible(_userAddress, false);\r\n            _userAddress.transfer(td.joiningFee()); //solhint-disable-line\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Called by existed member if if wish to Withdraw membership.\r\n     */\r\n    function withdrawMembership() public {\r\n        require(!ms.isPause() \u0026\u0026 ms.isMember(msg.sender));\r\n        require(dAppToken.totalLockedBalance(msg.sender, now) == 0); //solhint-disable-line\r\n        require(!tf.isLockedForMemberVote(msg.sender)); // No locked tokens for Member/Governance voting\r\n        require(cr.getAllPendingRewardOfUser(msg.sender) == 0); // No pending reward to be claimed(claim assesment).\r\n        gv.removeDelegation(msg.sender);\r\n        dAppToken.burnFrom(msg.sender, tk.balanceOf(msg.sender));\r\n        _updateRole(msg.sender, uint(Role.Member), false);\r\n        dAppToken.removeFromWhitelist(msg.sender); // need clarification on whitelist        \r\n    }\r\n\r\n    /// @dev Return number of member roles\r\n    function totalRoles() public view returns(uint256) { //solhint-disable-line\r\n        return memberRoleData.length;\r\n    }\r\n\r\n    /// @dev Change Member Address who holds the authority to Add/Delete any member from specific role.\r\n    /// @param _roleId roleId to update its Authorized Address\r\n    /// @param _newAuthorized New authorized address against role id\r\n    function changeAuthorized(uint _roleId, address _newAuthorized) public checkRoleAuthority(_roleId) { //solhint-disable-line\r\n        memberRoleData[_roleId].authorized = _newAuthorized;\r\n    }\r\n\r\n    /// @dev Gets the member addresses assigned by a specific role\r\n    /// @param _memberRoleId Member role id\r\n    /// @return roleId Role id\r\n    /// @return allMemberAddress Member addresses of specified role id\r\n    function members(uint _memberRoleId) public view returns(uint, address[] memory memberArray) { //solhint-disable-line\r\n        uint length = memberRoleData[_memberRoleId].memberAddress.length;\r\n        uint i;\r\n        uint j = 0;\r\n        memberArray = new address[](memberRoleData[_memberRoleId].memberCounter);\r\n        for (i = 0; i \u003c length; i++) {\r\n            address member = memberRoleData[_memberRoleId].memberAddress[i];\r\n            if (memberRoleData[_memberRoleId].memberActive[member] \u0026\u0026 !_checkMemberInArray(member, memberArray)) { //solhint-disable-line\r\n                memberArray[j] = member;\r\n                j++;\r\n            }\r\n        }\r\n\r\n        return (_memberRoleId, memberArray);\r\n    }\r\n\r\n    /// @dev Gets all members\u0027 length\r\n    /// @param _memberRoleId Member role id\r\n    /// @return memberRoleData[_memberRoleId].memberCounter Member length\r\n    function numberOfMembers(uint _memberRoleId) public view returns(uint) { //solhint-disable-line\r\n        return memberRoleData[_memberRoleId].memberCounter;\r\n    }\r\n\r\n    /// @dev Return member address who holds the right to add/remove any member from specific role.\r\n    function authorized(uint _memberRoleId) public view returns(address) { //solhint-disable-line\r\n        return memberRoleData[_memberRoleId].authorized;\r\n    }\r\n\r\n    /// @dev Get All role ids array that has been assigned to a member so far.\r\n    function roles(address _memberAddress) public view returns(uint[] memory) { //solhint-disable-line\r\n        uint length = memberRoleData.length;\r\n        uint[] memory assignedRoles = new uint[](length);\r\n        uint counter = 0; \r\n        for (uint i = 1; i \u003c length; i++) {\r\n            if (memberRoleData[i].memberActive[_memberAddress]) {\r\n                assignedRoles[counter] = i;\r\n                counter++;\r\n            }\r\n        }\r\n        return assignedRoles;\r\n    }\r\n\r\n    /// @dev Returns true if the given role id is assigned to a member.\r\n    /// @param _memberAddress Address of member\r\n    /// @param _roleId Checks member\u0027s authenticity with the roleId.\r\n    /// i.e. Returns true if this roleId is assigned to member\r\n    function checkRole(address _memberAddress, uint _roleId) public view returns(bool) { //solhint-disable-line\r\n        if (_roleId == uint(Role.UnAssigned))\r\n            return true;\r\n        else\r\n            if (memberRoleData[_roleId].memberActive[_memberAddress]) //solhint-disable-line\r\n                return true;\r\n            else\r\n                return false;\r\n    }\r\n\r\n    /// @dev Return total number of members assigned against each role id.\r\n    /// @return totalMembers Total members in particular role id\r\n    function getMemberLengthForAllRoles() public view returns(uint[] memory totalMembers) { //solhint-disable-line\r\n        totalMembers = new uint[](memberRoleData.length);\r\n        for (uint i = 0; i \u003c memberRoleData.length; i++) {\r\n            totalMembers[i] = numberOfMembers(i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to update the member roles\r\n     * @param _memberAddress in concern\r\n     * @param _roleId the id of role\r\n     * @param _active if active is true, add the member, else remove it \r\n     */\r\n    function _updateRole(address _memberAddress,\r\n        uint _roleId,\r\n        bool _active) internal {\r\n        // require(_roleId != uint(Role.TokenHolder), \"Membership to Token holder is detected automatically\");\r\n        if (_active) {\r\n            require(!memberRoleData[_roleId].memberActive[_memberAddress]);\r\n            memberRoleData[_roleId].memberCounter = SafeMath.add(memberRoleData[_roleId].memberCounter, 1);\r\n            memberRoleData[_roleId].memberActive[_memberAddress] = true;\r\n            memberRoleData[_roleId].memberAddress.push(_memberAddress);\r\n        } else {\r\n            require(memberRoleData[_roleId].memberActive[_memberAddress]);\r\n            memberRoleData[_roleId].memberCounter = SafeMath.sub(memberRoleData[_roleId].memberCounter, 1);\r\n            delete memberRoleData[_roleId].memberActive[_memberAddress];\r\n        }\r\n    }\r\n\r\n    /// @dev Adds new member role\r\n    /// @param _roleName New role name\r\n    /// @param _roleDescription New description hash\r\n    /// @param _authorized Authorized member against every role id\r\n    function _addRole(\r\n        bytes32 _roleName,\r\n        string memory _roleDescription,\r\n        address _authorized\r\n    ) internal {\r\n        emit MemberRole(memberRoleData.length, _roleName, _roleDescription);\r\n        memberRoleData.push(MemberRoleDetails(0, new address[](0), _authorized));\r\n    }\r\n\r\n    /**\r\n     * @dev to check if member is in the given member array\r\n     * @param _memberAddress in concern\r\n     * @param memberArray in concern\r\n     * @return boolean to represent the presence\r\n     */\r\n    function _checkMemberInArray(\r\n        address _memberAddress,\r\n        address[] memory memberArray\r\n    )\r\n        internal\r\n        pure\r\n        returns(bool memberExists)\r\n    {\r\n        uint i;\r\n        for (i = 0; i \u003c memberArray.length; i++) {\r\n            if (memberArray[i] == _memberAddress) {\r\n                memberExists = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to add initial member roles\r\n     * @param _firstAB is the member address to be added\r\n     * @param memberAuthority is the member authority(role) to be added for\r\n     */\r\n    function _addInitialMemberRoles(address _firstAB, address memberAuthority) internal {\r\n        maxABCount = 5;\r\n        _addRole(\"Unassigned\", \"Unassigned\", address(0));\r\n        _addRole(\r\n            \"Advisory Board\",\r\n            \"Selected few members that are deeply entrusted by the dApp. An ideal advisory board should be a mix of skills of domain, governance, research, technology, consulting etc to improve the performance of the dApp.\", //solhint-disable-line\r\n            address(0)\r\n        );\r\n        _addRole(\r\n            \"Member\",\r\n            \"Represents all users of Mutual.\", //solhint-disable-line\r\n            memberAuthority\r\n        );\r\n        _addRole(\r\n            \"Owner\",\r\n            \"Represents Owner of Mutual.\", //solhint-disable-line\r\n            address(0)\r\n        );\r\n        // _updateRole(_firstAB, uint(Role.AdvisoryBoard), true);\r\n        _updateRole(_firstAB, uint(Role.Owner), true);\r\n        // _updateRole(_firstAB, uint(Role.Member), true);\r\n        launchedOn = 0;\r\n    }\r\n\r\n}"},"NXMToken.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\n\r\ncontract NXMToken is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    event WhiteListed(address indexed member);\r\n\r\n    event BlackListed(address indexed member);\r\n\r\n    mapping (address =\u003e uint256) private _balances;\r\n\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowed;\r\n\r\n    mapping (address =\u003e bool) public whiteListed;\r\n\r\n    mapping(address =\u003e uint) public isLockedForMV;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string public name = \"NXM\";\r\n    string public symbol = \"NXM\";\r\n    uint8 public decimals = 18;\r\n    address public operator;\r\n\r\n    modifier canTransfer(address _to) {\r\n        require(whiteListed[_to]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        if (operator != address(0))\r\n            require(msg.sender == operator);\r\n        _;\r\n    }\r\n\r\n    constructor(address _founderAddress, uint _initialSupply) public {\r\n        _mint(_founderAddress, _initialSupply);\r\n    }\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param owner The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param owner address The address which owns the funds.\r\n    * @param spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender\u0027s allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param spender The address which will spend the funds.\r\n    * @param value The amount of tokens to be spent.\r\n    */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed_[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param spender The address which will spend the funds.\r\n    * @param addedValue The amount of tokens to increase the allowance by.\r\n    */\r\n    function increaseAllowance(\r\n        address spender,\r\n        uint256 addedValue\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = (\r\n        _allowed[msg.sender][spender].add(addedValue));\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed_[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param spender The address which will spend the funds.\r\n    * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseAllowance(\r\n        address spender,\r\n        uint256 subtractedValue\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = (\r\n        _allowed[msg.sender][spender].sub(subtractedValue));\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds a user to whitelist\r\n    * @param _member address to add to whitelist\r\n    */\r\n    function addToWhiteList(address _member) public onlyOperator returns (bool) {\r\n        whiteListed[_member] = true;\r\n        emit WhiteListed(_member);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev removes a user from whitelist\r\n    * @param _member address to remove from whitelist\r\n    */\r\n    function removeFromWhiteList(address _member) public onlyOperator returns (bool) {\r\n        whiteListed[_member] = false;\r\n        emit BlackListed(_member);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev change operator address \r\n    * @param _newOperator address of new operator\r\n    */\r\n    function changeOperator(address _newOperator) public onlyOperator returns (bool) {\r\n        operator = _newOperator;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev burns an amount of the tokens of the message sender\r\n    * account.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function burn(uint256 amount) public returns (bool) {\r\n        _burn(msg.sender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Burns a specific amount of tokens from the target address and decrements allowance\r\n    * @param from address The address which you want to send tokens from\r\n    * @param value uint256 The amount of token to be burned\r\n    */\r\n    function burnFrom(address from, uint256 value) public returns (bool) {\r\n        _burnFrom(from, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev function that mints an amount of the token and assigns it to\r\n    * an account.\r\n    * @param account The account that will receive the created tokens.\r\n    * @param amount The amount that will be created.\r\n    */\r\n    function mint(address account, uint256 amount) public onlyOperator {\r\n        _mint(account, amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function transfer(address to, uint256 value) public canTransfer(to) returns (bool) {\r\n\r\n        require(isLockedForMV[msg.sender] \u003c now); // if not voted under governance\r\n        require(value \u003c= _balances[msg.sender]);\r\n        _transfer(to, value); \r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens to the operator from the specified address\r\n    * @param from The address to transfer from.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function operatorTransfer(address from, uint256 value) public onlyOperator returns (bool) {\r\n        require(value \u003c= _balances[from]);\r\n        _transferFrom(from, operator, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param from address The address which you want to send tokens from\r\n    * @param to address The address which you want to transfer to\r\n    * @param value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    )\r\n        public\r\n        canTransfer(to)\r\n        returns (bool)\r\n    {\r\n        require(isLockedForMV[from] \u003c now); // if not voted under governance\r\n        require(value \u003c= _balances[from]);\r\n        require(value \u003c= _allowed[from][msg.sender]);\r\n        _transferFrom(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Lock the user\u0027s tokens \r\n     * @param _of user\u0027s address.\r\n     */\r\n    function lockForMemberVote(address _of, uint _days) public onlyOperator {\r\n        if (_days.add(now) \u003e isLockedForMV[_of])\r\n            isLockedForMV[_of] = _days.add(now);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function _transfer(address to, uint256 value) internal {\r\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(msg.sender, to, value);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param from address The address which you want to send tokens from\r\n    * @param to address The address which you want to transfer to\r\n    * @param value uint256 the amount of tokens to be transferred\r\n    */\r\n    function _transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    )\r\n        internal\r\n    {\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that mints an amount of the token and assigns it to\r\n    * an account. This encapsulates the modification of balances such that the\r\n    * proper events are emitted.\r\n    * @param account The account that will receive the created tokens.\r\n    * @param amount The amount that will be created.\r\n    */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0));\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that burns an amount of the token of a given\r\n    * account.\r\n    * @param account The account whose tokens will be burnt.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(amount \u003c= _balances[account]);\r\n\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        _balances[account] = _balances[account].sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that burns an amount of the token of a given\r\n    * account, deducting from the sender\u0027s allowance for said account. Uses the\r\n    * internal burn function.\r\n    * @param account The account whose tokens will be burnt.\r\n    * @param value The amount that will be burnt.\r\n    */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        require(value \u003c= _allowed[account][msg.sender]);\r\n\r\n        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\r\n        // this function needs to emit an event with the updated approval.\r\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\r\n        value);\r\n        _burn(account, value);\r\n    }\r\n}"},"Pool1.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\nimport \"./PoolData.sol\";\r\nimport \"./usingOraclize.sol\";\r\nimport \"./Claims.sol\";\r\nimport \"./Quotation.sol\";\r\nimport \"./Pool2.sol\";\r\nimport \"./MCR.sol\";\r\n\r\n\r\ncontract Pool1 is usingOraclize, Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    Quotation internal q2;\r\n    NXMToken internal tk;\r\n    TokenController internal tc;\r\n    TokenFunctions internal tf;\r\n    Pool2 internal p2;\r\n    PoolData internal pd;\r\n    MCR internal m1;\r\n    Claims public c1;\r\n    TokenData internal td;\r\n    bool internal locked;\r\n\r\n    uint internal constant DECIMAL1E18 = uint(10) ** 18;\r\n    // uint internal constant PRICE_STEP = uint(1000) * DECIMAL1E18;\r\n\r\n    event Apiresult(address indexed sender, string msg, bytes32 myid);\r\n    event Payout(address indexed to, uint coverId, uint tokens);\r\n\r\n    modifier noReentrancy() {\r\n        require(!locked, \"Reentrant call.\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    function () external payable {} //solhint-disable-line\r\n\r\n    /**\r\n     * @dev Pays out the sum assured in case a claim is accepted\r\n     * @param coverid Cover Id.\r\n     * @param claimid Claim Id.\r\n     * @return succ true if payout is successful, false otherwise. \r\n     */ \r\n    function sendClaimPayout(\r\n        uint coverid,\r\n        uint claimid,\r\n        uint sumAssured,\r\n        address payable coverHolder,\r\n        bytes4 coverCurr\r\n    )\r\n        external\r\n        onlyInternal\r\n        noReentrancy\r\n        returns(bool succ)\r\n    {\r\n        \r\n        uint sa = sumAssured.div(DECIMAL1E18);\r\n        bool check;\r\n        IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\r\n\r\n        //Payout\r\n        if (coverCurr == \"ETH\" \u0026\u0026 address(this).balance \u003e= sumAssured) {\r\n            // check = _transferCurrencyAsset(coverCurr, coverHolder, sumAssured);\r\n            coverHolder.transfer(sumAssured);\r\n            check = true;\r\n        } else if (coverCurr == \"DAI\" \u0026\u0026 erc20.balanceOf(address(this)) \u003e= sumAssured) {\r\n            erc20.transfer(coverHolder, sumAssured);\r\n            check = true;\r\n        }\r\n        \r\n        if (check == true) {\r\n            q2.removeSAFromCSA(coverid, sa);\r\n            pd.changeCurrencyAssetVarMin(coverCurr, \r\n                pd.getCurrencyAssetVarMin(coverCurr).sub(sumAssured));\r\n            emit Payout(coverHolder, coverid, sumAssured);\r\n            succ = true;\r\n        } else {\r\n            c1.setClaimStatus(claimid, 12);\r\n        }\r\n        _triggerExternalLiquidityTrade();\r\n        // p2.internalLiquiditySwap(coverCurr);\r\n\r\n        tf.burnStakerLockedToken(coverid, coverCurr, sumAssured);\r\n    }\r\n\r\n    /**\r\n     * @dev to trigger external liquidity trade\r\n     */\r\n    function triggerExternalLiquidityTrade() external onlyInternal {\r\n        _triggerExternalLiquidityTrade();\r\n    }\r\n\r\n    ///@dev Oraclize call to close emergency pause.\r\n    function closeEmergencyPause(uint time) external onlyInternal {\r\n        bytes32 myid = _oraclizeQuery(4, time, \"URL\", \"\", 300000);\r\n        _saveApiDetails(myid, \"EP\", 0);\r\n    }\r\n\r\n    /// @dev Calls the Oraclize Query to close a given Claim after a given period of time.\r\n    /// @param id Claim Id to be closed\r\n    /// @param time Time (in seconds) after which Claims assessment voting needs to be closed\r\n    function closeClaimsOraclise(uint id, uint time) external onlyInternal {\r\n        bytes32 myid = _oraclizeQuery(4, time, \"URL\", \"\", 3000000);\r\n        _saveApiDetails(myid, \"CLA\", id);\r\n    }\r\n\r\n    /// @dev Calls Oraclize Query to expire a given Cover after a given period of time.\r\n    /// @param id Quote Id to be expired\r\n    /// @param time Time (in seconds) after which the cover should be expired\r\n    function closeCoverOraclise(uint id, uint64 time) external onlyInternal {\r\n        bytes32 myid = _oraclizeQuery(4, time, \"URL\", strConcat(\r\n            \"http://a1.nexusmutual.io/api/Claims/closeClaim_hash/\", uint2str(id)), 1000000);\r\n        _saveApiDetails(myid, \"COV\", id);\r\n    }\r\n\r\n    /// @dev Calls the Oraclize Query to initiate MCR calculation.\r\n    /// @param time Time (in milliseconds) after which the next MCR calculation should be initiated\r\n    function mcrOraclise(uint time) external onlyInternal {\r\n        bytes32 myid = _oraclizeQuery(3, time, \"URL\", \"https://api.nexusmutual.io/postMCR/M1\", 0);\r\n        _saveApiDetails(myid, \"MCR\", 0);\r\n    }\r\n\r\n    /// @dev Calls the Oraclize Query in case MCR calculation fails.\r\n    /// @param time Time (in seconds) after which the next MCR calculation should be initiated\r\n    function mcrOracliseFail(uint id, uint time) external onlyInternal {\r\n        bytes32 myid = _oraclizeQuery(4, time, \"URL\", \"\", 1000000);\r\n        _saveApiDetails(myid, \"MCRF\", id);\r\n    }\r\n\r\n    /// @dev Oraclize call to update investment asset rates.\r\n    function saveIADetailsOracalise(uint time) external onlyInternal {\r\n        bytes32 myid = _oraclizeQuery(3, time, \"URL\", \"https://api.nexusmutual.io/saveIADetails/M1\", 0);\r\n        _saveApiDetails(myid, \"IARB\", 0);\r\n    }\r\n    \r\n    /**\r\n     * @dev Transfers all assest (i.e ETH balance, Currency Assest) from old Pool to new Pool\r\n     * @param newPoolAddress Address of the new Pool\r\n     */\r\n    function upgradeCapitalPool(address payable newPoolAddress) external noReentrancy onlyInternal {\r\n        for (uint64 i = 1; i \u003c pd.getAllCurrenciesLen(); i++) {\r\n            bytes4 caName = pd.getCurrenciesByIndex(i);\r\n            _upgradeCapitalPool(caName, newPoolAddress);\r\n        }\r\n        if (address(this).balance \u003e 0) {\r\n            Pool1 newP1 = Pool1(newPoolAddress);\r\n            newP1.sendEther.value(address(this).balance)();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Iupgradable Interface to update dependent contract address\r\n     */\r\n    function changeDependentContractAddress() public {\r\n        m1 = MCR(ms.getLatestAddress(\"MC\"));\r\n        tk = NXMToken(ms.tokenAddress());\r\n        tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\r\n        tc = TokenController(ms.getLatestAddress(\"TC\"));\r\n        pd = PoolData(ms.getLatestAddress(\"PD\"));\r\n        q2 = Quotation(ms.getLatestAddress(\"QT\"));\r\n        p2 = Pool2(ms.getLatestAddress(\"P2\"));\r\n        c1 = Claims(ms.getLatestAddress(\"CL\"));\r\n        td = TokenData(ms.getLatestAddress(\"TD\"));\r\n    }\r\n\r\n    function sendEther() public payable {\r\n        \r\n    }\r\n\r\n    /**\r\n     * @dev transfers currency asset to an address\r\n     * @param curr is the currency of currency asset to transfer\r\n     * @param amount is amount of currency asset to transfer\r\n     * @return boolean to represent success or failure\r\n     */\r\n    function transferCurrencyAsset(\r\n        bytes4 curr,\r\n        uint amount\r\n    )\r\n        public\r\n        onlyInternal\r\n        noReentrancy\r\n        returns(bool)\r\n    {\r\n    \r\n        return _transferCurrencyAsset(curr, amount);\r\n    } \r\n\r\n    /// @dev Handles callback of external oracle query.\r\n    function __callback(bytes32 myid, string memory result) public {\r\n        result; //silence compiler warning\r\n        // owner will be removed from production build\r\n        ms.delegateCallBack(myid);\r\n    }\r\n\r\n    /// @dev Enables user to purchase cover with funding in ETH.\r\n    /// @param smartCAdd Smart Contract Address\r\n    function makeCoverBegin(\r\n        address smartCAdd,\r\n        bytes4 coverCurr,\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        public\r\n        isMember\r\n        checkPause\r\n        payable\r\n    {\r\n        require(msg.value == coverDetails[1]);\r\n        q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\r\n    }\r\n\r\n    /**\r\n     * @dev Enables user to purchase cover via currency asset eg DAI\r\n     */ \r\n    function makeCoverUsingCA(\r\n        address smartCAdd,\r\n        bytes4 coverCurr,\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) \r\n        public\r\n        isMember\r\n        checkPause\r\n    {\r\n        IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\r\n        require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]), \"Transfer failed\");\r\n        q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\r\n    }\r\n\r\n    /// @dev Enables user to purchase NXM at the current token price.\r\n    function buyToken() public payable isMember checkPause returns(bool success) {\r\n        require(msg.value \u003e 0);\r\n        uint tokenPurchased = _getToken(address(this).balance, msg.value);\r\n        tc.mint(msg.sender, tokenPurchased);\r\n        success = true;\r\n    }\r\n\r\n    /// @dev Sends a given amount of Ether to a given address.\r\n    /// @param amount amount (in wei) to send.\r\n    /// @param _add Receiver\u0027s address.\r\n    /// @return succ True if transfer is a success, otherwise False.\r\n    function transferEther(uint amount, address payable _add) public noReentrancy checkPause returns(bool succ) {\r\n        require(ms.checkIsAuthToGoverned(msg.sender), \"Not authorized to Govern\");\r\n        succ = _add.send(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows selling of NXM for ether.\r\n     * Seller first needs to give this contract allowance to\r\n     * transfer/burn tokens in the NXMToken contract\r\n     * @param  _amount Amount of NXM to sell\r\n     * @return success returns true on successfull sale\r\n     */\r\n    function sellNXMTokens(uint _amount) public isMember noReentrancy checkPause returns(bool success) {\r\n        require(tk.balanceOf(msg.sender) \u003e= _amount, \"Not enough balance\");\r\n        require(!tf.isLockedForMemberVote(msg.sender), \"Member voted\");\r\n        require(_amount \u003c= m1.getMaxSellTokens(), \"exceeds maximum token sell limit\");\r\n        uint sellingPrice = _getWei(_amount);\r\n        tc.burnFrom(msg.sender, _amount);\r\n        msg.sender.transfer(sellingPrice);\r\n        success = true;\r\n    }\r\n\r\n    /**\r\n     * @dev gives the investment asset balance\r\n     * @return investment asset balance\r\n     */\r\n    function getInvestmentAssetBalance() public view returns (uint balance) {\r\n        IERC20 erc20;\r\n        uint currTokens;\r\n        for (uint i = 1; i \u003c pd.getInvestmentCurrencyLen(); i++) {\r\n            bytes4 currency = pd.getInvestmentCurrencyByIndex(i);\r\n            erc20 = IERC20(pd.getInvestmentAssetAddress(currency));\r\n            currTokens = erc20.balanceOf(address(p2));\r\n            if (pd.getIAAvgRate(currency) \u003e 0)\r\n                balance = balance.add((currTokens.mul(100)).div(pd.getIAAvgRate(currency)));\r\n        }\r\n\r\n        balance = balance.add(address(p2).balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of wei a seller will get for selling NXM\r\n     * @param amount Amount of NXM to sell\r\n     * @return weiToPay Amount of wei the seller will get\r\n     */\r\n    function getWei(uint amount) public view returns(uint weiToPay) {\r\n        return _getWei(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of token a buyer will get for corresponding wei\r\n     * @param weiPaid Amount of wei \r\n     * @return tokenToGet Amount of tokens the buyer will get\r\n     */\r\n    function getToken(uint weiPaid) public view returns(uint tokenToGet) {\r\n        return _getToken((address(this).balance).add(weiPaid), weiPaid);\r\n    }\r\n\r\n    /**\r\n     * @dev to trigger external liquidity trade\r\n     */\r\n    function _triggerExternalLiquidityTrade() internal {\r\n        if (now \u003e pd.lastLiquidityTradeTrigger().add(pd.liquidityTradeCallbackTime())) {\r\n            pd.setLastLiquidityTradeTrigger();\r\n            bytes32 myid = _oraclizeQuery(4, pd.liquidityTradeCallbackTime(), \"URL\", \"\", 300000);\r\n            _saveApiDetails(myid, \"ULT\", 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of wei a seller will get for selling NXM\r\n     * @param _amount Amount of NXM to sell\r\n     * @return weiToPay Amount of wei the seller will get\r\n     */\r\n    function _getWei(uint _amount) internal view returns(uint weiToPay) {\r\n        uint tokenPrice;\r\n        uint weiPaid;\r\n        uint tokenSupply = tk.totalSupply();\r\n        uint vtp;\r\n        uint mcrFullperc;\r\n        uint vFull;\r\n        uint mcrtp;\r\n        (mcrFullperc, , vFull, ) = pd.getLastMCR();\r\n        (vtp, ) = m1.calVtpAndMCRtp();\r\n\r\n        while (_amount \u003e 0) {\r\n            mcrtp = (mcrFullperc.mul(vtp)).div(vFull);\r\n            tokenPrice = m1.calculateStepTokenPrice(\"ETH\", mcrtp);\r\n            tokenPrice = (tokenPrice.mul(975)).div(1000); //97.5%\r\n            if (_amount \u003c= td.priceStep().mul(DECIMAL1E18)) {\r\n                weiToPay = weiToPay.add((tokenPrice.mul(_amount)).div(DECIMAL1E18));\r\n                break;\r\n            } else {\r\n                _amount = _amount.sub(td.priceStep().mul(DECIMAL1E18));\r\n                tokenSupply = tokenSupply.sub(td.priceStep().mul(DECIMAL1E18));\r\n                weiPaid = (tokenPrice.mul(td.priceStep().mul(DECIMAL1E18))).div(DECIMAL1E18);\r\n                vtp = vtp.sub(weiPaid);\r\n                weiToPay = weiToPay.add(weiPaid);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev gives the token\r\n     * @param _poolBalance is the pool balance\r\n     * @param _weiPaid is the amount paid in wei\r\n     * @return the token to get\r\n     */\r\n    function _getToken(uint _poolBalance, uint _weiPaid) internal view returns(uint tokenToGet) {\r\n        uint tokenPrice;\r\n        uint superWeiLeft = (_weiPaid).mul(DECIMAL1E18);\r\n        uint tempTokens;\r\n        uint superWeiSpent;\r\n        uint tokenSupply = tk.totalSupply();\r\n        uint vtp;\r\n        uint mcrFullperc;   \r\n        uint vFull;\r\n        uint mcrtp;\r\n        (mcrFullperc, , vFull, ) = pd.getLastMCR();\r\n        (vtp, ) = m1.calculateVtpAndMCRtp((_poolBalance).sub(_weiPaid));\r\n\r\n        require(m1.calculateTokenPrice(\"ETH\") \u003e 0, \"Token price can not be zero\");\r\n        while (superWeiLeft \u003e 0) {\r\n            mcrtp = (mcrFullperc.mul(vtp)).div(vFull);\r\n            tokenPrice = m1.calculateStepTokenPrice(\"ETH\", mcrtp);            \r\n            tempTokens = superWeiLeft.div(tokenPrice);\r\n            if (tempTokens \u003c= td.priceStep().mul(DECIMAL1E18)) {\r\n                tokenToGet = tokenToGet.add(tempTokens);\r\n                break;\r\n            } else {\r\n                tokenToGet = tokenToGet.add(td.priceStep().mul(DECIMAL1E18));\r\n                tokenSupply = tokenSupply.add(td.priceStep().mul(DECIMAL1E18));\r\n                superWeiSpent = td.priceStep().mul(DECIMAL1E18).mul(tokenPrice);\r\n                superWeiLeft = superWeiLeft.sub(superWeiSpent);\r\n                vtp = vtp.add((td.priceStep().mul(DECIMAL1E18).mul(tokenPrice)).div(DECIMAL1E18));\r\n            }\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev Save the details of the Oraclize API.\r\n     * @param myid Id return by the oraclize query.\r\n     * @param _typeof type of the query for which oraclize call is made.\r\n     * @param id ID of the proposal, quote, cover etc. for which oraclize call is made.\r\n     */ \r\n    function _saveApiDetails(bytes32 myid, bytes4 _typeof, uint id) internal {\r\n        pd.saveApiDetails(myid, _typeof, id);\r\n        pd.addInAllApiCall(myid);\r\n    }\r\n\r\n    /**\r\n     * @dev transfers currency asset\r\n     * @param _curr is currency of asset to transfer\r\n     * @param _amount is the amount to be transferred\r\n     * @return boolean representing the success of transfer\r\n     */\r\n    function _transferCurrencyAsset(bytes4 _curr, uint _amount) internal returns(bool succ) {\r\n        if (_curr == \"ETH\") {\r\n            if (address(this).balance \u003c _amount)\r\n                _amount = address(this).balance;\r\n            p2.sendEther.value(_amount)();\r\n            succ = true;\r\n        } else {\r\n            IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(_curr)); //solhint-disable-line\r\n            if (erc20.balanceOf(address(this)) \u003c _amount) \r\n                _amount = erc20.balanceOf(address(this));\r\n            require(erc20.transfer(address(p2), _amount)); \r\n            succ = true;\r\n            \r\n        }\r\n    } \r\n\r\n    /** \r\n     * @dev Transfers ERC20 Currency asset from this Pool to another Pool on upgrade.\r\n     */ \r\n    function _upgradeCapitalPool(\r\n        bytes4 _curr,\r\n        address _newPoolAddress\r\n    ) \r\n        internal\r\n    {\r\n        IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(_curr));\r\n        if (erc20.balanceOf(address(this)) \u003e 0)\r\n            require(erc20.transfer(_newPoolAddress, erc20.balanceOf(address(this))));\r\n    }\r\n\r\n    /**\r\n     * @dev oraclize query\r\n     * @param paramCount is number of paramters passed\r\n     * @param timestamp is the current timestamp\r\n     * @param datasource in concern\r\n     * @param arg in concern\r\n     * @param gasLimit required for query\r\n     * @return id of oraclize query\r\n     */\r\n    function _oraclizeQuery(\r\n        uint paramCount,\r\n        uint timestamp,\r\n        string memory datasource,\r\n        string memory arg,\r\n        uint gasLimit\r\n    ) \r\n        internal\r\n        returns (bytes32 id)\r\n    {\r\n        if (paramCount == 4) {\r\n            id = oraclize_query(timestamp, datasource, arg, gasLimit);   \r\n        } else if (paramCount == 3) {\r\n            id = oraclize_query(timestamp, datasource, arg);   \r\n        } else {\r\n            id = oraclize_query(datasource, arg);\r\n        }\r\n    }\r\n}\r\n"},"Pool2.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Quotation.sol\";\r\nimport \"./ClaimsReward.sol\";\r\nimport \"./solidity-interface.sol\";\r\n\r\n\r\ncontract Pool2 is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    MCR internal m1;\r\n    Pool1 internal p1;\r\n    PoolData internal pd;\r\n    Factory internal factory;\r\n    address public uniswapFactoryAddress;\r\n    uint internal constant DECIMAL1E18 = uint(10) ** 18;\r\n    bool internal locked;\r\n\r\n    constructor(address _uniswapFactoryAdd) public {\r\n       \r\n        uniswapFactoryAddress = _uniswapFactoryAdd;\r\n        factory = Factory(_uniswapFactoryAdd);\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n    event Liquidity(bytes16 typeOf, bytes16 functionName);\r\n\r\n    event Rebalancing(bytes4 iaCurr, uint tokenAmount);\r\n\r\n    modifier noReentrancy() {\r\n        require(!locked, \"Reentrant call.\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    /**\r\n     * @dev to change the uniswap factory address \r\n     * @param newFactoryAddress is the new factory address in concern\r\n     * @return the status of the concerned coverId\r\n     */\r\n    function changeUniswapFactoryAddress(address newFactoryAddress) external onlyInternal {\r\n        // require(ms.isOwner(msg.sender) || ms.checkIsAuthToGoverned(msg.sender));\r\n        uniswapFactoryAddress = newFactoryAddress;\r\n        factory = Factory(uniswapFactoryAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev On upgrade transfer all investment assets and ether to new Investment Pool\r\n     * @param newPoolAddress New Investment Assest Pool address\r\n     */\r\n    function upgradeInvestmentPool(address payable newPoolAddress) external onlyInternal noReentrancy {\r\n        uint len = pd.getInvestmentCurrencyLen();\r\n        for (uint64 i = 1; i \u003c len; i++) {\r\n            bytes4 iaName = pd.getInvestmentCurrencyByIndex(i);\r\n            _upgradeInvestmentPool(iaName, newPoolAddress);\r\n        }\r\n\r\n        if (address(this).balance \u003e 0) {\r\n            Pool2 newP2 = Pool2(newPoolAddress);\r\n            newP2.sendEther.value(address(this).balance)();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal Swap of assets between Capital \r\n     * and Investment Sub pool for excess or insufficient  \r\n     * liquidity conditions of a given currency.\r\n     */ \r\n    function internalLiquiditySwap(bytes4 curr) external onlyInternal noReentrancy {\r\n        uint caBalance;\r\n        uint baseMin;\r\n        uint varMin;\r\n        (, baseMin, varMin) = pd.getCurrencyAssetVarBase(curr);\r\n        caBalance = _getCurrencyAssetsBalance(curr);\r\n\r\n        if (caBalance \u003e uint(baseMin).add(varMin).mul(2)) {\r\n            _internalExcessLiquiditySwap(curr, baseMin, varMin, caBalance);\r\n        } else if (caBalance \u003c uint(baseMin).add(varMin)) {\r\n            _internalInsufficientLiquiditySwap(curr, baseMin, varMin, caBalance);\r\n            \r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Saves a given investment asset details. To be called daily.\r\n     * @param curr array of Investment asset name.\r\n     * @param rate array of investment asset exchange rate.\r\n     * @param date current date in yyyymmdd.\r\n     */ \r\n    function saveIADetails(bytes4[] calldata curr, uint64[] calldata rate, uint64 date, bool bit) \r\n    external checkPause noReentrancy {\r\n        bytes4 maxCurr;\r\n        bytes4 minCurr;\r\n        uint64 maxRate;\r\n        uint64 minRate;\r\n        //ONLY NOTARZIE ADDRESS CAN POST\r\n        require(pd.isnotarise(msg.sender));\r\n        (maxCurr, maxRate, minCurr, minRate) = _calculateIARank(curr, rate);\r\n        pd.saveIARankDetails(maxCurr, maxRate, minCurr, minRate, date);\r\n        pd.updatelastDate(date);\r\n        uint len = curr.length;\r\n        for (uint i = 0; i \u003c len; i++) {\r\n            pd.updateIAAvgRate(curr[i], rate[i]);\r\n        }\r\n        if (bit)   //for testing purpose\r\n            _rebalancingLiquidityTrading(maxCurr, maxRate);\r\n        p1.saveIADetailsOracalise(pd.iaRatesTime());\r\n    }\r\n\r\n    /**\r\n     * @dev External Trade for excess or insufficient  \r\n     * liquidity conditions of a given currency.\r\n     */ \r\n    function externalLiquidityTrade() external onlyInternal {\r\n        \r\n        bool triggerTrade;\r\n        bytes4 curr;\r\n        bytes4 minIACurr;\r\n        bytes4 maxIACurr;\r\n        uint amount;\r\n        uint minIARate;\r\n        uint maxIARate;\r\n        uint baseMin;\r\n        uint varMin;\r\n        uint caBalance;\r\n\r\n\r\n        (maxIACurr, maxIARate, minIACurr, minIARate) = pd.getIARankDetailsByDate(pd.getLastDate());\r\n        uint len = pd.getAllCurrenciesLen();\r\n        for (uint64 i = 0; i \u003c len; i++) {\r\n            curr = pd.getCurrenciesByIndex(i);\r\n            (, baseMin, varMin) = pd.getCurrencyAssetVarBase(curr);\r\n            caBalance = _getCurrencyAssetsBalance(curr);\r\n\r\n            if (caBalance \u003e uint(baseMin).add(varMin).mul(2)) { //excess\r\n                amount = caBalance.sub(((uint(baseMin).add(varMin)).mul(3)).div(2)); //*10**18;\r\n                triggerTrade = _externalExcessLiquiditySwap(curr, minIACurr, amount);\r\n            } else if (caBalance \u003c uint(baseMin).add(varMin)) { // insufficient\r\n                amount = (((uint(baseMin).add(varMin)).mul(3)).div(2)).sub(caBalance);\r\n                triggerTrade = _externalInsufficientLiquiditySwap(curr, maxIACurr, amount);\r\n            }\r\n\r\n            if (triggerTrade) {\r\n                p1.triggerExternalLiquidityTrade();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Iupgradable Interface to update dependent contract address\r\n     */\r\n    function changeDependentContractAddress() public onlyInternal {\r\n        m1 = MCR(ms.getLatestAddress(\"MC\"));\r\n        pd = PoolData(ms.getLatestAddress(\"PD\"));\r\n        p1 = Pool1(ms.getLatestAddress(\"P1\"));\r\n    }\r\n\r\n    function sendEther() public payable {\r\n        \r\n    }\r\n\r\n    /** \r\n     * @dev Gets currency asset balance for a given currency name.\r\n     */   \r\n    function _getCurrencyAssetsBalance(bytes4 _curr) public view returns(uint caBalance) {\r\n        if (_curr == \"ETH\") {\r\n            caBalance = address(p1).balance;\r\n        } else {\r\n            IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(_curr));\r\n            caBalance = erc20.balanceOf(address(p1));\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev Transfers ERC20 investment asset from this Pool to another Pool.\r\n     */ \r\n    function _transferInvestmentAsset(\r\n        bytes4 _curr,\r\n        address _transferTo,\r\n        uint _amount\r\n    ) \r\n        internal\r\n    {\r\n        if (_curr == \"ETH\") {\r\n            if (_amount \u003e address(this).balance)\r\n                _amount = address(this).balance;\r\n            p1.sendEther.value(_amount)();\r\n        } else {\r\n            IERC20 erc20 = IERC20(pd.getInvestmentAssetAddress(_curr));\r\n            if (_amount \u003e erc20.balanceOf(address(this)))\r\n                _amount = erc20.balanceOf(address(this));\r\n            require(erc20.transfer(_transferTo, _amount));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to perform rebalancing \r\n     * @param iaCurr is the investment asset currency\r\n     * @param iaRate is the investment asset rate\r\n     */\r\n    function _rebalancingLiquidityTrading(\r\n        bytes4 iaCurr,\r\n        uint64 iaRate\r\n    ) \r\n        internal\r\n        checkPause\r\n    {\r\n        uint amountToSell;\r\n        uint totalRiskBal = pd.getLastVfull();\r\n        uint intermediaryEth;\r\n        uint ethVol = pd.ethVolumeLimit();\r\n\r\n        totalRiskBal = (totalRiskBal.mul(100000)).div(DECIMAL1E18);\r\n        Exchange exchange;\r\n        if (totalRiskBal \u003e 0) {\r\n            amountToSell = ((totalRiskBal.mul(2).mul(\r\n                iaRate)).mul(pd.variationPercX100())).div(100 * 100 * 100000);\r\n            amountToSell = (amountToSell.mul(\r\n                10**uint(pd.getInvestmentAssetDecimals(iaCurr)))).div(100); // amount of asset to sell\r\n\r\n            if (iaCurr != \"ETH\" \u0026\u0026 _checkTradeConditions(iaCurr, iaRate, totalRiskBal)) { \r\n                exchange = Exchange(factory.getExchange(pd.getInvestmentAssetAddress(iaCurr)));\r\n                intermediaryEth = exchange.getTokenToEthInputPrice(amountToSell);\r\n                if (intermediaryEth \u003e (address(exchange).balance.mul(ethVol)).div(100)) { \r\n                    intermediaryEth = (address(exchange).balance.mul(ethVol)).div(100);\r\n                    amountToSell = (exchange.getEthToTokenInputPrice(intermediaryEth).mul(995)).div(1000);\r\n                }\r\n                IERC20 erc20;\r\n                erc20 = IERC20(pd.getCurrencyAssetAddress(iaCurr));\r\n                erc20.approve(address(exchange), amountToSell);\r\n                exchange.tokenToEthSwapInput(amountToSell, (exchange.getTokenToEthInputPrice(\r\n                    amountToSell).mul(995)).div(1000), pd.uniswapDeadline().add(now));\r\n            } else if (iaCurr == \"ETH\" \u0026\u0026 _checkTradeConditions(iaCurr, iaRate, totalRiskBal)) {\r\n\r\n                _transferInvestmentAsset(iaCurr, ms.getLatestAddress(\"P1\"), amountToSell);\r\n            }\r\n            emit Rebalancing(iaCurr, amountToSell); \r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks whether trading is required for a  \r\n     * given investment asset at a given exchange rate.\r\n     */ \r\n    function _checkTradeConditions(\r\n        bytes4 curr,\r\n        uint64 iaRate,\r\n        uint totalRiskBal\r\n    )\r\n        internal\r\n        view\r\n        returns(bool check)\r\n    {\r\n        if (iaRate \u003e 0) {\r\n            uint iaBalance =  _getInvestmentAssetBalance(curr).div(DECIMAL1E18);\r\n            if (iaBalance \u003e 0 \u0026\u0026 totalRiskBal \u003e 0) {\r\n                uint iaMax;\r\n                uint iaMin;\r\n                uint checkNumber;\r\n                uint z;\r\n                (iaMin, iaMax) = pd.getInvestmentAssetHoldingPerc(curr);\r\n                z = pd.variationPercX100();\r\n                checkNumber = (iaBalance.mul(100 * 100000)).div(totalRiskBal.mul(iaRate));\r\n                if ((checkNumber \u003e ((totalRiskBal.mul(iaMax.add(z))).mul(100000)).div(100)) ||\r\n                    (checkNumber \u003c ((totalRiskBal.mul(iaMin.sub(z))).mul(100000)).div(100)))\r\n                    check = true; //eligibleIA\r\n            }\r\n        }\r\n    }    \r\n\r\n    /** \r\n     * @dev Gets the investment asset rank.\r\n     */ \r\n    function _getIARank(\r\n        bytes4 curr,\r\n        uint64 rateX100,\r\n        uint totalRiskPoolBalance\r\n    ) \r\n        internal\r\n        view\r\n        returns (int rhsh, int rhsl) //internal function\r\n    {\r\n\r\n        uint currentIAmaxHolding;\r\n        uint currentIAminHolding;\r\n        uint iaBalance = _getInvestmentAssetBalance(curr);\r\n        (currentIAminHolding, currentIAmaxHolding) = pd.getInvestmentAssetHoldingPerc(curr);\r\n        \r\n        if (rateX100 \u003e 0) {\r\n            uint rhsf;\r\n            rhsf = (iaBalance.mul(1000000)).div(totalRiskPoolBalance.mul(rateX100));\r\n            rhsh = int(rhsf - currentIAmaxHolding);\r\n            rhsl = int(rhsf - currentIAminHolding);\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev Calculates the investment asset rank.\r\n     */  \r\n    function _calculateIARank(\r\n        bytes4[] memory curr,\r\n        uint64[] memory rate\r\n    )\r\n        internal\r\n        view\r\n        returns(\r\n            bytes4 maxCurr,\r\n            uint64 maxRate,\r\n            bytes4 minCurr,\r\n            uint64 minRate\r\n        )  \r\n    {\r\n        int max = 0;\r\n        int min = -1;\r\n        int rhsh;\r\n        int rhsl;\r\n        uint totalRiskPoolBalance;\r\n        (totalRiskPoolBalance, ) = m1.calVtpAndMCRtp();\r\n        uint len = curr.length;\r\n        for (uint i = 0; i \u003c len; i++) {\r\n            rhsl = 0;\r\n            rhsh = 0;\r\n            if (pd.getInvestmentAssetStatus(curr[i])) {\r\n                (rhsh, rhsl) = _getIARank(curr[i], rate[i], totalRiskPoolBalance);\r\n                if (rhsh \u003e max || i == 0) {\r\n                    max = rhsh;\r\n                    maxCurr = curr[i];\r\n                    maxRate = rate[i];\r\n                }\r\n                if (rhsl \u003c min || rhsl == 0 || i == 0) {\r\n                    min = rhsl;\r\n                    minCurr = curr[i];\r\n                    minRate = rate[i];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to get balance of an investment asset \r\n     * @param _curr is the investment asset in concern\r\n     * @return the balance\r\n     */\r\n    function _getInvestmentAssetBalance(bytes4 _curr) internal view returns (uint balance) {\r\n        if (_curr == \"ETH\") {\r\n            balance = address(this).balance;\r\n        } else {\r\n            IERC20 erc20 = IERC20(pd.getInvestmentAssetAddress(_curr));\r\n            balance = erc20.balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Creates Excess liquidity trading order for a given currency and a given balance.\r\n     */  \r\n    function _internalExcessLiquiditySwap(bytes4 _curr, uint _baseMin, uint _varMin, uint _caBalance) internal {\r\n        // require(ms.isInternal(msg.sender) || md.isnotarise(msg.sender));\r\n        bytes4 minIACurr;\r\n        // uint amount;\r\n        \r\n        (, , minIACurr, ) = pd.getIARankDetailsByDate(pd.getLastDate());\r\n        if (_curr == minIACurr) {\r\n            // amount = _caBalance.sub(((_baseMin.add(_varMin)).mul(3)).div(2)); //*10**18;\r\n            p1.transferCurrencyAsset(_curr, _caBalance.sub(((_baseMin.add(_varMin)).mul(3)).div(2)));\r\n        } else {\r\n            p1.triggerExternalLiquidityTrade();\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev insufficient liquidity swap  \r\n     * for a given currency and a given balance.\r\n     */ \r\n    function _internalInsufficientLiquiditySwap(bytes4 _curr, uint _baseMin, uint _varMin, uint _caBalance) internal {\r\n        \r\n        bytes4 maxIACurr;\r\n        uint amount;\r\n        \r\n        (maxIACurr, , , ) = pd.getIARankDetailsByDate(pd.getLastDate());\r\n        \r\n        if (_curr == maxIACurr) {\r\n            amount = (((_baseMin.add(_varMin)).mul(3)).div(2)).sub(_caBalance);\r\n            _transferInvestmentAsset(_curr, ms.getLatestAddress(\"P1\"), amount);\r\n        } else {\r\n            IERC20 erc20 = IERC20(pd.getInvestmentAssetAddress(maxIACurr));\r\n            if ((maxIACurr == \"ETH\" \u0026\u0026 address(this).balance \u003e 0) || \r\n            (maxIACurr != \"ETH\" \u0026\u0026 erc20.balanceOf(address(this)) \u003e 0))\r\n                p1.triggerExternalLiquidityTrade();\r\n            \r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Creates External excess liquidity trading  \r\n     * order for a given currency and a given balance.\r\n     * @param curr Currency Asset to Sell\r\n     * @param minIACurr Investment Asset to Buy  \r\n     * @param amount Amount of Currency Asset to Sell\r\n     */  \r\n    function _externalExcessLiquiditySwap(\r\n        bytes4 curr,\r\n        bytes4 minIACurr,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        returns (bool trigger)\r\n    {\r\n        uint intermediaryEth;\r\n        Exchange exchange;\r\n        IERC20 erc20;\r\n        uint ethVol = pd.ethVolumeLimit();\r\n        if (curr == minIACurr) {\r\n            p1.transferCurrencyAsset(curr, amount);\r\n        } else if (curr == \"ETH\" \u0026\u0026 minIACurr != \"ETH\") {\r\n            \r\n            exchange = Exchange(factory.getExchange(pd.getInvestmentAssetAddress(minIACurr)));\r\n            if (amount \u003e (address(exchange).balance.mul(ethVol)).div(100)) { // 4% ETH volume limit \r\n                amount = (address(exchange).balance.mul(ethVol)).div(100);\r\n                trigger = true;\r\n            }\r\n            p1.transferCurrencyAsset(curr, amount);\r\n            exchange.ethToTokenSwapInput.value(amount)\r\n            (exchange.getEthToTokenInputPrice(amount).mul(995).div(1000), pd.uniswapDeadline().add(now));    \r\n        } else if (curr != \"ETH\" \u0026\u0026 minIACurr == \"ETH\") {\r\n            exchange = Exchange(factory.getExchange(pd.getCurrencyAssetAddress(curr)));\r\n            erc20 = IERC20(pd.getCurrencyAssetAddress(curr));\r\n            intermediaryEth = exchange.getTokenToEthInputPrice(amount);\r\n\r\n            if (intermediaryEth \u003e (address(exchange).balance.mul(ethVol)).div(100)) { \r\n                intermediaryEth = (address(exchange).balance.mul(ethVol)).div(100);\r\n                amount = exchange.getEthToTokenInputPrice(intermediaryEth);\r\n                intermediaryEth = exchange.getTokenToEthInputPrice(amount);\r\n                trigger = true;\r\n            }\r\n            p1.transferCurrencyAsset(curr, amount);\r\n            // erc20.decreaseAllowance(address(exchange), erc20.allowance(address(this), address(exchange)));\r\n            erc20.approve(address(exchange), amount);\r\n            \r\n            exchange.tokenToEthSwapInput(amount, (\r\n                intermediaryEth.mul(995)).div(1000), pd.uniswapDeadline().add(now));   \r\n        } else {\r\n            \r\n            exchange = Exchange(factory.getExchange(pd.getCurrencyAssetAddress(curr)));\r\n            intermediaryEth = exchange.getTokenToEthInputPrice(amount);\r\n\r\n            if (intermediaryEth \u003e (address(exchange).balance.mul(ethVol)).div(100)) { \r\n                intermediaryEth = (address(exchange).balance.mul(ethVol)).div(100);\r\n                amount = exchange.getEthToTokenInputPrice(intermediaryEth);\r\n                trigger = true;\r\n            }\r\n            \r\n            Exchange tmp = Exchange(factory.getExchange(\r\n                pd.getInvestmentAssetAddress(minIACurr))); // minIACurr exchange\r\n\r\n            if (intermediaryEth \u003e address(tmp).balance.mul(ethVol).div(100)) { \r\n                intermediaryEth = address(tmp).balance.mul(ethVol).div(100);\r\n                amount = exchange.getEthToTokenInputPrice(intermediaryEth);\r\n                trigger = true;   \r\n            }\r\n            p1.transferCurrencyAsset(curr, amount);\r\n            erc20 = IERC20(pd.getCurrencyAssetAddress(curr));\r\n            erc20.approve(address(exchange), amount);\r\n            \r\n            exchange.tokenToTokenSwapInput(amount, (tmp.getEthToTokenInputPrice(\r\n                intermediaryEth).mul(995)).div(1000), (intermediaryEth.mul(995)).div(1000), \r\n                    pd.uniswapDeadline().add(now), pd.getInvestmentAssetAddress(minIACurr));\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev insufficient liquidity swap  \r\n     * for a given currency and a given balance.\r\n     * @param curr Currency Asset to buy\r\n     * @param maxIACurr Investment Asset to sell\r\n     * @param amount Amount of Investment Asset to sell\r\n     */ \r\n    function _externalInsufficientLiquiditySwap(\r\n        bytes4 curr,\r\n        bytes4 maxIACurr,\r\n        uint256 amount\r\n    ) \r\n        internal\r\n        returns (bool trigger)\r\n    {   \r\n\r\n        Exchange exchange;\r\n        IERC20 erc20;\r\n        uint intermediaryEth;\r\n        // uint ethVol = pd.ethVolumeLimit();\r\n        if (curr == maxIACurr) {\r\n            _transferInvestmentAsset(curr, ms.getLatestAddress(\"P1\"), amount);\r\n        } else if (curr == \"ETH\" \u0026\u0026 maxIACurr != \"ETH\") { \r\n            exchange = Exchange(factory.getExchange(pd.getInvestmentAssetAddress(maxIACurr)));\r\n            intermediaryEth = exchange.getEthToTokenInputPrice(amount);\r\n\r\n\r\n            if (amount \u003e (address(exchange).balance.mul(pd.ethVolumeLimit())).div(100)) { \r\n                amount = (address(exchange).balance.mul(pd.ethVolumeLimit())).div(100);\r\n                // amount = exchange.getEthToTokenInputPrice(intermediaryEth);\r\n                intermediaryEth = exchange.getEthToTokenInputPrice(amount);\r\n                trigger = true;\r\n            }\r\n            \r\n            erc20 = IERC20(pd.getCurrencyAssetAddress(maxIACurr));\r\n            if (intermediaryEth \u003e erc20.balanceOf(address(this))) {\r\n                intermediaryEth = erc20.balanceOf(address(this));\r\n            }\r\n            // erc20.decreaseAllowance(address(exchange), erc20.allowance(address(this), address(exchange)));\r\n            erc20.approve(address(exchange), intermediaryEth);\r\n            exchange.tokenToEthTransferInput(intermediaryEth, (\r\n                exchange.getTokenToEthInputPrice(intermediaryEth).mul(995)).div(1000), \r\n                pd.uniswapDeadline().add(now), address(p1)); \r\n\r\n        } else if (curr != \"ETH\" \u0026\u0026 maxIACurr == \"ETH\") {\r\n            exchange = Exchange(factory.getExchange(pd.getCurrencyAssetAddress(curr)));\r\n            intermediaryEth = exchange.getTokenToEthInputPrice(amount);\r\n            if (intermediaryEth \u003e address(this).balance)\r\n                intermediaryEth = address(this).balance;\r\n            if (intermediaryEth \u003e (address(exchange).balance.mul\r\n            (pd.ethVolumeLimit())).div(100)) { // 4% ETH volume limit \r\n                intermediaryEth = (address(exchange).balance.mul(pd.ethVolumeLimit())).div(100);\r\n                trigger = true;\r\n            }\r\n            exchange.ethToTokenTransferInput.value(intermediaryEth)((exchange.getEthToTokenInputPrice(\r\n                intermediaryEth).mul(995)).div(1000), pd.uniswapDeadline().add(now), address(p1));   \r\n        } else {\r\n            address currAdd = pd.getCurrencyAssetAddress(curr);\r\n            exchange = Exchange(factory.getExchange(currAdd));\r\n            intermediaryEth = exchange.getTokenToEthInputPrice(amount);\r\n            if (intermediaryEth \u003e (address(exchange).balance.mul(pd.ethVolumeLimit())).div(100)) { \r\n                intermediaryEth = (address(exchange).balance.mul(pd.ethVolumeLimit())).div(100);\r\n                trigger = true;\r\n            }\r\n            Exchange tmp = Exchange(factory.getExchange(pd.getInvestmentAssetAddress(maxIACurr)));\r\n\r\n            if (intermediaryEth \u003e address(tmp).balance.mul(pd.ethVolumeLimit()).div(100)) { \r\n                intermediaryEth = address(tmp).balance.mul(pd.ethVolumeLimit()).div(100);\r\n                // amount = exchange.getEthToTokenInputPrice(intermediaryEth);\r\n                trigger = true;\r\n            }\r\n\r\n            uint maxIAToSell = tmp.getEthToTokenInputPrice(intermediaryEth);\r\n\r\n            erc20 = IERC20(pd.getInvestmentAssetAddress(maxIACurr));\r\n            uint maxIABal = erc20.balanceOf(address(this));\r\n            if (maxIAToSell \u003e maxIABal) {\r\n                maxIAToSell = maxIABal;\r\n                intermediaryEth = tmp.getTokenToEthInputPrice(maxIAToSell);\r\n                // amount = exchange.getEthToTokenInputPrice(intermediaryEth);\r\n            }\r\n            amount = exchange.getEthToTokenInputPrice(intermediaryEth);\r\n            erc20.approve(address(tmp), maxIAToSell);\r\n            tmp.tokenToTokenTransferInput(maxIAToSell, (\r\n                amount.mul(995)).div(1000), (\r\n                    intermediaryEth), pd.uniswapDeadline().add(now), address(p1), currAdd);\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev Transfers ERC20 investment asset from this Pool to another Pool.\r\n     */ \r\n    function _upgradeInvestmentPool(\r\n        bytes4 _curr,\r\n        address _newPoolAddress\r\n    ) \r\n        internal\r\n    {\r\n        IERC20 erc20 = IERC20(pd.getInvestmentAssetAddress(_curr));\r\n        if (erc20.balanceOf(address(this)) \u003e 0)\r\n            require(erc20.transfer(_newPoolAddress, erc20.balanceOf(address(this))));\r\n    }\r\n}"},"PoolData.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\nimport \"./Iupgradable.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\n\r\ncontract DSValue {\r\n    function peek() public view returns (bytes32, bool);\r\n    function read() public view returns (bytes32);\r\n}\r\n\r\n\r\ncontract PoolData is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    struct ApiId {\r\n        bytes4 typeOf;\r\n        bytes4 currency;\r\n        uint id;\r\n        uint64 dateAdd;\r\n        uint64 dateUpd;\r\n    }\r\n\r\n    struct CurrencyAssets {\r\n        address currAddress;\r\n        uint baseMin;\r\n        uint varMin;\r\n    }\r\n\r\n    struct InvestmentAssets {\r\n        address currAddress;\r\n        bool status;\r\n        uint64 minHoldingPercX100;\r\n        uint64 maxHoldingPercX100;\r\n        uint8 decimals;\r\n    }\r\n\r\n    struct IARankDetails {\r\n        bytes4 maxIACurr;\r\n        uint64 maxRate;\r\n        bytes4 minIACurr;\r\n        uint64 minRate;\r\n    }\r\n\r\n    struct McrData {\r\n        uint mcrPercx100;\r\n        uint mcrEther;\r\n        uint vFull; //Pool funds\r\n        uint64 date;\r\n    }\r\n\r\n    IARankDetails[] internal allIARankDetails;\r\n    McrData[] public allMCRData;\r\n\r\n    bytes4[] internal allInvestmentCurrencies;\r\n    bytes4[] internal allCurrencies;\r\n    bytes32[] public allAPIcall;\r\n    mapping(bytes32 =\u003e ApiId) public allAPIid;\r\n    mapping(uint64 =\u003e uint) internal datewiseId;\r\n    mapping(bytes16 =\u003e uint) internal currencyLastIndex;\r\n    mapping(bytes4 =\u003e CurrencyAssets) internal allCurrencyAssets;\r\n    mapping(bytes4 =\u003e InvestmentAssets) internal allInvestmentAssets;\r\n    mapping(bytes4 =\u003e uint) internal caAvgRate;\r\n    mapping(bytes4 =\u003e uint) internal iaAvgRate;\r\n\r\n    address public notariseMCR;\r\n    address public daiFeedAddress;\r\n    uint private constant DECIMAL1E18 = uint(10) ** 18;\r\n    uint public uniswapDeadline;\r\n    uint public liquidityTradeCallbackTime;\r\n    uint public lastLiquidityTradeTrigger;\r\n    uint64 internal lastDate;\r\n    uint public variationPercX100;\r\n    uint public iaRatesTime;\r\n    uint public minCap;\r\n    uint public mcrTime;\r\n    uint public a;\r\n    uint public shockParameter;\r\n    uint public c;\r\n    uint public mcrFailTime; \r\n    uint public ethVolumeLimit;\r\n    uint public capReached;\r\n    uint public capacityLimit;\r\n    \r\n    constructor(address _notariseAdd, address _daiFeedAdd, address _daiAdd) public {\r\n        notariseMCR = _notariseAdd;\r\n        daiFeedAddress = _daiFeedAdd;\r\n        c = 5800000;\r\n        a = 1028;\r\n        mcrTime = 24 hours;\r\n        mcrFailTime = 6 hours;\r\n        allMCRData.push(McrData(0, 0, 0, 0));\r\n        minCap = 12000 * DECIMAL1E18;\r\n        shockParameter = 50;\r\n        variationPercX100 = 100; //1%\r\n        iaRatesTime = 24 hours; //24 hours in seconds\r\n        uniswapDeadline = 20 minutes;\r\n        liquidityTradeCallbackTime = 4 hours;\r\n        ethVolumeLimit = 4;\r\n        capacityLimit = 10;\r\n        allCurrencies.push(\"ETH\");\r\n        allCurrencyAssets[\"ETH\"] = CurrencyAssets(address(0), 1000 * DECIMAL1E18, 0);\r\n        allCurrencies.push(\"DAI\");\r\n        allCurrencyAssets[\"DAI\"] = CurrencyAssets(_daiAdd, 50000 * DECIMAL1E18, 0);\r\n        allInvestmentCurrencies.push(\"ETH\");\r\n        allInvestmentAssets[\"ETH\"] = InvestmentAssets(address(0), true, 2500, 10000, 18);\r\n        allInvestmentCurrencies.push(\"DAI\");\r\n        allInvestmentAssets[\"DAI\"] = InvestmentAssets(_daiAdd, true, 250, 1500, 18);\r\n    }\r\n\r\n    /**\r\n     * @dev to set the maximum cap allowed \r\n     * @param val is the new value\r\n     */\r\n    function setCapReached(uint val) external onlyInternal {\r\n        capReached = val;\r\n    }\r\n    \r\n    /// @dev Updates the 3 day average rate of a IA currency.\r\n    /// To be replaced by MakerDao\u0027s on chain rates\r\n    /// @param curr IA Currency Name.\r\n    /// @param rate Average exchange rate X 100 (of last 3 days).\r\n    function updateIAAvgRate(bytes4 curr, uint rate) external onlyInternal {\r\n        iaAvgRate[curr] = rate;\r\n    }\r\n\r\n    /// @dev Updates the 3 day average rate of a CA currency.\r\n    /// To be replaced by MakerDao\u0027s on chain rates\r\n    /// @param curr Currency Name.\r\n    /// @param rate Average exchange rate X 100 (of last 3 days).\r\n    function updateCAAvgRate(bytes4 curr, uint rate) external onlyInternal {\r\n        caAvgRate[curr] = rate;\r\n    }\r\n\r\n    /// @dev Adds details of (Minimum Capital Requirement)MCR.\r\n    /// @param mcrp Minimum Capital Requirement percentage (MCR% * 100 ,Ex:for 54.56% ,given 5456)\r\n    /// @param vf Pool fund value in Ether used in the last full daily calculation from the Capital model.\r\n    function pushMCRData(uint mcrp, uint mcre, uint vf, uint64 time) external onlyInternal {\r\n        allMCRData.push(McrData(mcrp, mcre, vf, time));\r\n    }\r\n\r\n    /** \r\n     * @dev Updates the Timestamp at which result of oracalize call is received.\r\n     */  \r\n    function updateDateUpdOfAPI(bytes32 myid) external onlyInternal {\r\n        allAPIid[myid].dateUpd = uint64(now);\r\n    }\r\n\r\n    /** \r\n     * @dev Saves the details of the Oraclize API.\r\n     * @param myid Id return by the oraclize query.\r\n     * @param _typeof type of the query for which oraclize call is made.\r\n     * @param id ID of the proposal,quote,cover etc. for which oraclize call is made \r\n     */  \r\n    function saveApiDetails(bytes32 myid, bytes4 _typeof, uint id) external onlyInternal {\r\n        allAPIid[myid] = ApiId(_typeof, \"\", id, uint64(now), uint64(now));\r\n    }\r\n\r\n    /** \r\n     * @dev Stores the id return by the oraclize query. \r\n     * Maintains record of all the Ids return by oraclize query.\r\n     * @param myid Id return by the oraclize query.\r\n     */  \r\n    function addInAllApiCall(bytes32 myid) external onlyInternal {\r\n        allAPIcall.push(myid);\r\n    }\r\n    \r\n    /**\r\n     * @dev Saves investment asset rank details.\r\n     * @param maxIACurr Maximum ranked investment asset currency.\r\n     * @param maxRate Maximum ranked investment asset rate.\r\n     * @param minIACurr Minimum ranked investment asset currency.\r\n     * @param minRate Minimum ranked investment asset rate.\r\n     * @param date in yyyymmdd.\r\n     */  \r\n    function saveIARankDetails(\r\n        bytes4 maxIACurr,\r\n        uint64 maxRate,\r\n        bytes4 minIACurr,\r\n        uint64 minRate,\r\n        uint64 date\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        allIARankDetails.push(IARankDetails(maxIACurr, maxRate, minIACurr, minRate));\r\n        datewiseId[date] = allIARankDetails.length.sub(1);\r\n    }\r\n\r\n    /**\r\n     * @dev to get the time for the laste liquidity trade trigger\r\n     */\r\n    function setLastLiquidityTradeTrigger() external onlyInternal {\r\n        lastLiquidityTradeTrigger = now;\r\n    }\r\n\r\n    /** \r\n     * @dev Updates Last Date.\r\n     */  \r\n    function updatelastDate(uint64 newDate) external onlyInternal {\r\n        lastDate = newDate;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds currency asset currency. \r\n     * @param curr currency of the asset\r\n     * @param currAddress address of the currency\r\n     * @param baseMin base minimum in 10^18. \r\n     */  \r\n    function addCurrencyAssetCurrency(\r\n        bytes4 curr,\r\n        address currAddress,\r\n        uint baseMin\r\n    ) \r\n        external\r\n    {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        allCurrencies.push(curr);\r\n        allCurrencyAssets[curr] = CurrencyAssets(currAddress, baseMin, 0);\r\n    }\r\n    \r\n    /**\r\n     * @dev Adds investment asset. \r\n     */  \r\n    function addInvestmentAssetCurrency(\r\n        bytes4 curr,\r\n        address currAddress,\r\n        bool status,\r\n        uint64 minHoldingPercX100,\r\n        uint64 maxHoldingPercX100,\r\n        uint8 decimals\r\n    ) \r\n        external\r\n    {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        allInvestmentCurrencies.push(curr);\r\n        allInvestmentAssets[curr] = InvestmentAssets(currAddress, status,\r\n            minHoldingPercX100, maxHoldingPercX100, decimals);\r\n    }\r\n\r\n    /**\r\n     * @dev Changes base minimum of a given currency asset.\r\n     */ \r\n    function changeCurrencyAssetBaseMin(bytes4 curr, uint baseMin) external {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        allCurrencyAssets[curr].baseMin = baseMin;\r\n    }\r\n\r\n    /**\r\n     * @dev changes variable minimum of a given currency asset.\r\n     */  \r\n    function changeCurrencyAssetVarMin(bytes4 curr, uint varMin) external onlyInternal {\r\n        allCurrencyAssets[curr].varMin = varMin;\r\n    }\r\n\r\n    /** \r\n     * @dev Changes the investment asset status.\r\n     */ \r\n    function changeInvestmentAssetStatus(bytes4 curr, bool status) external {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        allInvestmentAssets[curr].status = status;\r\n    }\r\n\r\n    /** \r\n     * @dev Changes the investment asset Holding percentage of a given currency.\r\n     */\r\n    function changeInvestmentAssetHoldingPerc(\r\n        bytes4 curr,\r\n        uint64 minPercX100,\r\n        uint64 maxPercX100\r\n    )\r\n        external\r\n    {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        allInvestmentAssets[curr].minHoldingPercX100 = minPercX100;\r\n        allInvestmentAssets[curr].maxHoldingPercX100 = maxPercX100;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Currency asset token address. \r\n     */  \r\n    function changeCurrencyAssetAddress(bytes4 curr, address currAdd) external {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        allCurrencyAssets[curr].currAddress = currAdd;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes Investment asset token address.\r\n     */ \r\n    function changeInvestmentAssetAddressAndDecimal(\r\n        bytes4 curr,\r\n        address currAdd,\r\n        uint8 newDecimal\r\n    )\r\n        external\r\n    {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        allInvestmentAssets[curr].currAddress = currAdd;\r\n        allInvestmentAssets[curr].decimals = newDecimal;\r\n    }\r\n\r\n    /// @dev Changes address allowed to post MCR.\r\n    function changeNotariseAddress(address _add) external onlyInternal {\r\n        notariseMCR = _add;\r\n    }\r\n\r\n    /// @dev updates daiFeedAddress address.\r\n    /// @param _add address of DAI feed.\r\n    function changeDAIfeedAddress(address _add) external onlyInternal {\r\n        daiFeedAddress = _add;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Uint Parameters of a code\r\n     * @param code whose details we want\r\n     * @return string value of the code\r\n     * @return associated amount (time or perc or value) to the code\r\n     */\r\n    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint val) {\r\n        codeVal = code;\r\n        if (code == \"MCRTIM\") {\r\n            val = mcrTime / (1 hours);\r\n\r\n        } else if (code == \"MCRFTIM\") {\r\n\r\n            val = mcrFailTime / (1 hours);\r\n\r\n        } else if (code == \"MCRMIN\") {\r\n\r\n            val = minCap;\r\n\r\n        } else if (code == \"MCRSHOCK\") {\r\n\r\n            val = shockParameter;\r\n\r\n        } else if (code == \"MCRCAPL\") {\r\n\r\n            val = capacityLimit;\r\n\r\n        } else if (code == \"IMZ\") {\r\n\r\n            val = variationPercX100;\r\n\r\n        } else if (code == \"IMRATET\") {\r\n\r\n            val = iaRatesTime / (1 hours);\r\n\r\n        } else if (code == \"IMUNIDL\") {\r\n\r\n            val = uniswapDeadline / (1 minutes);\r\n\r\n        } else if (code == \"IMLIQT\") {\r\n\r\n            val = liquidityTradeCallbackTime / (1 hours);\r\n\r\n        } else if (code == \"IMETHVL\") {\r\n\r\n            val = ethVolumeLimit;\r\n\r\n        } else if (code == \"C\") {\r\n            val = c;\r\n\r\n        } else if (code == \"A\") {\r\n\r\n            val = a;\r\n\r\n        }\r\n            \r\n    }\r\n \r\n    /// @dev Checks whether a given address can notaise MCR data or not.\r\n    /// @param _add Address.\r\n    /// @return res Returns 0 if address is not authorized, else 1.\r\n    function isnotarise(address _add) external view returns(bool res) {\r\n        res = false;\r\n        if (_add == notariseMCR)\r\n            res = true;\r\n    }\r\n\r\n    /// @dev Gets the details of last added MCR.\r\n    /// @return mcrPercx100 Total Minimum Capital Requirement percentage of that month of year(multiplied by 100).\r\n    /// @return vFull Total Pool fund value in Ether used in the last full daily calculation.\r\n    function getLastMCR() external view returns(uint mcrPercx100, uint mcrEtherx1E18, uint vFull, uint64 date) {\r\n        uint index = allMCRData.length.sub(1);\r\n        return (\r\n            allMCRData[index].mcrPercx100,\r\n            allMCRData[index].mcrEther,\r\n            allMCRData[index].vFull,\r\n            allMCRData[index].date\r\n        );\r\n    }\r\n\r\n    /// @dev Gets last Minimum Capital Requirement percentage of Capital Model\r\n    /// @return val MCR% value,multiplied by 100.\r\n    function getLastMCRPerc() external view returns(uint) {\r\n        return allMCRData[allMCRData.length.sub(1)].mcrPercx100;\r\n    }\r\n\r\n    /// @dev Gets last Ether price of Capital Model\r\n    /// @return val ether value,multiplied by 100.\r\n    function getLastMCREther() external view returns(uint) {\r\n        return allMCRData[allMCRData.length.sub(1)].mcrEther;\r\n    }\r\n\r\n    /// @dev Gets Pool fund value in Ether used in the last full daily calculation from the Capital model.\r\n    function getLastVfull() external view returns(uint) {\r\n        return allMCRData[allMCRData.length.sub(1)].vFull;\r\n    }\r\n\r\n    /// @dev Gets last Minimum Capital Requirement in Ether.\r\n    /// @return date of MCR.\r\n    function getLastMCRDate() external view returns(uint64 date) {\r\n        date = allMCRData[allMCRData.length.sub(1)].date;\r\n    }\r\n\r\n    /// @dev Gets details for token price calculation.\r\n    function getTokenPriceDetails(bytes4 curr) external view returns(uint _a, uint _c, uint rate) {\r\n        _a = a;\r\n        _c = c;\r\n        rate = _getAvgRate(curr, false);\r\n    }\r\n    \r\n    /// @dev Gets the total number of times MCR calculation has been made.\r\n    function getMCRDataLength() external view returns(uint len) {\r\n        len = allMCRData.length;\r\n    }\r\n \r\n    /**\r\n     * @dev Gets investment asset rank details by given date.\r\n     */  \r\n    function getIARankDetailsByDate(\r\n        uint64 date\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            bytes4 maxIACurr,\r\n            uint64 maxRate,\r\n            bytes4 minIACurr,\r\n            uint64 minRate\r\n        )\r\n    {\r\n        uint index = datewiseId[date];\r\n        return (\r\n            allIARankDetails[index].maxIACurr,\r\n            allIARankDetails[index].maxRate,\r\n            allIARankDetails[index].minIACurr,\r\n            allIARankDetails[index].minRate\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev Gets Last Date.\r\n     */ \r\n    function getLastDate() external view returns(uint64 date) {\r\n        return lastDate;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets investment currency for a given index.\r\n     */  \r\n    function getInvestmentCurrencyByIndex(uint index) external view returns(bytes4 currName) {\r\n        return allInvestmentCurrencies[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets count of investment currency.\r\n     */  \r\n    function getInvestmentCurrencyLen() external view returns(uint len) {\r\n        return allInvestmentCurrencies.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets all the investment currencies.\r\n     */ \r\n    function getAllInvestmentCurrencies() external view returns(bytes4[] memory currencies) {\r\n        return allInvestmentCurrencies;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets All currency for a given index.\r\n     */  \r\n    function getCurrenciesByIndex(uint index) external view returns(bytes4 currName) {\r\n        return allCurrencies[index];\r\n    }\r\n\r\n    /** \r\n     * @dev Gets count of All currency.\r\n     */  \r\n    function getAllCurrenciesLen() external view returns(uint len) {\r\n        return allCurrencies.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets all currencies \r\n     */  \r\n    function getAllCurrencies() external view returns(bytes4[] memory currencies) {\r\n        return allCurrencies;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets currency asset details for a given currency.\r\n     */  \r\n    function getCurrencyAssetVarBase(\r\n        bytes4 curr\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            bytes4 currency,\r\n            uint baseMin,\r\n            uint varMin\r\n        )\r\n    {\r\n        return (\r\n            curr,\r\n            allCurrencyAssets[curr].baseMin,\r\n            allCurrencyAssets[curr].varMin\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets minimum variable value for currency asset.\r\n     */  \r\n    function getCurrencyAssetVarMin(bytes4 curr) external view returns(uint varMin) {\r\n        return allCurrencyAssets[curr].varMin;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets base minimum of  a given currency asset.\r\n     */  \r\n    function getCurrencyAssetBaseMin(bytes4 curr) external view returns(uint baseMin) {\r\n        return allCurrencyAssets[curr].baseMin;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets investment asset maximum and minimum holding percentage of a given currency.\r\n     */  \r\n    function getInvestmentAssetHoldingPerc(\r\n        bytes4 curr\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint64 minHoldingPercX100,\r\n            uint64 maxHoldingPercX100\r\n        )\r\n    {\r\n        return (\r\n            allInvestmentAssets[curr].minHoldingPercX100,\r\n            allInvestmentAssets[curr].maxHoldingPercX100\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev Gets investment asset decimals.\r\n     */  \r\n    function getInvestmentAssetDecimals(bytes4 curr) external view returns(uint8 decimal) {\r\n        return allInvestmentAssets[curr].decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets investment asset maximum holding percentage of a given currency.\r\n     */  \r\n    function getInvestmentAssetMaxHoldingPerc(bytes4 curr) external view returns(uint64 maxHoldingPercX100) {\r\n        return allInvestmentAssets[curr].maxHoldingPercX100;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets investment asset minimum holding percentage of a given currency.\r\n     */  \r\n    function getInvestmentAssetMinHoldingPerc(bytes4 curr) external view returns(uint64 minHoldingPercX100) {\r\n        return allInvestmentAssets[curr].minHoldingPercX100;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets investment asset details of a given currency\r\n     */  \r\n    function getInvestmentAssetDetails(\r\n        bytes4 curr\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            bytes4 currency,\r\n            address currAddress,\r\n            bool status,\r\n            uint64 minHoldingPerc,\r\n            uint64 maxHoldingPerc,\r\n            uint8 decimals\r\n        )\r\n    {\r\n        return (\r\n            curr,\r\n            allInvestmentAssets[curr].currAddress,\r\n            allInvestmentAssets[curr].status,\r\n            allInvestmentAssets[curr].minHoldingPercX100,\r\n            allInvestmentAssets[curr].maxHoldingPercX100,\r\n            allInvestmentAssets[curr].decimals\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Currency asset token address.\r\n     */  \r\n    function getCurrencyAssetAddress(bytes4 curr) external view returns(address) {\r\n        return allCurrencyAssets[curr].currAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets investment asset token address.\r\n     */  \r\n    function getInvestmentAssetAddress(bytes4 curr) external view returns(address) {\r\n        return allInvestmentAssets[curr].currAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets investment asset active Status of a given currency.\r\n     */  \r\n    function getInvestmentAssetStatus(bytes4 curr) external view returns(bool status) {\r\n        return allInvestmentAssets[curr].status;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets type of oraclize query for a given Oraclize Query ID.\r\n     * @param myid Oraclize Query ID identifying the query for which the result is being received.\r\n     * @return _typeof It could be of type \"quote\",\"quotation\",\"cover\",\"claim\" etc.\r\n     */  \r\n    function getApiIdTypeOf(bytes32 myid) external view returns(bytes4) {\r\n        return allAPIid[myid].typeOf;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets ID associated to oraclize query for a given Oraclize Query ID.\r\n     * @param myid Oraclize Query ID identifying the query for which the result is being received.\r\n     * @return id1 It could be the ID of \"proposal\",\"quotation\",\"cover\",\"claim\" etc.\r\n     */  \r\n    function getIdOfApiId(bytes32 myid) external view returns(uint) {\r\n        return allAPIid[myid].id;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the Timestamp of a oracalize call.\r\n     */  \r\n    function getDateAddOfAPI(bytes32 myid) external view returns(uint64) {\r\n        return allAPIid[myid].dateAdd;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Timestamp at which result of oracalize call is received.\r\n     */  \r\n    function getDateUpdOfAPI(bytes32 myid) external view returns(uint64) {\r\n        return allAPIid[myid].dateUpd;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets currency by oracalize id. \r\n     */  \r\n    function getCurrOfApiId(bytes32 myid) external view returns(bytes4) {\r\n        return allAPIid[myid].currency;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets ID return by the oraclize query of a given index.\r\n     * @param index Index.\r\n     * @return myid ID return by the oraclize query.\r\n     */  \r\n    function getApiCallIndex(uint index) external view returns(bytes32 myid) {\r\n        myid = allAPIcall[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Length of API call. \r\n     */  \r\n    function getApilCallLength() external view returns(uint) {\r\n        return allAPIcall.length;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get Details of Oraclize API when given Oraclize Id.\r\n     * @param myid ID return by the oraclize query.\r\n     * @return _typeof ype of the query for which oraclize \r\n     * call is made.(\"proposal\",\"quote\",\"quotation\" etc.) \r\n     */  \r\n    function getApiCallDetails(\r\n        bytes32 myid\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            bytes4 _typeof,\r\n            bytes4 curr,\r\n            uint id,\r\n            uint64 dateAdd,\r\n            uint64 dateUpd\r\n        )\r\n    {\r\n        return (\r\n            allAPIid[myid].typeOf,\r\n            allAPIid[myid].currency,\r\n            allAPIid[myid].id,\r\n            allAPIid[myid].dateAdd,\r\n            allAPIid[myid].dateUpd\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Updates Uint Parameters of a code\r\n     * @param code whose details we want to update\r\n     * @param val value to set\r\n     */\r\n    function updateUintParameters(bytes8 code, uint val) public {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        if (code == \"MCRTIM\") {\r\n            _changeMCRTime(val * 1 hours);\r\n\r\n        } else if (code == \"MCRFTIM\") {\r\n\r\n            _changeMCRFailTime(val * 1 hours);\r\n\r\n        } else if (code == \"MCRMIN\") {\r\n\r\n            _changeMinCap(val);\r\n\r\n        } else if (code == \"MCRSHOCK\") {\r\n\r\n            _changeShockParameter(val);\r\n\r\n        } else if (code == \"MCRCAPL\") {\r\n\r\n            _changeCapacityLimit(val);\r\n\r\n        } else if (code == \"IMZ\") {\r\n\r\n            _changeVariationPercX100(val);\r\n\r\n        } else if (code == \"IMRATET\") {\r\n\r\n            _changeIARatesTime(val * 1 hours);\r\n\r\n        } else if (code == \"IMUNIDL\") {\r\n\r\n            _changeUniswapDeadlineTime(val * 1 minutes);\r\n\r\n        } else if (code == \"IMLIQT\") {\r\n\r\n            _changeliquidityTradeCallbackTime(val * 1 hours);\r\n\r\n        } else if (code == \"IMETHVL\") {\r\n\r\n            _setEthVolumeLimit(val);\r\n\r\n        } else if (code == \"C\") {\r\n            _changeC(val);\r\n\r\n        } else if (code == \"A\") {\r\n\r\n            _changeA(val);\r\n\r\n        } else {\r\n            revert(\"Invalid param code\");\r\n        }\r\n            \r\n    }\r\n\r\n    /**\r\n     * @dev to get the average rate of currency rate \r\n     * @param curr is the currency in concern\r\n     * @return required rate\r\n     */\r\n    function getCAAvgRate(bytes4 curr) public view returns(uint rate) {\r\n        return _getAvgRate(curr, false);\r\n    }\r\n\r\n    /**\r\n     * @dev to get the average rate of investment rate \r\n     * @param curr is the investment in concern\r\n     * @return required rate\r\n     */\r\n    function getIAAvgRate(bytes4 curr) public view returns(uint rate) {\r\n        return _getAvgRate(curr, true);\r\n    }\r\n\r\n    function changeDependentContractAddress() public onlyInternal {}\r\n\r\n    /// @dev Gets the average rate of a CA currency.\r\n    /// @param curr Currency Name.\r\n    /// @return rate Average rate X 100(of last 3 days).\r\n    function _getAvgRate(bytes4 curr, bool isIA) internal view returns(uint rate) {\r\n        if (curr == \"DAI\") {\r\n            DSValue ds = DSValue(daiFeedAddress);\r\n            rate = uint(ds.read()).div(uint(10) ** 16);\r\n        } else if (isIA) {\r\n            rate = iaAvgRate[curr];\r\n        } else {\r\n            rate = caAvgRate[curr];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to set the ethereum volume limit \r\n     * @param val is the new limit value\r\n     */\r\n    function _setEthVolumeLimit(uint val) internal {\r\n        ethVolumeLimit = val;\r\n    }\r\n\r\n    /// @dev Sets minimum Cap.\r\n    function _changeMinCap(uint newCap) internal {\r\n        minCap = newCap;\r\n    }\r\n\r\n    /// @dev Sets Shock Parameter.\r\n    function _changeShockParameter(uint newParam) internal {\r\n        shockParameter = newParam;\r\n    }\r\n    \r\n    /// @dev Changes time period for obtaining new MCR data from external oracle query.\r\n    function _changeMCRTime(uint _time) internal {\r\n        mcrTime = _time;\r\n    }\r\n\r\n    /// @dev Sets MCR Fail time.\r\n    function _changeMCRFailTime(uint _time) internal {\r\n        mcrFailTime = _time;\r\n    }\r\n\r\n    /**\r\n     * @dev to change the uniswap deadline time \r\n     * @param newDeadline is the value\r\n     */\r\n    function _changeUniswapDeadlineTime(uint newDeadline) internal {\r\n        uniswapDeadline = newDeadline;\r\n    }\r\n\r\n    /**\r\n     * @dev to change the liquidity trade call back time \r\n     * @param newTime is the new value to be set\r\n     */\r\n    function _changeliquidityTradeCallbackTime(uint newTime) internal {\r\n        liquidityTradeCallbackTime = newTime;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes time after which investment asset rates need to be fed.\r\n     */  \r\n    function _changeIARatesTime(uint _newTime) internal {\r\n        iaRatesTime = _newTime;\r\n    }\r\n    \r\n    /**\r\n     * @dev Changes the variation range percentage.\r\n     */  \r\n    function _changeVariationPercX100(uint newPercX100) internal {\r\n        variationPercX100 = newPercX100;\r\n    }\r\n\r\n    /// @dev Changes Growth Step\r\n    function _changeC(uint newC) internal {\r\n        c = newC;\r\n    }\r\n\r\n    /// @dev Changes scaling factor.\r\n    function _changeA(uint val) internal {\r\n        a = val;\r\n    }\r\n    \r\n    /**\r\n     * @dev to change the capacity limit \r\n     * @param val is the new value\r\n     */\r\n    function _changeCapacityLimit(uint val) internal {\r\n        capacityLimit = val;\r\n    }    \r\n}\r\n"},"ProposalCategory.sol":{"content":"/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\npragma solidity 0.5.7;\r\n\r\nimport \"./IProposalCategory.sol\";\r\nimport \"./Governed.sol\";\r\nimport \"./Iupgradable.sol\";\r\nimport \"./MemberRoles.sol\";\r\n\r\n\r\ncontract ProposalCategory is  Governed, IProposalCategory, Iupgradable {\r\n\r\n    bool public constructorCheck;\r\n    MemberRoles internal mr;\r\n\r\n    struct CategoryStruct {\r\n        uint memberRoleToVote;\r\n        uint majorityVotePerc;\r\n        uint quorumPerc;\r\n        uint[] allowedToCreateProposal;\r\n        uint closingTime;\r\n        uint minStake;\r\n    }\r\n\r\n    struct CategoryAction {\r\n        uint defaultIncentive;\r\n        address contractAddress;\r\n        bytes2 contractName;\r\n    }\r\n    \r\n    CategoryStruct[] internal allCategory;\r\n    mapping (uint =\u003e CategoryAction) internal categoryActionData;\r\n    mapping (uint =\u003e uint) public categoryABReq;\r\n    mapping (uint =\u003e uint) public isSpecialResolution;\r\n\r\n    /// @dev Adds new category\r\n    /// @param _name Category name\r\n    /// @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n    /// @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n    /// @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n    /// @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n    /// @param _closingTime Vote closing time for Each voting layer\r\n    /// @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n    /// @param _contractAddress address of contract to call after proposal is accepted\r\n    /// @param _contractName name of contract to be called after proposal is accepted\r\n    /// @param _incentives rewards to distributed after proposal is accepted\r\n    function addCategory(\r\n        string calldata _name, \r\n        uint _memberRoleToVote,\r\n        uint _majorityVotePerc, \r\n        uint _quorumPerc,\r\n        uint[] calldata _allowedToCreateProposal,\r\n        uint _closingTime,\r\n        string calldata _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint[] calldata _incentives\r\n    ) \r\n        external\r\n        onlyAuthorizedToGovern \r\n    {\r\n        _addCategory(\r\n            _name, \r\n            _memberRoleToVote,\r\n            _majorityVotePerc, \r\n            _quorumPerc,\r\n            _allowedToCreateProposal,\r\n            _closingTime,\r\n            _actionHash,\r\n            _contractAddress,\r\n            _contractName,\r\n            _incentives\r\n        );\r\n    }\r\n\r\n    /// @dev Gets Total number of categories added till now\r\n    function totalCategories() external view returns(uint) {\r\n        return allCategory.length;\r\n    }\r\n\r\n    /// @dev gets category details\r\n    function category(uint _categoryId) external view returns(uint, uint, uint, uint, uint[] memory, uint, uint) {\r\n        return(\r\n            _categoryId,\r\n            allCategory[_categoryId].memberRoleToVote,\r\n            allCategory[_categoryId].majorityVotePerc,\r\n            allCategory[_categoryId].quorumPerc,\r\n            allCategory[_categoryId].allowedToCreateProposal,\r\n            allCategory[_categoryId].closingTime,\r\n            allCategory[_categoryId].minStake\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev to get the category acion details of a category id \r\n     * @param _categoryId is the category id in concern\r\n     * @return the category id\r\n     * @return the contract address\r\n     * @return the contract name\r\n     * @return the default incentive\r\n     */\r\n    function categoryAction(uint _categoryId) external view returns(uint, address, bytes2, uint) {\r\n        return(\r\n            _categoryId,\r\n            categoryActionData[_categoryId].contractAddress,\r\n            categoryActionData[_categoryId].contractName,\r\n            categoryActionData[_categoryId].defaultIncentive\r\n        );\r\n    }\r\n\r\n    /// @dev Initiates Default settings for Proposal Category contract (Adding default categories)\r\n    function proposalCategoryInitiate() external { //solhint-disable-line\r\n        require(!constructorCheck);\r\n        _addInitialCategories(\"Uncategorized\", \"\", \"MR\", 60, 15, 1, 0); //0\r\n        _addInitialCategories(\"Add new member role\", \"QmQFnBep7AyMYU3LJDuHSpTYatnw65XjHzzirrghtZoR8U\", \r\n        \"MR\", 60, 15, 1, 0);\r\n        _addInitialCategories(\"Update member role\", \"QmXMzSViLBJ22P9oj51Zz7isKTRnXWPHZcQ5hzGvvWD3UV\", \r\n        \"MR\", 60, 15, 1, 0);\r\n        _addInitialCategories(\"Add new category\", \"QmUq9Rb6rWFHZXjVtyzh7AWGDeyVFtDHKiP5fJpgnuinQ7\", \"PC\", \r\n        60, 15, 1, 0);\r\n        _addInitialCategories(\"Edit category\", \"QmQmvfBiCLfe5jPdq69iRBRRdnSHSroJQ4SG8DhtkXcLfQ\",  //4\r\n        \"PC\", 60, 15, 1, 0);\r\n        _addInitialCategories(\r\n            \"Upgrade a contract Implementation\",\r\n            \"Qme4hGas6RuDYk9LKE2XkK9E46LNeCBUzY12DdT5uQstvh\",\r\n            \"MS\",\r\n            50,\r\n            15,\r\n            2,\r\n            80\r\n        );\r\n        \r\n        //  --------------------------------------------------------------------------------------------- //\r\n        _addInitialCategories(\"Implement Emergency Pause\", \"QmZSaEsvTCpy357ZSrPYKqby1iaksBwPdKCGWzW1HpgSpe\",\r\n        \"MS\", 0, 15, 1, 0);\r\n        _addInitialCategories(\"Extend or Switch Off Emergency Pause\", \"Qmao6dD8amq4kxsAheWn5gQX22ABucFFGRvnRuY1VqtEKy\",\r\n        \"MS\", 50, 15, 2, 0);\r\n        _addInitialCategories(\"Burn Claims Assessor Bond\", \"QmezNJUF2BM5Nv9EMnsEKUmuqjvdySzvQFvhEdvFJbau3k\", //8\r\n        \"TF\", 80, 15, 1, 0);\r\n        _addInitialCategories(\"Pause Claim Assessor Voting for 3 days\", \r\n        \"QmRBXh9NGoGV7U7tTurKPhL4bzvDc9n23QZYidELpBPVdg\", \"CD\", 60, 15, 1, 0);\r\n        _addInitialCategories(\"Changes to Capital Model\", \"\", \"EX\", 50, 15, 2, 60);\r\n        _addInitialCategories(\"Changes to Pricing Model\", \"\", \"EX\", 50, 15, 2, 60);\r\n        _addInitialCategories(\"Withdraw funds to Pay for Support Services\", \r\n        \"QmZQhJunZesYuCJkdGwejSATTR8eynUgV8372cHvnAPMaM\", \"P1\", 50, 15, 2, 80);\r\n        // _addInitialCategories(\"Change to Authorities\", \"\", \"EX\", 80, 15, 2); //no func yet\r\n        _addInitialCategories(\"Add Investment Asset\", \"Qmd66GdYtn1BYmZTB1op1Fbfkq6uywMpow5LRmG2Twbzjb\", //13\r\n        \"PD\", 50, 15, 2, 60);\r\n        _addInitialCategories(\"Edit Investment Asset min and max holding percentages\", \r\n        \"QmXwyffmk7rYGHE7p4g3oroJkmyEYAn6EffhZu2MCNcJGA\",\r\n        \"PD\", 50, 15, 2, 60);\r\n        _addInitialCategories(\"Update Investment Asset Status\", \"QmZkxcC82WFRvnBahLT3eQ95ZSGMxuAyCYqxvR3tSyhFmB\",\r\n        \"PD\", 50, 15, 2, 60);\r\n        _addInitialCategories(\"Change AB Member\", \"QmUBjPDdSiG3pRMqkVzZA2WaqiksT7ixNd3gPQwngGmF9x\", \r\n            \"MR\", 50, 15, 2, 0); \r\n        _addInitialCategories(\"Add Currency Asset\", \"QmYtpNuTdProressqZwEmN7cFtyyJvhFBrqr6xnxQGWrPm\", //17\r\n            \"PD\", 50, 15, 2, 0);\r\n        _addInitialCategories(\"Any other Item\", \"\", \"EX\", 50, 15, 2, 80);\r\n        _addInitialCategories(\"Special Resolution\", \"\", \"EX\", 75, 0, 2, 0);\r\n        _addInitialCategories(\"Update Token Parameters\", \"QmbfJTXyLTDsq41U4dukHbagcXef8bRfyMdMqcqLd9aKNM\", \r\n            \"TD\", 50, 15, 2, 60);\r\n        _addInitialCategories(\"Update Risk Assessment Parameters\", \"QmUHvBShLpDwPWAsWcZvbUJfVGyXYscybi5ASmF6ectxSo\",\r\n        //21\r\n            \"TD\", 50, 15, 2, 60);\r\n        _addInitialCategories(\"Update Governance Parameters\", \"QmdFDVEaZnJxXncFczTW6EvrcgR3jBfuPWftR7PfkPfqqT\", \r\n            \"GV\", 50, 15, 2, 60);\r\n        _addInitialCategories(\"Update Quotation Parameters\", \"QmTtSbBp2Cxaz8HzB4TingUozr9AW91siCfMjjyzf8qqAb\", \r\n            \"QD\", 50, 15, 2, 60);\r\n        _addInitialCategories(\"Update Claims Assessment Parameters\", \"QmPo6HPydwXEeoVdwBpwGeZasFnmFwZoTsQ93Bg5pFtQg6\", \r\n            \"CD\", 50, 15, 2, 60);\r\n        _addInitialCategories(\"Update Investment Module Parameters\", \"QmYSUJBJD9hUevydfdF34rGFG7bBQhMrxh2ga9XfeAkdEM\", \r\n        //25\r\n            \"PD\", 50, 15, 2, 60);\r\n        _addInitialCategories(\"Update Capital Model Parameters\", \"QmaQH6AdvBdgrW4xdzcMHa7gNyYSGa2fz7gBuuic2hLkZQ\", \r\n            \"PD\", 50, 15, 2, 60);\r\n        _addInitialCategories(\"Update Address Parameters\", \"QmPfXySkeDFbdMvZyD35y1hiB4g6ZXLSEHfS7JjS6e1VKL\", \r\n            \"MS\", 50, 15, 2, 60);\r\n        _addInitialCategories(\"Update Owner Parameters\", \"QmTEmDA1ECmGPfh5x3co1GmjXQCp3zisUP6rnLQjWmW8nu\", //28\r\n            \"MS\", 50, 15, 3, 0);\r\n        _addInitialCategories(\"Release new smart contract code\", \"QmSStfVwXF1TzDPCseVtMydgdF1xmzqhMtfpUg9Btx7tUp\", \r\n        \"MS\", 50, 15, 2, 80);\r\n        _addInitialCategories(\"Edit Currency Asset Address\", \"QmahwCzxmUX1QEjgczmA2NF4Nxtx839eRLCXbBFeFCm3cF\",\r\n        \"PD\", 50, 15, 3, 60);\r\n        _addInitialCategories(\"Edit Currency Asset baseMin\", \"QmeFSwZ21d7XabxVc7eiNKbtfEXUuD8qQXkeHZ5To1vo4t\",\r\n        \"PD\", 50, 15, 2, 60);\r\n        _addInitialCategories(\"Edit Investment Asset Address and decimal\", \r\n        \"QmRpztKqva2ud5xz9CQeb562bRQt2VEBPnjaWEPwN8q3vf\",\r\n        \"PD\", 50, 15, 3, 60);\r\n        constructorCheck = true;\r\n    }\r\n\r\n    function changeDependentContractAddress() public {\r\n        mr = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n    }\r\n\r\n    /**\r\n     * @dev to change the master address\r\n     * @param _masterAddress is the new master address\r\n     */\r\n    function changeMasterAddress(address _masterAddress) public {\r\n        if (masterAddress != address(0))\r\n            require(masterAddress == msg.sender);\r\n        masterAddress = _masterAddress;\r\n        ms = INXMMaster(_masterAddress);\r\n        nxMasterAddress = _masterAddress;\r\n        \r\n    }\r\n\r\n    /// @dev Updates category details\r\n    /// @param _categoryId Category id that needs to be updated\r\n    /// @param _name Category name\r\n    /// @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n    /// @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n    /// @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n    /// @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n    /// @param _closingTime Vote closing time for Each voting layer\r\n    /// @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n    /// @param _contractAddress address of contract to call after proposal is accepted\r\n    /// @param _contractName name of contract to be called after proposal is accepted\r\n    /// @param _incentives rewards to distributed after proposal is accepted\r\n    function updateCategory(\r\n        uint _categoryId, \r\n        string memory _name, \r\n        uint _memberRoleToVote, \r\n        uint _majorityVotePerc, \r\n        uint _quorumPerc,\r\n        uint[] memory _allowedToCreateProposal,\r\n        uint _closingTime,\r\n        string memory _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint[] memory _incentives\r\n    )\r\n        public\r\n        onlyAuthorizedToGovern\r\n    {\r\n        require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 0, \"Invalid Role\");\r\n        allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\r\n        allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\r\n        allCategory[_categoryId].closingTime = _closingTime;\r\n        allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\r\n        allCategory[_categoryId].minStake = _incentives[0];\r\n        allCategory[_categoryId].quorumPerc = _quorumPerc;\r\n        categoryActionData[_categoryId].defaultIncentive = _incentives[1];\r\n        categoryActionData[_categoryId].contractName = _contractName;\r\n        categoryActionData[_categoryId].contractAddress = _contractAddress;\r\n        categoryABReq[_categoryId] = _incentives[2];\r\n        emit Category(_categoryId, _name, _actionHash);\r\n    }\r\n\r\n    /// @dev Adds new category\r\n    /// @param _name Category name\r\n    /// @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n    /// @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n    /// @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n    /// @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n    /// @param _closingTime Vote closing time for Each voting layer\r\n    /// @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n    /// @param _contractAddress address of contract to call after proposal is accepted\r\n    /// @param _contractName name of contract to be called after proposal is accepted\r\n    /// @param _incentives rewards to distributed after proposal is accepted\r\n    function _addCategory(\r\n        string memory _name, \r\n        uint _memberRoleToVote,\r\n        uint _majorityVotePerc, \r\n        uint _quorumPerc,\r\n        uint[] memory _allowedToCreateProposal,\r\n        uint _closingTime,\r\n        string memory _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint[] memory _incentives\r\n    ) \r\n        internal\r\n    {\r\n        require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 0, \"Invalid Role\");\r\n        allCategory.push(\r\n            CategoryStruct(\r\n                _memberRoleToVote,\r\n                _majorityVotePerc,\r\n                _quorumPerc,\r\n                _allowedToCreateProposal,\r\n                _closingTime,\r\n                _incentives[0]\r\n            )\r\n        );\r\n        uint categoryId = allCategory.length - 1;\r\n        categoryActionData[categoryId] = CategoryAction(_incentives[1], _contractAddress, _contractName);\r\n        categoryABReq[categoryId] = _incentives[2];\r\n        isSpecialResolution[categoryId] = _incentives[3];\r\n        emit Category(categoryId, _name, _actionHash);\r\n    }\r\n\r\n    function _verifyMemberRoles(uint _memberRoleToVote, uint[] memory _allowedToCreateProposal) \r\n    internal view returns(uint) { \r\n        uint totalRoles = mr.totalRoles();\r\n        if (_memberRoleToVote \u003e= totalRoles) {\r\n            return 1;\r\n        }\r\n        for (uint i = 0; i \u003c _allowedToCreateProposal.length; i++) {\r\n            if (_allowedToCreateProposal[i] \u003e= totalRoles) {\r\n                return 1;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @dev to add the initial categories \r\n     * @param _name is category name\r\n     * @param _actionHash hash of category action\r\n     * @param _contractName is the name of contract\r\n     * @param _majorityVotePerc percentage of majority vote\r\n     * @param _quorumPerc is the quorom percentage\r\n     * @param _memberRoleToVote is the member role the category can vote on\r\n     * @param _categoryABReq is majority percentage required by advisory board \r\n     */\r\n    function _addInitialCategories(\r\n        string memory _name,\r\n        string memory _actionHash,\r\n        bytes2 _contractName,\r\n        uint _majorityVotePerc, \r\n        uint _quorumPerc,\r\n        uint _memberRoleToVote,\r\n        uint _categoryABReq\r\n    ) \r\n        internal \r\n    {\r\n        uint[] memory allowedToCreateProposal = new uint[](1);\r\n        uint[] memory stakeIncentive = new uint[](4);\r\n        if (_memberRoleToVote == 3) {\r\n            allowedToCreateProposal[0] = 3;\r\n        } else {\r\n            allowedToCreateProposal[0] = 2;\r\n        }\r\n        stakeIncentive[0] = 0;\r\n        stakeIncentive[1] = 0;\r\n        stakeIncentive[2] = _categoryABReq;\r\n        if (_quorumPerc == 0) {//For special resolutions\r\n            stakeIncentive[3] = 1;\r\n        } else {\r\n            stakeIncentive[3] = 0;\r\n        }\r\n        _addCategory(\r\n                _name,\r\n                _memberRoleToVote,\r\n                _majorityVotePerc,\r\n                _quorumPerc,\r\n                allowedToCreateProposal,\r\n                604800,\r\n                _actionHash,\r\n                address(0),\r\n                _contractName,\r\n                stakeIncentive\r\n            );\r\n    }\r\n\r\n\r\n}"},"Quotation.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\nimport \"./QuotationData.sol\";\r\nimport \"./TokenFunctions.sol\";\r\nimport \"./TokenController.sol\";\r\nimport \"./TokenData.sol\";\r\nimport \"./PoolData.sol\";\r\nimport \"./MCR.sol\";\r\nimport \"./MemberRoles.sol\";\r\nimport \"./Pool1.sol\";\r\n\r\n\r\ncontract Quotation is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    TokenFunctions internal tf;\r\n    TokenController internal tc;\r\n    TokenData internal td;\r\n    Pool1 internal p1;\r\n    PoolData internal pd;\r\n    QuotationData internal qd;\r\n    MCR internal m1;\r\n    MemberRoles internal mr;\r\n    bool internal locked;\r\n\r\n    event RefundEvent(address indexed user, bool indexed status, uint holdedCoverID, bytes32 reason);\r\n\r\n    modifier noReentrancy() {\r\n        require(!locked, \"Reentrant call.\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n    \r\n    /**\r\n     * @dev Iupgradable Interface to update dependent contract address\r\n     */\r\n    function changeDependentContractAddress() public onlyInternal {\r\n        m1 = MCR(ms.getLatestAddress(\"MC\"));\r\n        tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\r\n        tc = TokenController(ms.getLatestAddress(\"TC\"));\r\n        td = TokenData(ms.getLatestAddress(\"TD\"));\r\n        qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n        p1 = Pool1(ms.getLatestAddress(\"P1\"));\r\n        pd = PoolData(ms.getLatestAddress(\"PD\"));\r\n        mr = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n    }\r\n\r\n    function sendEther() public payable {\r\n        \r\n    }\r\n\r\n    /**\r\n     * @dev Expires a cover after a set period of time.\r\n     * Changes the status of the Cover and reduces the current\r\n     * sum assured of all areas in which the quotation lies\r\n     * Unlocks the CN tokens of the cover. Updates the Total Sum Assured value.\r\n     * @param _cid Cover Id.\r\n     */ \r\n    function expireCover(uint _cid) public {\r\n        require(checkCoverExpired(_cid) \u0026\u0026 qd.getCoverStatusNo(_cid) != uint(QuotationData.CoverStatus.CoverExpired));\r\n        \r\n        tf.unlockCN(_cid);\r\n        bytes4 curr;\r\n        address scAddress;\r\n        uint sumAssured;\r\n        (, , scAddress, curr, sumAssured, ) = qd.getCoverDetailsByCoverID1(_cid);\r\n        if (qd.getCoverStatusNo(_cid) != uint(QuotationData.CoverStatus.ClaimAccepted))\r\n            _removeSAFromCSA(_cid, sumAssured);\r\n        qd.changeCoverStatusNo(_cid, uint8(QuotationData.CoverStatus.CoverExpired));       \r\n    }\r\n\r\n    /**\r\n     * @dev Checks if a cover should get expired/closed or not.\r\n     * @param _cid Cover Index.\r\n     * @return expire true if the Cover\u0027s time has expired, false otherwise.\r\n     */ \r\n    function checkCoverExpired(uint _cid) public view returns(bool expire) {\r\n\r\n        expire = qd.getValidityOfCover(_cid) \u003c uint64(now);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the Sum Assured Amount of all the quotation.\r\n     * @param _cid Cover id\r\n     * @param _amount that will get subtracted Current Sum Assured \r\n     * amount that comes under a quotation.\r\n     */ \r\n    function removeSAFromCSA(uint _cid, uint _amount) public onlyInternal {\r\n        _removeSAFromCSA(_cid, _amount);        \r\n    }\r\n\r\n    /**\r\n     * @dev Makes Cover funded via NXM tokens.\r\n     * @param smartCAdd Smart Contract Address\r\n     */ \r\n    function makeCoverUsingNXMTokens(\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod,\r\n        bytes4 coverCurr,\r\n        address smartCAdd,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        public\r\n        isMemberAndcheckPause\r\n    {\r\n        \r\n        tc.burnFrom(msg.sender, coverDetails[2]); //need burn allowance\r\n        _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\r\n    }\r\n\r\n    /**\r\n     * @dev Verifies cover details signed off chain.\r\n     * @param from address of funder.\r\n     * @param scAddress Smart Contract Address\r\n     */\r\n    function verifyCoverDetails(\r\n        address payable from,\r\n        address scAddress,\r\n        bytes4 coverCurr,\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        public\r\n        onlyInternal\r\n    {\r\n        _verifyCoverDetails(\r\n            from,\r\n            scAddress,\r\n            coverCurr,\r\n            coverDetails,\r\n            coverPeriod,\r\n            _v,\r\n            _r,\r\n            _s\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev Verifies signature.\r\n     * @param coverDetails details related to cover.\r\n     * @param coverPeriod validity of cover.\r\n     * @param smaratCA smarat contract address.\r\n     * @param _v argument from vrs hash.\r\n     * @param _r argument from vrs hash.\r\n     * @param _s argument from vrs hash.\r\n     */ \r\n    function verifySign(\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod,\r\n        bytes4 curr,\r\n        address smaratCA,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) \r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        require(smaratCA != address(0));\r\n        require(pd.capReached() == 1, \"Can not buy cover until cap reached for 1st time\");\r\n        bytes32 hash = getOrderHash(coverDetails, coverPeriod, curr, smaratCA);\r\n        return isValidSignature(hash, _v, _r, _s);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets order hash for given cover details.\r\n     * @param coverDetails details realted to cover.\r\n     * @param coverPeriod validity of cover.\r\n     * @param smaratCA smarat contract address.\r\n     */ \r\n    function getOrderHash(\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod,\r\n        bytes4 curr,\r\n        address smaratCA\r\n    ) \r\n        public\r\n        view\r\n        returns(bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                coverDetails[0],\r\n                curr, coverPeriod,\r\n                smaratCA,\r\n                coverDetails[1],\r\n                coverDetails[2],\r\n                coverDetails[3],\r\n                coverDetails[4],\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Verifies signature.\r\n     * @param hash order hash\r\n     * @param v argument from vrs hash.\r\n     * @param r argument from vrs hash.\r\n     * @param s argument from vrs hash.\r\n     */  \r\n    function isValidSignature(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public view returns(bool) {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\r\n        address a = ecrecover(prefixedHash, v, r, s);\r\n        return (a == qd.getAuthQuoteEngine());\r\n    }\r\n\r\n    /**\r\n     * @dev to get the status of recently holded coverID \r\n     * @param userAdd is the user address in concern\r\n     * @return the status of the concerned coverId\r\n     */\r\n    function getRecentHoldedCoverIdStatus(address userAdd) public view returns(int) {\r\n\r\n        uint holdedCoverLen = qd.getUserHoldedCoverLength(userAdd);\r\n        if (holdedCoverLen == 0) {\r\n            return -1;\r\n        } else {\r\n            uint holdedCoverID = qd.getUserHoldedCoverByIndex(userAdd, holdedCoverLen.sub(1));\r\n            return int(qd.holdedCoverIDStatus(holdedCoverID));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev to initiate the membership and the cover \r\n     * @param smartCAdd is the smart contract address to make cover on\r\n     * @param coverCurr is the currency used to make cover\r\n     * @param coverDetails list of details related to cover like cover amount, expire time, coverCurrPrice and priceNXM\r\n     * @param coverPeriod is cover period for which cover is being bought\r\n     * @param _v argument from vrs hash \r\n     * @param _r argument from vrs hash \r\n     * @param _s argument from vrs hash \r\n     */\r\n    function initiateMembershipAndCover(\r\n        address smartCAdd,\r\n        bytes4 coverCurr,\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) \r\n        public\r\n        payable\r\n        checkPause\r\n    {\r\n        require(coverDetails[3] \u003e now);\r\n        require(!qd.timestampRepeated(coverDetails[4]));\r\n        qd.setTimestampRepeated(coverDetails[4]);\r\n        require(!ms.isMember(msg.sender));\r\n        require(qd.refundEligible(msg.sender) == false);\r\n        uint joinFee = td.joiningFee();\r\n        uint totalFee = joinFee;\r\n        if (coverCurr == \"ETH\") {\r\n            totalFee = joinFee.add(coverDetails[1]);\r\n        } else {\r\n            IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\r\n            require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]));\r\n        }\r\n        require(msg.value == totalFee);\r\n        require(verifySign(coverDetails, coverPeriod, coverCurr, smartCAdd, _v, _r, _s));\r\n        qd.addHoldCover(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod);\r\n        qd.setRefundEligible(msg.sender, true);\r\n    }\r\n\r\n    /**\r\n     * @dev to get the verdict of kyc process \r\n     * @param status is the kyc status\r\n     * @param _add is the address of member\r\n     */\r\n    function kycVerdict(address _add, bool status) public checkPause noReentrancy {\r\n        require(msg.sender == qd.kycAuthAddress());\r\n        _kycTrigger(status, _add);\r\n    }\r\n\r\n    /**\r\n     * @dev transfering Ethers to newly created quotation contract.\r\n     */  \r\n    function transferAssetsToNewContract(address newAdd) public onlyInternal noReentrancy {\r\n        uint amount = address(this).balance;\r\n        IERC20 erc20;\r\n        if (amount \u003e 0) {\r\n            // newAdd.transfer(amount);   \r\n            Quotation newQT = Quotation(newAdd);\r\n            newQT.sendEther.value(amount)();\r\n        }\r\n        uint currAssetLen = pd.getAllCurrenciesLen();\r\n        for (uint64 i = 1; i \u003c currAssetLen; i++) {\r\n            bytes4 currName = pd.getCurrenciesByIndex(i);\r\n            address currAddr = pd.getCurrencyAssetAddress(currName);\r\n            erc20 = IERC20(currAddr); //solhint-disable-line\r\n            if (erc20.balanceOf(address(this)) \u003e 0) {\r\n                require(erc20.transfer(newAdd, erc20.balanceOf(address(this))));\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Creates cover of the quotation, changes the status of the quotation ,\r\n     * updates the total sum assured and locks the tokens of the cover against a quote.\r\n     * @param from Quote member Ethereum address.\r\n     */  \r\n\r\n    function _makeCover ( //solhint-disable-line\r\n        address payable from,\r\n        address scAddress,\r\n        bytes4 coverCurr,\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod\r\n    )\r\n        internal\r\n    {\r\n        uint cid = qd.getCoverLength();\r\n        qd.addCover(coverPeriod, coverDetails[0],\r\n            from, coverCurr, scAddress, coverDetails[1], coverDetails[2]);\r\n        // if cover period of quote is less than 60 days.\r\n        if (coverPeriod \u003c= 60) {\r\n            p1.closeCoverOraclise(cid, uint64(uint(coverPeriod).mul(1 days)));\r\n        }\r\n        uint coverNoteAmount = (coverDetails[2].mul(qd.tokensRetained())).div(100);\r\n        tc.mint(from, coverNoteAmount);\r\n        tf.lockCN(coverNoteAmount, coverPeriod, cid, from);\r\n        qd.addInTotalSumAssured(coverCurr, coverDetails[0]);\r\n        qd.addInTotalSumAssuredSC(scAddress, coverCurr, coverDetails[0]);\r\n        if (tf.getTotalStakedTokensOnSmartContract(scAddress) \u003e 0)\r\n            tf.updateStakerCommissions(scAddress, coverDetails[2]);\r\n        \r\n    }\r\n\r\n    /**\r\n     * @dev Makes a vover.\r\n     * @param from address of funder.\r\n     * @param scAddress Smart Contract Address\r\n     */  \r\n    function _verifyCoverDetails(\r\n        address payable from,\r\n        address scAddress,\r\n        bytes4 coverCurr,\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        internal\r\n    {\r\n        require(coverDetails[3] \u003e now);\r\n        require(!qd.timestampRepeated(coverDetails[4]));\r\n        qd.setTimestampRepeated(coverDetails[4]);\r\n        require(verifySign(coverDetails, coverPeriod, coverCurr, scAddress, _v, _r, _s));\r\n        _makeCover(from, scAddress, coverCurr, coverDetails, coverPeriod);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the Sum Assured Amount of all the quotation.\r\n     * @param _cid Cover id\r\n     * @param _amount that will get subtracted Current Sum Assured \r\n     * amount that comes under a quotation.\r\n     */ \r\n    function _removeSAFromCSA(uint _cid, uint _amount) internal checkPause {\r\n        address _add;\r\n        bytes4 coverCurr;\r\n        (, , _add, coverCurr, , ) = qd.getCoverDetailsByCoverID1(_cid);\r\n        qd.subFromTotalSumAssured(coverCurr, _amount);        \r\n        qd.subFromTotalSumAssuredSC(_add, coverCurr, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev to trigger the kyc process \r\n     * @param status is the kyc status\r\n     * @param _add is the address of member\r\n     */\r\n    function _kycTrigger(bool status, address _add) internal {\r\n\r\n        uint holdedCoverLen = qd.getUserHoldedCoverLength(_add).sub(1);\r\n        uint holdedCoverID = qd.getUserHoldedCoverByIndex(_add, holdedCoverLen);\r\n        address payable userAdd;\r\n        address scAddress;\r\n        bytes4 coverCurr;\r\n        uint16 coverPeriod;\r\n        uint[]  memory coverDetails = new uint[](4);\r\n        IERC20 erc20;\r\n\r\n        (, userAdd, coverDetails) = qd.getHoldedCoverDetailsByID2(holdedCoverID);\r\n        (, scAddress, coverCurr, coverPeriod) = qd.getHoldedCoverDetailsByID1(holdedCoverID);\r\n        require(qd.refundEligible(userAdd));\r\n        qd.setRefundEligible(userAdd, false);\r\n        require(qd.holdedCoverIDStatus(holdedCoverID) == uint(QuotationData.HCIDStatus.kycPending));\r\n        uint joinFee = td.joiningFee();\r\n        if (status) {\r\n            mr.payJoiningFee.value(joinFee)(userAdd);\r\n            if (coverDetails[3] \u003e now) { \r\n                qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycPass));\r\n                address poolAdd = ms.getLatestAddress(\"P1\");\r\n                if (coverCurr == \"ETH\") {\r\n                    p1.sendEther.value(coverDetails[1])();\r\n                } else {\r\n                    erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); //solhint-disable-line\r\n                    require(erc20.transfer(poolAdd, coverDetails[1]));\r\n                }\r\n                emit RefundEvent(userAdd, status, holdedCoverID, \"KYC Passed\");               \r\n                _makeCover(userAdd, scAddress, coverCurr, coverDetails, coverPeriod);\r\n\r\n            } else {\r\n                qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycPassNoCover));\r\n                if (coverCurr == \"ETH\") {\r\n                    userAdd.transfer(coverDetails[1]);\r\n                } else {\r\n                    erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); //solhint-disable-line\r\n                    require(erc20.transfer(userAdd, coverDetails[1]));\r\n                }\r\n                emit RefundEvent(userAdd, status, holdedCoverID, \"Cover Failed\");\r\n            }\r\n        } else {\r\n            qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycFailedOrRefunded));\r\n            uint totalRefund = joinFee;\r\n            if (coverCurr == \"ETH\") {\r\n                totalRefund = coverDetails[1].add(joinFee);\r\n            } else {\r\n                erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); //solhint-disable-line\r\n                require(erc20.transfer(userAdd, coverDetails[1]));\r\n            }\r\n            userAdd.transfer(totalRefund);\r\n            emit RefundEvent(userAdd, status, holdedCoverID, \"KYC Failed\");\r\n        }\r\n              \r\n    }\r\n}\r\n"},"QuotationData.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\nimport \"./Iupgradable.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\n\r\ncontract QuotationData is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    enum HCIDStatus { NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover }\r\n\r\n    enum CoverStatus { Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested }\r\n\r\n    struct Cover {\r\n        address payable memberAddress;\r\n        bytes4 currencyCode;\r\n        uint sumAssured;\r\n        uint16 coverPeriod;\r\n        uint validUntil;\r\n        address scAddress;\r\n        uint premiumNXM;\r\n    }\r\n\r\n    struct HoldCover {\r\n        uint holdCoverId;\r\n        address payable userAddress;\r\n        address scAddress;\r\n        bytes4 coverCurr;\r\n        uint[] coverDetails;\r\n        uint16 coverPeriod;\r\n    }\r\n\r\n    address public authQuoteEngine;\r\n  \r\n    mapping(bytes4 =\u003e uint) internal currencyCSA;\r\n    mapping(address =\u003e uint[]) internal userCover;\r\n    mapping(address =\u003e uint[]) public userHoldedCover;\r\n    mapping(address =\u003e bool) public refundEligible;\r\n    mapping(address =\u003e mapping(bytes4 =\u003e uint)) internal currencyCSAOfSCAdd;\r\n    mapping(uint =\u003e uint8) public coverStatus;\r\n    mapping(uint =\u003e uint) public holdedCoverIDStatus;\r\n    mapping(uint =\u003e bool) public timestampRepeated; \r\n    \r\n\r\n    Cover[] internal allCovers;\r\n    HoldCover[] internal allCoverHolded;\r\n\r\n    uint public stlp;\r\n    uint public stl;\r\n    uint public pm;\r\n    uint public minDays;\r\n    uint public tokensRetained;\r\n    address public kycAuthAddress;\r\n\r\n    event CoverDetailsEvent(\r\n        uint indexed cid,\r\n        address scAdd,\r\n        uint sumAssured,\r\n        uint expiry,\r\n        uint premium,\r\n        uint premiumNXM,\r\n        bytes4 curr\r\n    );\r\n\r\n    event CoverStatusEvent(uint indexed cid, uint8 statusNum);\r\n\r\n    constructor(address _authQuoteAdd, address _kycAuthAdd) public {\r\n        authQuoteEngine = _authQuoteAdd;\r\n        kycAuthAddress = _kycAuthAdd;\r\n        stlp = 90;\r\n        stl = 100;\r\n        pm = 30;\r\n        minDays = 30;\r\n        tokensRetained = 10;\r\n        allCovers.push(Cover(address(0), \"0x00\", 0, 0, 0, address(0), 0));\r\n        uint[] memory arr = new uint[](1);\r\n        allCoverHolded.push(HoldCover(0, address(0), address(0), 0x00, arr, 0));\r\n\r\n    }\r\n    \r\n    /// @dev Adds the amount in Total Sum Assured of a given currency of a given smart contract address.\r\n    /// @param _add Smart Contract Address.\r\n    /// @param _amount Amount to be added.\r\n    function addInTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\r\n        currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].add(_amount);\r\n    }\r\n\r\n    /// @dev Subtracts the amount from Total Sum Assured of a given currency and smart contract address.\r\n    /// @param _add Smart Contract Address.\r\n    /// @param _amount Amount to be subtracted.\r\n    function subFromTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\r\n        currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].sub(_amount);\r\n    }\r\n    \r\n    /// @dev Subtracts the amount from Total Sum Assured of a given currency.\r\n    /// @param _curr Currency Name.\r\n    /// @param _amount Amount to be subtracted.\r\n    function subFromTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\r\n        currencyCSA[_curr] = currencyCSA[_curr].sub(_amount);\r\n    }\r\n\r\n    /// @dev Adds the amount in Total Sum Assured of a given currency.\r\n    /// @param _curr Currency Name.\r\n    /// @param _amount Amount to be added.\r\n    function addInTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\r\n        currencyCSA[_curr] = currencyCSA[_curr].add(_amount);\r\n    }\r\n\r\n    /// @dev sets bit for timestamp to avoid replay attacks.\r\n    function setTimestampRepeated(uint _timestamp) external onlyInternal {\r\n        timestampRepeated[_timestamp] = true;\r\n    }\r\n    \r\n    /// @dev Creates a blank new cover.\r\n    function addCover(\r\n        uint16 _coverPeriod,\r\n        uint _sumAssured,\r\n        address payable _userAddress,\r\n        bytes4 _currencyCode,\r\n        address _scAddress,\r\n        uint premium,\r\n        uint premiumNXM\r\n    )   \r\n        external\r\n        onlyInternal\r\n    {\r\n        uint expiryDate = now.add(uint(_coverPeriod).mul(1 days));\r\n        allCovers.push(Cover(_userAddress, _currencyCode,\r\n                _sumAssured, _coverPeriod, expiryDate, _scAddress, premiumNXM));\r\n        uint cid = allCovers.length.sub(1);\r\n        userCover[_userAddress].push(cid);\r\n        emit CoverDetailsEvent(cid, _scAddress, _sumAssured, expiryDate, premium, premiumNXM, _currencyCode);\r\n    }\r\n\r\n    /// @dev create holded cover which will process after verdict of KYC.\r\n    function addHoldCover(\r\n        address payable from,\r\n        address scAddress,\r\n        bytes4 coverCurr, \r\n        uint[] calldata coverDetails,\r\n        uint16 coverPeriod\r\n    )   \r\n        external\r\n        onlyInternal\r\n    {\r\n        uint holdedCoverLen = allCoverHolded.length;\r\n        holdedCoverIDStatus[holdedCoverLen] = uint(HCIDStatus.kycPending);             \r\n        allCoverHolded.push(HoldCover(holdedCoverLen, from, scAddress, \r\n            coverCurr, coverDetails, coverPeriod));\r\n        userHoldedCover[from].push(allCoverHolded.length.sub(1));\r\n    \r\n    }\r\n\r\n    ///@dev sets refund eligible bit.\r\n    ///@param _add user address.\r\n    ///@param status indicates if user have pending kyc.\r\n    function setRefundEligible(address _add, bool status) external onlyInternal {\r\n        refundEligible[_add] = status;\r\n    }\r\n\r\n    /// @dev to set current status of particular holded coverID (1 for not completed KYC,\r\n    /// 2 for KYC passed, 3 for failed KYC or full refunded,\r\n    /// 4 for KYC completed but cover not processed)\r\n    function setHoldedCoverIDStatus(uint holdedCoverID, uint status) external onlyInternal {\r\n        holdedCoverIDStatus[holdedCoverID] = status;\r\n    }\r\n\r\n    /**\r\n     * @dev to set address of kyc authentication \r\n     * @param _add is the new address\r\n     */\r\n    function setKycAuthAddress(address _add) external onlyInternal {\r\n        kycAuthAddress = _add;\r\n    }\r\n\r\n    /// @dev Changes authorised address for generating quote off chain.\r\n    function changeAuthQuoteEngine(address _add) external onlyInternal {\r\n        authQuoteEngine = _add;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Uint Parameters of a code\r\n     * @param code whose details we want\r\n     * @return string value of the code\r\n     * @return associated amount (time or perc or value) to the code\r\n     */\r\n    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint val) {\r\n        codeVal = code;\r\n\r\n        if (code == \"STLP\") {\r\n            val = stlp;\r\n\r\n        } else if (code == \"STL\") {\r\n            \r\n            val = stl;\r\n\r\n        } else if (code == \"PM\") {\r\n\r\n            val = pm;\r\n\r\n        } else if (code == \"QUOMIND\") {\r\n\r\n            val = minDays;\r\n\r\n        } else if (code == \"QUOTOK\") {\r\n\r\n            val = tokensRetained;\r\n\r\n        }\r\n        \r\n    }\r\n\r\n    /// @dev Gets Product details.\r\n    /// @return  _minDays minimum cover period.\r\n    /// @return  _PM Profit margin.\r\n    /// @return  _STL short term Load.\r\n    /// @return  _STLP short term load period.\r\n    function getProductDetails()\r\n        external\r\n        view\r\n        returns (\r\n            uint _minDays,\r\n            uint _pm,\r\n            uint _stl,\r\n            uint _stlp\r\n        )\r\n    {\r\n\r\n        _minDays = minDays;\r\n        _pm = pm;\r\n        _stl = stl;\r\n        _stlp = stlp;\r\n    }\r\n\r\n    /// @dev Gets total number covers created till date.\r\n    function getCoverLength() external view returns(uint len) {\r\n        return (allCovers.length);\r\n    }\r\n\r\n    /// @dev Gets Authorised Engine address.\r\n    function getAuthQuoteEngine() external view returns(address _add) {\r\n        _add = authQuoteEngine;\r\n    }\r\n\r\n    /// @dev Gets the Total Sum Assured amount of a given currency.\r\n    function getTotalSumAssured(bytes4 _curr) external view returns(uint amount) {\r\n        amount = currencyCSA[_curr];\r\n    }\r\n\r\n    /// @dev Gets all the Cover ids generated by a given address.\r\n    /// @param _add User\u0027s address.\r\n    /// @return allCover array of covers.\r\n    function getAllCoversOfUser(address _add) external view returns(uint[] memory allCover) {\r\n        return (userCover[_add]);\r\n    }\r\n\r\n    /// @dev Gets total number of covers generated by a given address\r\n    function getUserCoverLength(address _add) external view returns(uint len) {\r\n        len = userCover[_add].length;\r\n    }\r\n\r\n    /// @dev Gets the status of a given cover.\r\n    function getCoverStatusNo(uint _cid) external view returns(uint8) {\r\n        return coverStatus[_cid];\r\n    }\r\n\r\n    /// @dev Gets the Cover Period (in days) of a given cover.\r\n    function getCoverPeriod(uint _cid) external view returns(uint32 cp) {\r\n        cp = allCovers[_cid].coverPeriod;\r\n    }\r\n\r\n    /// @dev Gets the Sum Assured Amount of a given cover.\r\n    function getCoverSumAssured(uint _cid) external view returns(uint sa) {\r\n        sa = allCovers[_cid].sumAssured;\r\n    }\r\n\r\n    /// @dev Gets the Currency Name in which a given cover is assured.\r\n    function getCurrencyOfCover(uint _cid) external view returns(bytes4 curr) {\r\n        curr = allCovers[_cid].currencyCode;\r\n    }\r\n\r\n    /// @dev Gets the validity date (timestamp) of a given cover.\r\n    function getValidityOfCover(uint _cid) external view returns(uint date) {\r\n        date = allCovers[_cid].validUntil;\r\n    }\r\n\r\n    /// @dev Gets Smart contract address of cover.\r\n    function getscAddressOfCover(uint _cid) external view returns(uint, address) {\r\n        return (_cid, allCovers[_cid].scAddress);\r\n    }\r\n\r\n    /// @dev Gets the owner address of a given cover.\r\n    function getCoverMemberAddress(uint _cid) external view returns(address payable _add) {\r\n        _add = allCovers[_cid].memberAddress;\r\n    }\r\n\r\n    /// @dev Gets the premium amount of a given cover in NXM.\r\n    function getCoverPremiumNXM(uint _cid) external view returns(uint _premiumNXM) {\r\n        _premiumNXM = allCovers[_cid].premiumNXM;\r\n    }\r\n\r\n    /// @dev Provides the details of a cover Id\r\n    /// @param _cid cover Id\r\n    /// @return memberAddress cover user address.\r\n    /// @return scAddress smart contract Address \r\n    /// @return currencyCode currency of cover\r\n    /// @return sumAssured sum assured of cover\r\n    /// @return premiumNXM premium in NXM\r\n    function getCoverDetailsByCoverID1(\r\n        uint _cid\r\n    ) \r\n        external\r\n        view\r\n        returns (\r\n            uint cid,\r\n            address _memberAddress,\r\n            address _scAddress,\r\n            bytes4 _currencyCode,\r\n            uint _sumAssured,  \r\n            uint premiumNXM \r\n        ) \r\n    {\r\n        return (\r\n            _cid,\r\n            allCovers[_cid].memberAddress,\r\n            allCovers[_cid].scAddress,\r\n            allCovers[_cid].currencyCode,\r\n            allCovers[_cid].sumAssured,\r\n            allCovers[_cid].premiumNXM\r\n        );\r\n    }\r\n\r\n    /// @dev Provides details of a cover Id\r\n    /// @param _cid cover Id\r\n    /// @return status status of cover.\r\n    /// @return sumAssured Sum assurance of cover.\r\n    /// @return coverPeriod Cover Period of cover (in days).\r\n    /// @return validUntil is validity of cover.\r\n    function getCoverDetailsByCoverID2(\r\n        uint _cid\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint cid,\r\n            uint8 status,\r\n            uint sumAssured,\r\n            uint16 coverPeriod,\r\n            uint validUntil\r\n        ) \r\n    {\r\n\r\n        return (\r\n            _cid,\r\n            coverStatus[_cid],\r\n            allCovers[_cid].sumAssured,\r\n            allCovers[_cid].coverPeriod,\r\n            allCovers[_cid].validUntil\r\n        );\r\n    }\r\n\r\n    /// @dev Provides details of a holded cover Id\r\n    /// @param _hcid holded cover Id\r\n    /// @return scAddress SmartCover address of cover.\r\n    /// @return coverCurr currency of cover.\r\n    /// @return coverPeriod Cover Period of cover (in days).\r\n    function getHoldedCoverDetailsByID1(\r\n        uint _hcid\r\n    )\r\n        external \r\n        view\r\n        returns (\r\n            uint hcid,\r\n            address scAddress,\r\n            bytes4 coverCurr,\r\n            uint16 coverPeriod\r\n        )\r\n    {\r\n        return (\r\n            _hcid,\r\n            allCoverHolded[_hcid].scAddress,\r\n            allCoverHolded[_hcid].coverCurr, \r\n            allCoverHolded[_hcid].coverPeriod\r\n        );\r\n    }\r\n\r\n    /// @dev Gets total number holded covers created till date.\r\n    function getUserHoldedCoverLength(address _add) external view returns (uint) {\r\n        return userHoldedCover[_add].length;\r\n    }\r\n\r\n    /// @dev Gets holded cover index by index of user holded covers.\r\n    function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint) {\r\n        return userHoldedCover[_add][index];\r\n    }\r\n\r\n    /// @dev Provides the details of a holded cover Id\r\n    /// @param _hcid holded cover Id\r\n    /// @return memberAddress holded cover user address.\r\n    /// @return coverDetails array contains SA, Cover Currency Price,Price in NXM, Expiration time of Qoute.    \r\n    function getHoldedCoverDetailsByID2(\r\n        uint _hcid\r\n    ) \r\n        external\r\n        view\r\n        returns (\r\n            uint hcid,\r\n            address payable memberAddress, \r\n            uint[] memory coverDetails\r\n        )\r\n    {\r\n        return (\r\n            _hcid,\r\n            allCoverHolded[_hcid].userAddress,\r\n            allCoverHolded[_hcid].coverDetails\r\n        );\r\n    }\r\n\r\n    /// @dev Gets the Total Sum Assured amount of a given currency and smart contract address.\r\n    function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns(uint amount) {\r\n        amount = currencyCSAOfSCAdd[_add][_curr];\r\n    }\r\n\r\n    //solhint-disable-next-line\r\n    function changeDependentContractAddress() public {}\r\n\r\n    /// @dev Changes the status of a given cover.\r\n    /// @param _cid cover Id.\r\n    /// @param _stat New status.\r\n    function changeCoverStatusNo(uint _cid, uint8 _stat) public onlyInternal {\r\n        coverStatus[_cid] = _stat;\r\n        emit CoverStatusEvent(_cid, _stat);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates Uint Parameters of a code\r\n     * @param code whose details we want to update\r\n     * @param val value to set\r\n     */\r\n    function updateUintParameters(bytes8 code, uint val) public {\r\n\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        if (code == \"STLP\") {\r\n            _changeSTLP(val);\r\n\r\n        } else if (code == \"STL\") {\r\n            \r\n            _changeSTL(val);\r\n\r\n        } else if (code == \"PM\") {\r\n\r\n            _changePM(val);\r\n\r\n        } else if (code == \"QUOMIND\") {\r\n\r\n            _changeMinDays(val);\r\n\r\n        } else if (code == \"QUOTOK\") {\r\n\r\n            _setTokensRetained(val);\r\n\r\n        } else {\r\n\r\n            revert(\"Invalid param code\");\r\n        }\r\n        \r\n    }\r\n    \r\n    /// @dev Changes the existing Profit Margin value\r\n    function _changePM(uint _pm) internal {\r\n        pm = _pm;\r\n    }\r\n\r\n    /// @dev Changes the existing Short Term Load Period (STLP) value.\r\n    function _changeSTLP(uint _stlp) internal {\r\n        stlp = _stlp;\r\n    }\r\n\r\n    /// @dev Changes the existing Short Term Load (STL) value.\r\n    function _changeSTL(uint _stl) internal {\r\n        stl = _stl;\r\n    }\r\n\r\n    /// @dev Changes the existing Minimum cover period (in days)\r\n    function _changeMinDays(uint _days) internal {\r\n        minDays = _days;\r\n    }\r\n    \r\n    /**\r\n     * @dev to set the the amount of tokens retained \r\n     * @param val is the amount retained\r\n     */\r\n    function _setTokensRetained(uint val) internal {\r\n        tokensRetained = val;\r\n    }\r\n}\r\n"},"SafeMath.sol":{"content":"pragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003e 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003c= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n"},"solidity-interface.sol":{"content":"pragma solidity 0.5.7;\r\n\r\n\r\ncontract Factory {\r\n    function getExchange(address token) public view returns (address);\r\n    function getToken(address exchange) public view returns (address);\r\n}\r\n\r\n\r\ncontract Exchange { \r\n    function getEthToTokenInputPrice(uint256 ethSold) public view returns(uint256);\r\n\r\n    function getTokenToEthInputPrice(uint256 tokensSold) public view returns(uint256);\r\n\r\n    function ethToTokenSwapInput(uint256 minTokens, uint256 deadline) public payable returns (uint256);\r\n\r\n    function ethToTokenTransferInput(uint256 minTokens, uint256 deadline, address recipient)\r\n        public payable returns (uint256);\r\n\r\n    function tokenToEthSwapInput(uint256 tokensSold, uint256 minEth, uint256 deadline)\r\n        public payable returns (uint256);\r\n\r\n    function tokenToEthTransferInput(uint256 tokensSold, uint256 minEth, uint256 deadline, address recipient) \r\n        public payable returns (uint256);\r\n\r\n    function tokenToTokenSwapInput(\r\n        uint256 tokensSold,\r\n        uint256 minTokensBought,\r\n        uint256 minEthBought,\r\n        uint256 deadline,\r\n        address tokenAddress\r\n    ) \r\n        public returns (uint256);\r\n\r\n    function tokenToTokenTransferInput(\r\n        uint256 tokensSold,\r\n        uint256 minTokensBought,\r\n        uint256 minEthBought,\r\n        uint256 deadline,\r\n        address recipient,\r\n        address tokenAddress\r\n    )\r\n        public returns (uint256);\r\n}\r\n"},"TokenController.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n  it under the terms of the GNU General Public License as published by\r\n  the Free Software Foundation, either version 3 of the License, or\r\n  (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n  along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\nimport \"./Iupgradable.sol\";\r\nimport \"./IERC1132.sol\";\r\nimport \"./NXMToken.sol\";\r\n\r\n\r\ncontract TokenController is IERC1132, Iupgradable {\r\n    using SafeMath for uint256;\r\n\r\n    event Burned(address indexed member, bytes32 lockedUnder, uint256 amount);\r\n\r\n    NXMToken public token;\r\n    \r\n    /**\r\n    * @dev Just for interface\r\n    */\r\n    function changeDependentContractAddress() public {\r\n        token = NXMToken(ms.tokenAddress());\r\n    }\r\n\r\n    /**\r\n     * @dev to change the operator address \r\n     * @param _newOperator is the new address of operator\r\n     */\r\n    function changeOperator(address _newOperator) public onlyInternal {\r\n        token.changeOperator(_newOperator);\r\n    }\r\n    \r\n    /**\r\n    * @dev Locks a specified amount of tokens,\r\n    *    for a specified reason and time\r\n    * @param _reason The reason to lock tokens\r\n    * @param _amount Number of tokens to be locked\r\n    * @param _time Lock time in seconds\r\n    */\r\n    function lock(bytes32 _reason, uint256 _amount, uint256 _time) public returns (bool)\r\n    {\r\n        // If tokens are already locked, then functions extendLock or\r\n        // increaseLockAmount should be used to make any changes\r\n        _lock(msg.sender, _reason, _amount, _time);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Locks a specified amount of tokens against an address,\r\n    *    for a specified reason and time\r\n    * @param _reason The reason to lock tokens\r\n    * @param _amount Number of tokens to be locked\r\n    * @param _time Lock time in seconds\r\n    * @param _of address whose tokens are to be locked\r\n    */\r\n    function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time)\r\n        public\r\n        onlyInternal\r\n        returns (bool)\r\n    {\r\n        // If tokens are already locked, then functions extendLock or\r\n        // increaseLockAmount should be used to make any changes\r\n        _lock(_of, _reason, _amount, _time);\r\n        return true;\r\n    }\r\n  \r\n    /**\r\n    * @dev Extends lock for a specified reason and time\r\n    * @param _reason The reason to lock tokens\r\n    * @param _time Lock extension time in seconds\r\n    */\r\n    function extendLock(bytes32 _reason, uint256 _time)\r\n        public\r\n        returns (bool)\r\n    {\r\n        _extendLock(msg.sender, _reason, _time);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Extends lock for a specified reason and time\r\n    * @param _reason The reason to lock tokens\r\n    * @param _time Lock extension time in seconds\r\n    */\r\n    function extendLockOf(address _of, bytes32 _reason, uint256 _time)\r\n        public\r\n        onlyInternal\r\n        returns (bool)\r\n    {\r\n        _extendLock(_of, _reason, _time);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev Increase number of tokens locked for a specified reason\r\n    * @param _reason The reason to lock tokens\r\n    * @param _amount Number of tokens to be increased\r\n    */\r\n    function increaseLockAmount(bytes32 _reason, uint256 _amount)\r\n        public\r\n        returns (bool)\r\n    {    \r\n        _increaseLockAmount(msg.sender, _reason, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev burns tokens of an address \r\n     * @param _of is the address to burn tokens of\r\n     * @param amount is the amount to burn\r\n     * @return the boolean status of the burning process\r\n     */\r\n    function burnFrom (address _of, uint amount) public onlyInternal returns (bool) {\r\n        return token.burnFrom(_of, amount);\r\n    }\r\n    \r\n    /**\r\n    * @dev Burns locked tokens of a user \r\n    * @param _of address whose tokens are to be burned\r\n    * @param _reason lock reason for which tokens are to be burned\r\n    * @param _amount amount of tokens to burn\r\n    */\r\n    function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) public onlyInternal {\r\n        _burnLockedTokens(_of, _reason, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev reduce lock duration for a specified reason and time\r\n    * @param _of The address whose tokens are locked\r\n    * @param _reason The reason to lock tokens\r\n    * @param _time Lock reduction time in seconds\r\n    */\r\n    function reduceLock(address _of, bytes32 _reason, uint256 _time) public onlyInternal {\r\n        _reduceLock(_of, _reason, _time);\r\n    } \r\n\r\n    /**\r\n    * @dev Released locked tokens of an address locked for a specific reason\r\n    * @param _of address whose tokens are to be released from lock\r\n    * @param _reason reason of the lock\r\n    * @param _amount amount of tokens to release\r\n    */\r\n    function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) \r\n        public \r\n        onlyInternal \r\n    {\r\n        _releaseLockedTokens(_of, _reason, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Adds an address to whitelist maintained in the contract\r\n    * @param _member address to add to whitelist\r\n    */\r\n    function addToWhitelist(address _member) public onlyInternal {\r\n        token.addToWhiteList(_member);\r\n    }\r\n\r\n    /**\r\n    * @dev Removes an address from the whitelist in the token\r\n    * @param _member address to remove\r\n    */\r\n    function removeFromWhitelist(address _member) public onlyInternal {\r\n        token.removeFromWhiteList(_member);\r\n    }\r\n\r\n    /**\r\n    * @dev Mints new token for an address\r\n    * @param _member address to reward the minted tokens\r\n    * @param _amount number of tokens to mint\r\n    */\r\n    function mint(address _member, uint _amount) public onlyInternal {\r\n        token.mint(_member, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Lock the user\u0027s tokens \r\n     * @param _of user\u0027s address.\r\n     */\r\n    function lockForMemberVote(address _of, uint _days) public onlyInternal {\r\n        token.lockForMemberVote(_of, _days);\r\n    }\r\n\r\n    /**\r\n    * @dev Unlocks the unlockable tokens of a specified address\r\n    * @param _of Address of user, claiming back unlockable tokens\r\n    */\r\n    function unlock(address _of)\r\n        public\r\n        returns (uint256 unlockableTokens)\r\n    {\r\n        uint256 lockedTokens;\r\n\r\n        for (uint256 i = 0; i \u003c lockReason[_of].length; i++) {\r\n            lockedTokens = _tokensUnlockable(_of, lockReason[_of][i]);\r\n            if (lockedTokens \u003e 0) {\r\n                unlockableTokens = unlockableTokens.add(lockedTokens);\r\n                locked[_of][lockReason[_of][i]].claimed = true;\r\n                emit Unlocked(_of, lockReason[_of][i], lockedTokens);\r\n            }\r\n        }  \r\n\r\n        if (unlockableTokens \u003e 0)\r\n            require(token.transfer(_of, unlockableTokens));\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the validity of locked tokens of a specified address\r\n    * @param _of The address to query the validity\r\n    * @param reason reason for which tokens were locked \r\n    */\r\n    function getLockedTokensValidity(address _of, bytes32 reason)\r\n        public\r\n        view\r\n        returns (uint256 validity)\r\n    {\r\n        validity = locked[_of][reason].validity;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the unlockable tokens of a specified address\r\n    * @param _of The address to query the the unlockable token count of\r\n    */\r\n    function getUnlockableTokens(address _of)\r\n        public\r\n        view\r\n        returns (uint256 unlockableTokens)\r\n    {\r\n        for (uint256 i = 0; i \u003c lockReason[_of].length; i++) {\r\n            unlockableTokens = unlockableTokens.add(_tokensUnlockable(_of, lockReason[_of][i]));\r\n        }  \r\n    }\r\n\r\n    /**\r\n    * @dev Returns tokens locked for a specified address for a\r\n    *    specified reason\r\n    *\r\n    * @param _of The address whose tokens are locked\r\n    * @param _reason The reason to query the lock tokens for\r\n    */\r\n    function tokensLocked(address _of, bytes32 _reason)\r\n        public\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        return _tokensLocked(_of, _reason);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns unlockable tokens for a specified address for a specified reason\r\n    * @param _of The address to query the the unlockable token count of\r\n    * @param _reason The reason to query the unlockable tokens for\r\n    */\r\n    function tokensUnlockable(address _of, bytes32 _reason)\r\n        public\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        return _tokensUnlockable(_of, _reason);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256)\r\n    {\r\n        return token.totalSupply();\r\n    }\r\n\r\n    /**\r\n    * @dev Returns tokens locked for a specified address for a\r\n    *    specified reason at a specific time\r\n    *\r\n    * @param _of The address whose tokens are locked\r\n    * @param _reason The reason to query the lock tokens for\r\n    * @param _time The timestamp to query the lock tokens for\r\n    */\r\n    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n        public\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        return _tokensLockedAtTime(_of, _reason, _time);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns total tokens held by an address (locked + transferable)\r\n    * @param _of The address to query the total balance of\r\n    */\r\n    function totalBalanceOf(address _of)\r\n        public\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        amount = token.balanceOf(_of);\r\n\r\n        for (uint256 i = 0; i \u003c lockReason[_of].length; i++) {\r\n            amount = amount.add(_tokensLocked(_of, lockReason[_of][i]));\r\n        }   \r\n    }\r\n\r\n    /**\r\n    * @dev Returns the total locked tokens at time\r\n    * @param _of member whose locked tokens are to be calculate\r\n    * @param _time timestamp when the tokens should be locked\r\n    */\r\n    function totalLockedBalance(address _of, uint256 _time) public view returns (uint256 amount) {\r\n        amount = _totalLockedBalance(_of, _time);\r\n    }  \r\n\r\n    /**\r\n    * @dev Internal function to returns the total locked tokens at time\r\n    * @param _of member whose locked tokens are to be calculate\r\n    * @param _time timestamp when the tokens should be locked\r\n    */\r\n    function _totalLockedBalance(address _of, uint256 _time) internal view returns (uint256 amount) {\r\n        for (uint256 i = 0; i \u003c lockReason[_of].length; i++) {\r\n            amount = amount.add(_tokensLockedAtTime(_of, lockReason[_of][i], _time));\r\n        }\r\n    } \r\n\r\n    /**\r\n    * @dev Locks a specified amount of tokens against an address,\r\n    *    for a specified reason and time\r\n    * @param _of address whose tokens are to be locked\r\n    * @param _reason The reason to lock tokens\r\n    * @param _amount Number of tokens to be locked\r\n    * @param _time Lock time in seconds\r\n    */\r\n    function _lock(address _of, bytes32 _reason, uint256 _amount, uint256 _time) internal {\r\n        require(_tokensLocked(_of, _reason) == 0);\r\n        require(_amount != 0);\r\n\r\n        if (locked[_of][_reason].amount == 0)\r\n            lockReason[_of].push(_reason);\r\n\r\n        require(token.operatorTransfer(_of, _amount));\r\n\r\n        uint256 validUntil = now.add(_time); //solhint-disable-line\r\n        locked[_of][_reason] = LockToken(_amount, validUntil, false);\r\n        emit Locked(_of, _reason, _amount, validUntil);\r\n    }\r\n    \r\n    /**\r\n    * @dev Returns tokens locked for a specified address for a\r\n    *    specified reason\r\n    *\r\n    * @param _of The address whose tokens are locked\r\n    * @param _reason The reason to query the lock tokens for\r\n    */\r\n    function _tokensLocked(address _of, bytes32 _reason)\r\n        internal\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        if (!locked[_of][_reason].claimed)\r\n            amount = locked[_of][_reason].amount;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns tokens locked for a specified address for a\r\n    *    specified reason at a specific time\r\n    *\r\n    * @param _of The address whose tokens are locked\r\n    * @param _reason The reason to query the lock tokens for\r\n    * @param _time The timestamp to query the lock tokens for\r\n    */\r\n    function _tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n        internal\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        if (locked[_of][_reason].validity \u003e _time)\r\n            amount = locked[_of][_reason].amount;\r\n    }\r\n    \r\n    /**\r\n    * @dev Extends lock for a specified reason and time\r\n    * @param _of The address whose tokens are locked\r\n    * @param _reason The reason to lock tokens\r\n    * @param _time Lock extension time in seconds\r\n    */\r\n    function _extendLock(address _of, bytes32 _reason, uint256 _time) internal {\r\n        require(_tokensLocked(_of, _reason) \u003e 0);\r\n        emit Unlocked(_of, _reason, locked[_of][_reason].amount);\r\n        locked[_of][_reason].validity = locked[_of][_reason].validity.add(_time);\r\n        emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\r\n    }\r\n\r\n    /**\r\n    * @dev reduce lock duration for a specified reason and time\r\n    * @param _of The address whose tokens are locked\r\n    * @param _reason The reason to lock tokens\r\n    * @param _time Lock reduction time in seconds\r\n    */\r\n    function _reduceLock(address _of, bytes32 _reason, uint256 _time) internal {\r\n        require(_tokensLocked(_of, _reason) \u003e 0);\r\n        emit Unlocked(_of, _reason, locked[_of][_reason].amount);\r\n        locked[_of][_reason].validity = locked[_of][_reason].validity.sub(_time);\r\n        emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\r\n    }\r\n    \r\n    /**\r\n    * @dev Increase number of tokens locked for a specified reason\r\n    * @param _of The address whose tokens are locked\r\n    * @param _reason The reason to lock tokens\r\n    * @param _amount Number of tokens to be increased\r\n    */\r\n    function _increaseLockAmount(address _of, bytes32 _reason, uint256 _amount) internal {\r\n        require(_tokensLocked(_of, _reason) \u003e 0);\r\n        token.operatorTransfer(msg.sender, _amount);\r\n\r\n        locked[_of][_reason].amount = locked[_of][_reason].amount.add(_amount);\r\n        emit Locked(_of, _reason, _amount, locked[_of][_reason].validity);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns unlockable tokens for a specified address for a specified reason\r\n    * @param _of The address to query the the unlockable token count of\r\n    * @param _reason The reason to query the unlockable tokens for\r\n    */\r\n    function _tokensUnlockable(address _of, bytes32 _reason) internal view returns (uint256 amount)\r\n    {\r\n      if (locked[_of][_reason].validity \u003c= now \u0026\u0026 !locked[_of][_reason].claimed) //solhint-disable-line\r\n            amount = locked[_of][_reason].amount;\r\n    }\r\n\r\n    /**\r\n    * @dev Burns locked tokens of a user \r\n    * @param _of address whose tokens are to be burned\r\n    * @param _reason lock reason for which tokens are to be burned\r\n    * @param _amount amount of tokens to burn\r\n    */\r\n    function _burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal {\r\n        uint256 amount = _tokensLocked(_of, _reason);\r\n        require(amount \u003e= _amount);\r\n        \r\n        if (amount == _amount)\r\n            locked[_of][_reason].claimed = true;\r\n        \r\n        locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\r\n        token.burn(_amount);\r\n        emit Burned(_of, _reason, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Released locked tokens of an address locked for a specific reason\r\n    * @param _of address whose tokens are to be released from lock\r\n    * @param _reason reason of the lock\r\n    * @param _amount amount of tokens to release\r\n    */\r\n    function _releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) \r\n        internal \r\n    {\r\n        uint256 amount = _tokensLocked(_of, _reason);\r\n        require(amount \u003e= _amount);\r\n\r\n        if (amount == _amount)\r\n            locked[_of][_reason].claimed = true;\r\n\r\n        locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\r\n        require(token.transfer(_of, _amount));\r\n        emit Unlocked(_of, _reason, _amount);\r\n    }\r\n}"},"TokenData.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n    \r\npragma solidity 0.5.7;\r\n\r\nimport \"./Iupgradable.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\n\r\ncontract TokenData is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    address payable public walletAddress;\r\n    uint public lockTokenTimeAfterCoverExp;\r\n    uint public bookTime;\r\n    uint public lockCADays;\r\n    uint public lockMVDays;\r\n    uint public scValidDays;\r\n    uint public joiningFee;\r\n    uint public stakerCommissionPer;\r\n    uint public stakerMaxCommissionPer;\r\n    uint public tokenExponent;\r\n    uint public priceStep;\r\n\r\n    struct StakeCommission {\r\n        uint commissionEarned;\r\n        uint commissionRedeemed;\r\n    }\r\n\r\n    struct Stake {\r\n        address stakedContractAddress;\r\n        uint stakedContractIndex;\r\n        uint dateAdd;\r\n        uint stakeAmount;\r\n        uint unlockedAmount;\r\n        uint burnedAmount;\r\n        uint unLockableBeforeLastBurn;\r\n    }\r\n\r\n    struct Staker {\r\n        address stakerAddress;\r\n        uint stakerIndex;\r\n    }\r\n\r\n    struct CoverNote {\r\n        uint amount;\r\n        bool isDeposited;\r\n    }\r\n\r\n    /**\r\n     * @dev mapping of uw address to array of sc address to fetch \r\n     * all staked contract address of underwriter, pushing\r\n     * data into this array of Stake returns stakerIndex \r\n     */ \r\n    mapping(address =\u003e Stake[]) public stakerStakedContracts; \r\n\r\n    /** \r\n     * @dev mapping of sc address to array of UW address to fetch\r\n     * all underwritters of the staked smart contract\r\n     * pushing data into this mapped array returns scIndex \r\n     */\r\n    mapping(address =\u003e Staker[]) public stakedContractStakers;\r\n\r\n    /**\r\n     * @dev mapping of staked contract Address to the array of StakeCommission\r\n     * here index of this array is stakedContractIndex\r\n     */ \r\n    mapping(address =\u003e mapping(uint =\u003e StakeCommission)) public stakedContractStakeCommission;\r\n\r\n    mapping(address =\u003e uint) public lastCompletedStakeCommission;\r\n\r\n    /** \r\n     * @dev mapping of the staked contract address to the current \r\n     * staker index who will receive commission.\r\n     */ \r\n    mapping(address =\u003e uint) public stakedContractCurrentCommissionIndex;\r\n\r\n    /** \r\n     * @dev mapping of the staked contract address to the \r\n     * current staker index to burn token from.\r\n     */ \r\n    mapping(address =\u003e uint) public stakedContractCurrentBurnIndex;\r\n\r\n    /** \r\n     * @dev mapping to return true if Cover Note deposited against coverId\r\n     */ \r\n    mapping(uint =\u003e CoverNote) public depositedCN;\r\n\r\n    mapping(address =\u003e uint) internal isBookedTokens;\r\n\r\n    event Commission(\r\n        address indexed stakedContractAddress,\r\n        address indexed stakerAddress,\r\n        uint indexed scIndex,\r\n        uint commissionAmount\r\n    );\r\n\r\n    constructor(address payable _walletAdd) public {\r\n        walletAddress = _walletAdd;\r\n        bookTime = 12 hours;\r\n        joiningFee = 2000000000000000; // 0.002 Ether\r\n        lockTokenTimeAfterCoverExp = 35 days;\r\n        scValidDays = 250;\r\n        lockCADays = 7 days;\r\n        lockMVDays = 2 days;\r\n        stakerCommissionPer = 20;\r\n        stakerMaxCommissionPer = 50;\r\n        tokenExponent = 4;\r\n        priceStep = 1000;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Change the wallet address which receive Joining Fee\r\n     */\r\n    function changeWalletAddress(address payable _address) external onlyInternal {\r\n        walletAddress = _address;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Uint Parameters of a code\r\n     * @param code whose details we want\r\n     * @return string value of the code\r\n     * @return associated amount (time or perc or value) to the code\r\n     */\r\n    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint val) {\r\n        codeVal = code;\r\n        if (code == \"TOKEXP\") {\r\n\r\n            val = tokenExponent; \r\n\r\n        } else if (code == \"TOKSTEP\") {\r\n\r\n            val = priceStep;\r\n\r\n        } else if (code == \"RALOCKT\") {\r\n\r\n            val = scValidDays;\r\n\r\n        } else if (code == \"RACOMM\") {\r\n\r\n            val = stakerCommissionPer;\r\n\r\n        } else if (code == \"RAMAXC\") {\r\n\r\n            val = stakerMaxCommissionPer;\r\n\r\n        } else if (code == \"CABOOKT\") {\r\n\r\n            val = bookTime / (1 hours);\r\n\r\n        } else if (code == \"CALOCKT\") {\r\n\r\n            val = lockCADays / (1 days);\r\n\r\n        } else if (code == \"MVLOCKT\") {\r\n\r\n            val = lockMVDays / (1 days);\r\n\r\n        } else if (code == \"QUOLOCKT\") {\r\n\r\n            val = lockTokenTimeAfterCoverExp / (1 days);\r\n\r\n        } else if (code == \"JOINFEE\") {\r\n\r\n            val = joiningFee;\r\n\r\n        } \r\n    }\r\n\r\n    /**\r\n    * @dev Just for interface\r\n    */\r\n    function changeDependentContractAddress() public { //solhint-disable-line\r\n    }\r\n    \r\n    /**\r\n     * @dev to get the contract staked by a staker \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return the address of staked contract\r\n     */\r\n    function getStakerStakedContractByIndex(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    ) \r\n        public\r\n        view\r\n        returns (address stakedContractAddress) \r\n    {\r\n        stakedContractAddress = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker\u0027s staked burned \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return amount burned\r\n     */\r\n    function getStakerStakedBurnedByIndex(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    ) \r\n        public\r\n        view\r\n        returns (uint burnedAmount) \r\n    {\r\n        burnedAmount = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].burnedAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker\u0027s staked unlockable before the last burn \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return unlockable staked tokens\r\n     */\r\n    function getStakerStakedUnlockableBeforeLastBurnByIndex(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    ) \r\n        public\r\n        view\r\n        returns (uint unlockable) \r\n    {\r\n        unlockable = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].unLockableBeforeLastBurn;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker\u0027s staked contract index \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return is the index of the smart contract address\r\n     */\r\n    function getStakerStakedContractIndex(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    ) \r\n        public\r\n        view\r\n        returns (uint scIndex) \r\n    {\r\n        scIndex = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker index of the staked contract\r\n     * @param _stakedContractAddress is the address of the staked contract\r\n     * @param _stakedContractIndex is the index of staked contract\r\n     * @return is the index of the staker\r\n     */\r\n    function getStakedContractStakerIndex(\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex\r\n    ) \r\n        public\r\n        view\r\n        returns (uint sIndex) \r\n    {\r\n        sIndex = stakedContractStakers[\r\n            _stakedContractAddress][_stakedContractIndex].stakerIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker\u0027s initial staked amount on the contract \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return staked amount\r\n     */\r\n    function getStakerInitialStakedAmountOnContract(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        public \r\n        view\r\n        returns (uint amount)\r\n    {\r\n        amount = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakeAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker\u0027s staked contract length \r\n     * @param _stakerAddress is the address of the staker\r\n     * @return length of staked contract\r\n     */\r\n    function getStakerStakedContractLength(\r\n        address _stakerAddress\r\n    ) \r\n        public\r\n        view\r\n        returns (uint length)\r\n    {\r\n        length = stakerStakedContracts[_stakerAddress].length;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker\u0027s unlocked tokens which were staked \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return amount\r\n     */\r\n    function getStakerUnlockedStakedTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        public \r\n        view\r\n        returns (uint amount)\r\n    {\r\n        amount = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].unlockedAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev pushes the unlocked staked tokens by a staker.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker to distribute commission.\r\n     * @param _amount amount to be given as commission.\r\n     */ \r\n    function pushUnlockedStakedTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {   \r\n        stakerStakedContracts[_stakerAddress][\r\n            _stakerIndex].unlockedAmount = stakerStakedContracts[_stakerAddress][\r\n                _stakerIndex].unlockedAmount.add(_amount);\r\n    }\r\n\r\n    /**\r\n     * @dev pushes the Burned tokens for a staker.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker.\r\n     * @param _amount amount to be burned.\r\n     */ \r\n    function pushBurnedTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {   \r\n        stakerStakedContracts[_stakerAddress][\r\n            _stakerIndex].burnedAmount = stakerStakedContracts[_stakerAddress][\r\n                _stakerIndex].burnedAmount.add(_amount);\r\n    }\r\n\r\n    /**\r\n     * @dev pushes the unLockable tokens for a staker before last burn.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker.\r\n     * @param _amount amount to be added to unlockable.\r\n     */ \r\n    function pushUnlockableBeforeLastBurnTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {   \r\n        stakerStakedContracts[_stakerAddress][\r\n            _stakerIndex].unLockableBeforeLastBurn = stakerStakedContracts[_stakerAddress][\r\n                _stakerIndex].unLockableBeforeLastBurn.add(_amount);\r\n    }\r\n\r\n    /**\r\n     * @dev sets the unLockable tokens for a staker before last burn.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker.\r\n     * @param _amount amount to be added to unlockable.\r\n     */ \r\n    function setUnlockableBeforeLastBurnTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {   \r\n        stakerStakedContracts[_stakerAddress][\r\n            _stakerIndex].unLockableBeforeLastBurn = _amount;\r\n    }\r\n\r\n    /**\r\n     * @dev pushes the earned commission earned by a staker.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakedContractAddress address of smart contract.\r\n     * @param _stakedContractIndex index of the staker to distribute commission.\r\n     * @param _commissionAmount amount to be given as commission.\r\n     */ \r\n    function pushEarnedStakeCommissions(\r\n        address _stakerAddress,\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex,\r\n        uint _commissionAmount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {\r\n        stakedContractStakeCommission[_stakedContractAddress][_stakedContractIndex].\r\n            commissionEarned = stakedContractStakeCommission[_stakedContractAddress][\r\n                _stakedContractIndex].commissionEarned.add(_commissionAmount);\r\n                \r\n        emit Commission(\r\n            _stakerAddress,\r\n            _stakedContractAddress,\r\n            _stakedContractIndex,\r\n            _commissionAmount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev pushes the redeemed commission redeemed by a staker.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker to distribute commission.\r\n     * @param _amount amount to be given as commission.\r\n     */ \r\n    function pushRedeemedStakeCommissions(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {   \r\n        uint stakedContractIndex = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractIndex;\r\n        address stakedContractAddress = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractAddress;\r\n        stakedContractStakeCommission[stakedContractAddress][stakedContractIndex].\r\n            commissionRedeemed = stakedContractStakeCommission[\r\n                stakedContractAddress][stakedContractIndex].commissionRedeemed.add(_amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets stake commission given to an underwriter\r\n     * for particular stakedcontract on given index.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker commission.\r\n     */ \r\n    function getStakerEarnedStakeCommission(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        public \r\n        view\r\n        returns (uint) \r\n    {\r\n        return _getStakerEarnedStakeCommission(_stakerAddress, _stakerIndex);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets stake commission redeemed by an underwriter\r\n     * for particular staked contract on given index.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker commission.\r\n     * @return commissionEarned total amount given to staker.\r\n     */ \r\n    function getStakerRedeemedStakeCommission(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        public \r\n        view\r\n        returns (uint) \r\n    {\r\n        return _getStakerRedeemedStakeCommission(_stakerAddress, _stakerIndex);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets total stake commission given to an underwriter\r\n     * @param _stakerAddress address of staker.\r\n     * @return totalCommissionEarned total commission earned by staker.\r\n     */ \r\n    function getStakerTotalEarnedStakeCommission(\r\n        address _stakerAddress\r\n    )\r\n        public \r\n        view\r\n        returns (uint totalCommissionEarned) \r\n    {\r\n        totalCommissionEarned = 0;\r\n        for (uint i = 0; i \u003c stakerStakedContracts[_stakerAddress].length; i++) {\r\n            totalCommissionEarned = totalCommissionEarned.\r\n                add(_getStakerEarnedStakeCommission(_stakerAddress, i));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets total stake commission given to an underwriter\r\n     * @param _stakerAddress address of staker.\r\n     * @return totalCommissionEarned total commission earned by staker.\r\n     */ \r\n    function getStakerTotalReedmedStakeCommission(\r\n        address _stakerAddress\r\n    )\r\n        public \r\n        view\r\n        returns(uint totalCommissionRedeemed) \r\n    {\r\n        totalCommissionRedeemed = 0;\r\n        for (uint i = 0; i \u003c stakerStakedContracts[_stakerAddress].length; i++) {\r\n            totalCommissionRedeemed = totalCommissionRedeemed.add(\r\n                _getStakerRedeemedStakeCommission(_stakerAddress, i));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev set flag to deposit/ undeposit cover note \r\n     * against a cover Id\r\n     * @param coverId coverId of Cover\r\n     * @param flag true/false for deposit/undeposit\r\n     */\r\n    function setDepositCN(uint coverId, bool flag) public onlyInternal {\r\n\r\n        if (flag == true) {\r\n            require(!depositedCN[coverId].isDeposited, \"Cover note already deposited\");    \r\n        }\r\n\r\n        depositedCN[coverId].isDeposited = flag;\r\n    }\r\n\r\n    /**\r\n     * @dev set locked cover note amount\r\n     * against a cover Id\r\n     * @param coverId coverId of Cover\r\n     * @param amount amount of nxm to be locked\r\n     */\r\n    function setDepositCNAmount(uint coverId, uint amount) public onlyInternal {\r\n\r\n        depositedCN[coverId].amount = amount;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker address on a staked contract \r\n     * @param _stakedContractAddress is the address of the staked contract in concern\r\n     * @param _stakedContractIndex is the index of staked contract\u0027s index\r\n     * @return address of staker\r\n     */\r\n    function getStakedContractStakerByIndex(\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex\r\n    )\r\n        public\r\n        view\r\n        returns (address stakerAddress)\r\n    {\r\n        stakerAddress = stakedContractStakers[\r\n            _stakedContractAddress][_stakedContractIndex].stakerAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the length of stakers on a staked contract \r\n     * @param _stakedContractAddress is the address of the staked contract in concern\r\n     * @return length in concern\r\n     */\r\n    function getStakedContractStakersLength(\r\n        address _stakedContractAddress\r\n    ) \r\n        public\r\n        view\r\n        returns (uint length)\r\n    {\r\n        length = stakedContractStakers[_stakedContractAddress].length;\r\n    } \r\n    \r\n    /**\r\n     * @dev Adds a new stake record.\r\n     * @param _stakerAddress staker address.\r\n     * @param _stakedContractAddress smart contract address.\r\n     * @param _amount amountof NXM to be staked.\r\n     */\r\n    function addStake(\r\n        address _stakerAddress,\r\n        address _stakedContractAddress,\r\n        uint _amount\r\n    ) \r\n        public\r\n        onlyInternal\r\n        returns(uint scIndex) \r\n    {\r\n        scIndex = (stakedContractStakers[_stakedContractAddress].push(\r\n            Staker(_stakerAddress, stakerStakedContracts[_stakerAddress].length))).sub(1);\r\n        stakerStakedContracts[_stakerAddress].push(\r\n            Stake(_stakedContractAddress, scIndex, now, _amount, 0, 0, 0));\r\n    }\r\n\r\n    /**\r\n     * @dev books the user\u0027s tokens for maintaining Assessor Velocity, \r\n     * i.e. once a token is used to cast a vote as a Claims assessor,\r\n     * @param _of user\u0027s address.\r\n     */\r\n    function bookCATokens(address _of) public onlyInternal {\r\n        require(!isCATokensBooked(_of), \"Tokens already booked\");\r\n        isBookedTokens[_of] = now.add(bookTime);\r\n    }\r\n\r\n    /**\r\n     * @dev to know if claim assessor\u0027s tokens are booked or not \r\n     * @param _of is the claim assessor\u0027s address in concern\r\n     * @return boolean representing the status of tokens booked\r\n     */\r\n    function isCATokensBooked(address _of) public view returns(bool res) {\r\n        if (now \u003c isBookedTokens[_of])\r\n            res = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the index which will receive commission.\r\n     * @param _stakedContractAddress smart contract address.\r\n     * @param _index current index.\r\n     */\r\n    function setStakedContractCurrentCommissionIndex(\r\n        address _stakedContractAddress,\r\n        uint _index\r\n    )\r\n        public\r\n        onlyInternal\r\n    {\r\n        stakedContractCurrentCommissionIndex[_stakedContractAddress] = _index;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the last complete commission index\r\n     * @param _stakerAddress smart contract address.\r\n     * @param _index current index.\r\n     */\r\n    function setLastCompletedStakeCommissionIndex(\r\n        address _stakerAddress,\r\n        uint _index\r\n    )\r\n        public\r\n        onlyInternal\r\n    {\r\n        lastCompletedStakeCommission[_stakerAddress] = _index;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the index till which commission is distrubuted.\r\n     * @param _stakedContractAddress smart contract address.\r\n     * @param _index current index.\r\n     */\r\n    function setStakedContractCurrentBurnIndex(\r\n        address _stakedContractAddress,\r\n        uint _index\r\n    )\r\n        public\r\n        onlyInternal\r\n    {\r\n        stakedContractCurrentBurnIndex[_stakedContractAddress] = _index;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates Uint Parameters of a code\r\n     * @param code whose details we want to update\r\n     * @param val value to set\r\n     */\r\n    function updateUintParameters(bytes8 code, uint val) public {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        if (code == \"TOKEXP\") {\r\n\r\n            _setTokenExponent(val); \r\n\r\n        } else if (code == \"TOKSTEP\") {\r\n\r\n            _setPriceStep(val);\r\n\r\n        } else if (code == \"RALOCKT\") {\r\n\r\n            _changeSCValidDays(val);\r\n\r\n        } else if (code == \"RACOMM\") {\r\n\r\n            _setStakerCommissionPer(val);\r\n\r\n        } else if (code == \"RAMAXC\") {\r\n\r\n            _setStakerMaxCommissionPer(val);\r\n\r\n        } else if (code == \"CABOOKT\") {\r\n\r\n            _changeBookTime(val * 1 hours);\r\n\r\n        } else if (code == \"CALOCKT\") {\r\n\r\n            _changelockCADays(val * 1 days);\r\n\r\n        } else if (code == \"MVLOCKT\") {\r\n\r\n            _changelockMVDays(val * 1 days);\r\n\r\n        } else if (code == \"QUOLOCKT\") {\r\n\r\n            _setLockTokenTimeAfterCoverExp(val * 1 days);\r\n\r\n        } else if (code == \"JOINFEE\") {\r\n\r\n            _setJoiningFee(val);\r\n\r\n        } else {\r\n            revert(\"Invalid param code\");\r\n        } \r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to get stake commission given to an \r\n     * underwriter for particular stakedcontract on given index.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker commission.\r\n     */ \r\n    function _getStakerEarnedStakeCommission(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        internal\r\n        view \r\n        returns (uint amount) \r\n    {\r\n        uint _stakedContractIndex;\r\n        address _stakedContractAddress;\r\n        _stakedContractAddress = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractAddress;\r\n        _stakedContractIndex = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractIndex;\r\n        amount = stakedContractStakeCommission[\r\n            _stakedContractAddress][_stakedContractIndex].commissionEarned;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to get stake commission redeemed by an \r\n     * underwriter for particular stakedcontract on given index.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker commission.\r\n     */ \r\n    function _getStakerRedeemedStakeCommission(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        internal\r\n        view \r\n        returns (uint amount) \r\n    {\r\n        uint _stakedContractIndex;\r\n        address _stakedContractAddress;\r\n        _stakedContractAddress = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractAddress;\r\n        _stakedContractIndex = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractIndex;\r\n        amount = stakedContractStakeCommission[\r\n            _stakedContractAddress][_stakedContractIndex].commissionRedeemed;\r\n    }\r\n\r\n    /**\r\n     * @dev to set the percentage of staker commission \r\n     * @param _val is new percentage value\r\n     */\r\n    function _setStakerCommissionPer(uint _val) internal {\r\n        stakerCommissionPer = _val;\r\n    }\r\n\r\n    /**\r\n     * @dev to set the max percentage of staker commission \r\n     * @param _val is new percentage value\r\n     */\r\n    function _setStakerMaxCommissionPer(uint _val) internal {\r\n        stakerMaxCommissionPer = _val;\r\n    }\r\n\r\n    /**\r\n     * @dev to set the token exponent value \r\n     * @param _val is new value\r\n     */\r\n    function _setTokenExponent(uint _val) internal {\r\n        tokenExponent = _val;\r\n    }\r\n\r\n    /**\r\n     * @dev to set the price step \r\n     * @param _val is new value\r\n     */\r\n    function _setPriceStep(uint _val) internal {\r\n        priceStep = _val;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes number of days for which NXM needs to staked in case of underwriting\r\n     */ \r\n    function _changeSCValidDays(uint _days) internal {\r\n        scValidDays = _days;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the time period up to which tokens will be locked.\r\n     *      Used to generate the validity period of tokens booked by\r\n     *      a user for participating in claim\u0027s assessment/claim\u0027s voting.\r\n     */ \r\n    function _changeBookTime(uint _time) internal {\r\n        bookTime = _time;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes lock CA days - number of days for which tokens \r\n     * are locked while submitting a vote.\r\n     */ \r\n    function _changelockCADays(uint _val) internal {\r\n        lockCADays = _val;\r\n    }\r\n    \r\n    /**\r\n     * @dev Changes lock MV days - number of days for which tokens are locked\r\n     * while submitting a vote.\r\n     */ \r\n    function _changelockMVDays(uint _val) internal {\r\n        lockMVDays = _val;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes extra lock period for a cover, post its expiry.\r\n     */ \r\n    function _setLockTokenTimeAfterCoverExp(uint time) internal {\r\n        lockTokenTimeAfterCoverExp = time;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the joining fee for membership\r\n     */\r\n    function _setJoiningFee(uint _amount) internal {\r\n        joiningFee = _amount;\r\n    }\r\n}"},"TokenFunctions.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\nimport \"./NXMToken.sol\";\r\nimport \"./Governance.sol\";\r\n\r\n\r\ncontract TokenFunctions is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    MCR internal m1;\r\n    MemberRoles internal mr;\r\n    NXMToken public tk;\r\n    TokenController internal tc;\r\n    TokenData internal td;\r\n    QuotationData internal qd;\r\n    ClaimsReward internal cr;\r\n    Governance internal gv;\r\n    PoolData internal pd;\r\n\r\n    uint private constant DECIMAL1E18 = uint(10) ** 18;\r\n\r\n    event BurnCATokens(uint claimId, address addr, uint amount);\r\n    \r\n    /**\r\n     * @dev Sends commission to underwriter on purchase of staked smart contract.\r\n     * @param _scAddress staker address.\r\n     * @param _premiumNXM premium of cover in NXM.\r\n     */\r\n    function updateStakerCommissions(address _scAddress, uint _premiumNXM) external onlyInternal {\r\n        uint commissionToBePaid = (_premiumNXM.mul(td.stakerCommissionPer())).div(100);\r\n        uint stakeLength = td.getStakedContractStakersLength(_scAddress);\r\n        address claimsRewardAddress = ms.getLatestAddress(\"CR\");\r\n        for (uint i = td.stakedContractCurrentCommissionIndex(_scAddress); i \u003c stakeLength; i++) {\r\n            if (commissionToBePaid \u003e 0) {\r\n                address stakerAddress;\r\n                uint stakeAmt;\r\n                uint stakerIndex;\r\n                (stakerAddress, ) = td.stakedContractStakers(_scAddress, i);\r\n                stakerIndex = td.getStakedContractStakerIndex(_scAddress, i);\r\n                stakeAmt = td.getStakerInitialStakedAmountOnContract(stakerAddress, stakerIndex);\r\n                uint maxCommission = (stakeAmt.mul(td.stakerMaxCommissionPer())).div(100);\r\n                uint commissionEarned;\r\n                commissionEarned = td.getStakerEarnedStakeCommission(stakerAddress, stakerIndex);\r\n                if (maxCommission \u003e commissionEarned) {\r\n                    if (maxCommission \u003e= commissionEarned.add(commissionToBePaid)) {\r\n                        td.pushEarnedStakeCommissions(stakerAddress, _scAddress, \r\n                            i, commissionToBePaid);\r\n                        tc.mint(claimsRewardAddress, commissionToBePaid);\r\n                        if (i \u003e 0)\r\n                            td.setStakedContractCurrentCommissionIndex(_scAddress, i);\r\n                        commissionToBePaid = 0;\r\n                        break;\r\n                    } else {\r\n                        td.pushEarnedStakeCommissions(stakerAddress, _scAddress, i,\r\n                            maxCommission.sub(commissionEarned));\r\n                        tc.mint(claimsRewardAddress, maxCommission.sub(commissionEarned));\r\n                        commissionToBePaid = commissionToBePaid.sub(maxCommission.sub(commissionEarned));\r\n                    }\r\n                }\r\n            } else\r\n                break;\r\n        }\r\n        if (commissionToBePaid \u003e 0 \u0026\u0026 stakeLength \u003e 0)\r\n            td.setStakedContractCurrentCommissionIndex(_scAddress, stakeLength.sub(1));\r\n    }\r\n\r\n     /**\r\n     * @dev Burns tokens staked against a Smart Contract Cover.\r\n     * Called when a claim submitted against this cover is accepted.\r\n     * @param coverid Cover Id.\r\n     */\r\n    function burnStakerLockedToken(uint coverid, bytes4 curr, uint sumAssured) external onlyInternal {\r\n        address scAddress;\r\n        (, scAddress) = qd.getscAddressOfCover(coverid);\r\n        uint tokenPrice = m1.calculateTokenPrice(curr);\r\n        uint totalStaker = td.getStakedContractStakersLength(scAddress);\r\n        uint burnNXMAmount = sumAssured.mul(DECIMAL1E18).div(tokenPrice);\r\n        address stakerAddress;\r\n        uint stakerStakedNXM;\r\n        for (uint i = td.stakedContractCurrentBurnIndex(scAddress); i \u003c totalStaker; i++) {\r\n            if (burnNXMAmount \u003e 0) {\r\n                stakerAddress = td.getStakedContractStakerByIndex(scAddress, i);\r\n                uint stakerIndex = td.getStakedContractStakerIndex(\r\n                scAddress, i);\r\n                uint v;\r\n                (v, stakerStakedNXM) = _unlockableBeforeBurningAndCanBurn(stakerAddress, scAddress, stakerIndex);\r\n                td.pushUnlockableBeforeLastBurnTokens(stakerAddress, stakerIndex, v);\r\n                if (stakerStakedNXM \u003e 0) {\r\n                    if (stakerStakedNXM \u003e= burnNXMAmount) {\r\n                        _burnStakerTokenLockedAgainstSmartContract(\r\n                            stakerAddress, scAddress, i, burnNXMAmount);\r\n                        if (i \u003e 0)\r\n                            td.setStakedContractCurrentBurnIndex(scAddress, i);\r\n                        burnNXMAmount = 0;\r\n                        break;\r\n                    } else {\r\n                        _burnStakerTokenLockedAgainstSmartContract(\r\n                            stakerAddress, scAddress, i, stakerStakedNXM);\r\n                        burnNXMAmount = burnNXMAmount.sub(stakerStakedNXM);\r\n                    }\r\n                }\r\n            } else\r\n                break;\r\n        }\r\n        if (burnNXMAmount \u003e 0 \u0026\u0026 totalStaker \u003e 0)\r\n            td.setStakedContractCurrentBurnIndex(scAddress, totalStaker.sub(1));\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total staked NXM tokens against\r\n     * Smart contract by all stakers\r\n     * @param _stakedContractAddress smart contract address.\r\n     * @return amount total staked NXM tokens.\r\n     */\r\n    function getTotalStakedTokensOnSmartContract(\r\n        address _stakedContractAddress\r\n    )\r\n        external\r\n        view\r\n        returns(uint amount)\r\n    {\r\n        uint stakedAmount = 0;\r\n        address stakerAddress;\r\n        uint staketLen = td.getStakedContractStakersLength(_stakedContractAddress);\r\n        for (uint i = 0; i \u003c staketLen; i++) {\r\n            stakerAddress = td.getStakedContractStakerByIndex(_stakedContractAddress, i);\r\n            uint stakerIndex = td.getStakedContractStakerIndex(\r\n            _stakedContractAddress, i);\r\n            uint currentlyStaked;\r\n            (, currentlyStaked) = _unlockableBeforeBurningAndCanBurn(stakerAddress, \r\n            _stakedContractAddress, stakerIndex);\r\n            stakedAmount = stakedAmount.add(currentlyStaked);\r\n        } \r\n        amount = stakedAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\r\n     * @param _of address of the coverHolder.\r\n     * @param _coverId coverId of the cover.\r\n     */\r\n    function getUserLockedCNTokens(address _of, uint _coverId) external view returns(uint) {\r\n        return _getUserLockedCNTokens(_of, _coverId);\r\n    } \r\n\r\n    /**\r\n     * @dev to get the all the cover locked tokens of a user \r\n     * @param _of is the user address in concern\r\n     * @return amount locked\r\n     */\r\n    function getUserAllLockedCNTokens(address _of) external view returns(uint amount) {\r\n        for (uint i = 0; i \u003c qd.getUserCoverLength(_of); i++) {\r\n            amount = amount.add(_getUserLockedCNTokens(_of, qd.getAllCoversOfUser(_of)[i]));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns amount of NXM Tokens locked as Cover Note against given coverId.\r\n     * @param _coverId coverId of the cover.\r\n     */\r\n    function getLockedCNAgainstCover(uint _coverId) external view returns(uint) {\r\n        return _getLockedCNAgainstCover(_coverId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns total amount of staked NXM Tokens on all smart contract .\r\n     * @param _stakerAddress address of the Staker.\r\n     */ \r\n    function getStakerAllLockedTokens(address _stakerAddress) external view returns (uint amount) {\r\n        uint stakedAmount = 0;\r\n        address scAddress;\r\n        uint scIndex;\r\n        for (uint i = 0; i \u003c td.getStakerStakedContractLength(_stakerAddress); i++) {\r\n            scAddress = td.getStakerStakedContractByIndex(_stakerAddress, i);\r\n            scIndex = td.getStakerStakedContractIndex(_stakerAddress, i);\r\n            uint currentlyStaked;\r\n            (, currentlyStaked) = _unlockableBeforeBurningAndCanBurn(_stakerAddress, scAddress, i);\r\n            stakedAmount = stakedAmount.add(currentlyStaked);\r\n        }\r\n        amount = stakedAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns total unlockable amount of staked NXM Tokens on all smart contract .\r\n     * @param _stakerAddress address of the Staker.\r\n     */ \r\n    function getStakerAllUnlockableStakedTokens(\r\n        address _stakerAddress\r\n    )\r\n        external\r\n        view\r\n        returns (uint amount)\r\n    {\r\n        uint unlockableAmount = 0;\r\n        address scAddress;\r\n        uint scIndex;\r\n        for (uint i = 0; i \u003c td.getStakerStakedContractLength(_stakerAddress); i++) {\r\n            scAddress = td.getStakerStakedContractByIndex(_stakerAddress, i);\r\n            scIndex = td.getStakerStakedContractIndex(_stakerAddress, i);\r\n            unlockableAmount = unlockableAmount.add(\r\n            _getStakerUnlockableTokensOnSmartContract(_stakerAddress, scAddress,\r\n            scIndex));\r\n        }\r\n        amount = unlockableAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Change Dependent Contract Address\r\n     */\r\n    function changeDependentContractAddress() public {\r\n        tk = NXMToken(ms.tokenAddress());\r\n        td = TokenData(ms.getLatestAddress(\"TD\"));\r\n        tc = TokenController(ms.getLatestAddress(\"TC\"));\r\n        cr = ClaimsReward(ms.getLatestAddress(\"CR\"));\r\n        qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n        m1 = MCR(ms.getLatestAddress(\"MC\"));\r\n        gv = Governance(ms.getLatestAddress(\"GV\"));\r\n        mr = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n        pd = PoolData(ms.getLatestAddress(\"PD\"));\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Token price in a given currency\r\n     * @param curr Currency name.\r\n     * @return price Token Price.\r\n     */\r\n    function getTokenPrice(bytes4 curr) public view returns(uint price) {\r\n        price = m1.calculateTokenPrice(curr);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the flag to check if cover note is deposited against the cover id\r\n     * @param coverId Cover Id.\r\n     */ \r\n    function depositCN(uint coverId) public onlyInternal returns (bool success) {\r\n        require(_getLockedCNAgainstCover(coverId) \u003e 0, \"No cover note available\");\r\n        td.setDepositCN(coverId, true);\r\n        success = true;    \r\n    }\r\n\r\n    /**\r\n     * @param _of address of Member\r\n     * @param _coverId Cover Id\r\n     * @param _lockTime Pending Time + Cover Period 7*1 days\r\n     */ \r\n    function extendCNEPOff(address _of, uint _coverId, uint _lockTime) public onlyInternal {\r\n        uint timeStamp = now.add(_lockTime);\r\n        uint coverValidUntil = qd.getValidityOfCover(_coverId);\r\n        if (timeStamp \u003e= coverValidUntil) {\r\n            bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, _coverId));\r\n            tc.extendLockOf(_of, reason, timeStamp);\r\n        } \r\n    }\r\n\r\n    /**\r\n     * @dev to burn the deposited cover tokens \r\n     * @param coverId is id of cover whose tokens have to be burned\r\n     * @return the status of the successful burning\r\n     */\r\n    function burnDepositCN(uint coverId) public onlyInternal returns (bool success) {\r\n        address _of = qd.getCoverMemberAddress(coverId);\r\n        uint amount;\r\n        (amount, ) = td.depositedCN(coverId);\r\n        amount = (amount.mul(50)).div(100);\r\n        bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, coverId));\r\n        tc.burnLockedTokens(_of, reason, amount);\r\n        success = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Unlocks covernote locked against a given cover \r\n     * @param coverId id of cover\r\n     */ \r\n    function unlockCN(uint coverId) public onlyInternal {\r\n        address _of = qd.getCoverMemberAddress(coverId);\r\n        uint lockedCN = _getLockedCNAgainstCover(coverId);\r\n        if (lockedCN != 0) {\r\n            bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, coverId));\r\n            tc.releaseLockedTokens(_of, reason, lockedCN);\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev Burns tokens used for fraudulent voting against a claim\r\n     * @param claimid Claim Id.\r\n     * @param _value number of tokens to be burned\r\n     * @param _of Claim Assessor\u0027s address.\r\n     */     \r\n    function burnCAToken(uint claimid, uint _value, address _of) public {\r\n\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        tc.burnLockedTokens(_of, \"CLA\", _value);\r\n        emit BurnCATokens(claimid, _of, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev to lock cover note tokens\r\n     * @param coverNoteAmount is number of tokens to be locked\r\n     * @param coverPeriod is cover period in concern\r\n     * @param coverId is the cover id of cover in concern\r\n     * @param _of address whose tokens are to be locked\r\n     */\r\n    function lockCN(\r\n        uint coverNoteAmount,\r\n        uint coverPeriod,\r\n        uint coverId,\r\n        address _of\r\n    )\r\n        public\r\n        onlyInternal\r\n    {\r\n        uint validity = now.add(coverPeriod * 1 days).add(td.lockTokenTimeAfterCoverExp());\r\n        bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, coverId));\r\n        td.setDepositCNAmount(coverId, coverNoteAmount);\r\n        tc.lockOf(_of, reason, coverNoteAmount, validity);\r\n    }\r\n\r\n    /**\r\n     * @dev Staking on contract.\r\n     * @param _scAddress smart contract address.\r\n     * @param _amount amount of NXM.\r\n     */ \r\n    function addStake(address _scAddress, uint _amount) public isMemberAndcheckPause {\r\n        uint scIndex = td.addStake(msg.sender, _scAddress, _amount);\r\n        uint validity = (td.scValidDays()).mul(1 days);\r\n        bytes32 reason = keccak256(abi.encodePacked(\"UW\", msg.sender, _scAddress, scIndex));\r\n        tc.lockOf(msg.sender, reason, _amount, validity);\r\n    }\r\n\r\n    /**\r\n     * @dev to check if a  member is locked for member vote \r\n     * @param _of is the member address in concern\r\n     * @return the boolean status\r\n     */\r\n    function isLockedForMemberVote(address _of) public view returns(bool) {\r\n        return now \u003c tk.isLockedForMV(_of);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to gets amount of locked NXM tokens,\r\n     * staked against smartcontract by index\r\n     * @param _stakerAddress address of user\r\n     * @param _stakedContractAddress staked contract address\r\n     * @param _stakedContractIndex index of staking\r\n     */\r\n    function getStakerLockedTokensOnSmartContract (\r\n        address _stakerAddress,\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex\r\n    )\r\n        public\r\n        view\r\n        returns\r\n        (uint amount)\r\n    {   \r\n        amount = _getStakerLockedTokensOnSmartContract(_stakerAddress,\r\n            _stakedContractAddress, _stakedContractIndex);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to gets unlockable amount of locked NXM \r\n     * tokens, staked against smartcontract by index\r\n     * @param stakerAddress address of staker\r\n     * @param stakedContractAddress staked contract address\r\n     * @param stakerIndex index of staking\r\n     */\r\n    function getStakerUnlockableTokensOnSmartContract (\r\n        address stakerAddress,\r\n        address stakedContractAddress,\r\n        uint stakerIndex\r\n    ) \r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return _getStakerUnlockableTokensOnSmartContract(stakerAddress, stakedContractAddress,\r\n        td.getStakerStakedContractIndex(stakerAddress, stakerIndex));\r\n    }\r\n\r\n    /**\r\n     * @dev releases unlockable staked tokens to staker \r\n     */\r\n    function unlockStakerUnlockableTokens(address _stakerAddress) public onlyInternal {\r\n        uint unlockableAmount;\r\n        address scAddress;\r\n        bytes32 reason;\r\n        uint scIndex;\r\n        for (uint i = 0; i \u003c td.getStakerStakedContractLength(_stakerAddress); i++) {\r\n            scAddress = td.getStakerStakedContractByIndex(_stakerAddress, i);\r\n            scIndex = td.getStakerStakedContractIndex(_stakerAddress, i);\r\n            unlockableAmount = _getStakerUnlockableTokensOnSmartContract(\r\n            _stakerAddress, scAddress,\r\n            scIndex);\r\n            td.setUnlockableBeforeLastBurnTokens(_stakerAddress, i, 0);\r\n            td.pushUnlockedStakedTokens(_stakerAddress, i, unlockableAmount);\r\n            reason = keccak256(abi.encodePacked(\"UW\", _stakerAddress, scAddress, scIndex));\r\n            tc.releaseLockedTokens(_stakerAddress, reason, unlockableAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to get tokens of staker locked before burning that are allowed to burn \r\n     * @param stakerAdd is the address of the staker \r\n     * @param stakedAdd is the address of staked contract in concern \r\n     * @param stakerIndex is the staker index in concern\r\n     * @return amount of unlockable tokens\r\n     * @return amount of tokens that can burn\r\n     */\r\n    function _unlockableBeforeBurningAndCanBurn(\r\n        address stakerAdd, \r\n        address stakedAdd, \r\n        uint stakerIndex\r\n    )\r\n    internal \r\n    view \r\n    returns\r\n    (uint amount, uint canBurn) {\r\n\r\n        uint dateAdd;\r\n        uint initialStake;\r\n        uint totalBurnt;\r\n        uint ub;\r\n        (, , dateAdd, initialStake, , totalBurnt, ub) = td.stakerStakedContracts(stakerAdd, stakerIndex);\r\n        canBurn = _calculateStakedTokens(initialStake, (now.sub(dateAdd)).div(1 days), td.scValidDays());\r\n        // Can\u0027t use SafeMaths for int.\r\n        int v = int(initialStake - (canBurn) - (totalBurnt) - (\r\n            td.getStakerUnlockedStakedTokens(stakerAdd, stakerIndex)) - (ub));\r\n        uint currentLockedTokens = _getStakerLockedTokensOnSmartContract(\r\n            stakerAdd, stakedAdd, td.getStakerStakedContractIndex(stakerAdd, stakerIndex));\r\n        if (v \u003c 0)\r\n            v = 0;\r\n        amount = uint(v);\r\n        if (canBurn \u003e currentLockedTokens.sub(amount).sub(ub))\r\n            canBurn = currentLockedTokens.sub(amount).sub(ub);\r\n    }\r\n\r\n    /**\r\n     * @dev to get tokens of staker that are unlockable\r\n     * @param _stakerAddress is the address of the staker \r\n     * @param _stakedContractAddress is the address of staked contract in concern \r\n     * @param _stakedContractIndex is the staked contract index in concern\r\n     * @return amount of unlockable tokens\r\n     */\r\n    function _getStakerUnlockableTokensOnSmartContract (\r\n        address _stakerAddress,\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex\r\n    ) \r\n        internal\r\n        view\r\n        returns\r\n        (uint amount)\r\n    {   \r\n        uint initialStake;\r\n        uint stakerIndex = td.getStakedContractStakerIndex(\r\n            _stakedContractAddress, _stakedContractIndex);\r\n        uint burnt;\r\n        (, , , initialStake, , burnt,) = td.stakerStakedContracts(_stakerAddress, stakerIndex);\r\n        uint alreadyUnlocked = td.getStakerUnlockedStakedTokens(_stakerAddress, stakerIndex);\r\n        uint currentStakedTokens;\r\n        (, currentStakedTokens) = _unlockableBeforeBurningAndCanBurn(_stakerAddress, \r\n            _stakedContractAddress, stakerIndex);\r\n        amount = initialStake.sub(currentStakedTokens).sub(alreadyUnlocked).sub(burnt);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to get the amount of locked NXM tokens,\r\n     * staked against smartcontract by index\r\n     * @param _stakerAddress address of user\r\n     * @param _stakedContractAddress staked contract address\r\n     * @param _stakedContractIndex index of staking\r\n     */\r\n    function _getStakerLockedTokensOnSmartContract (\r\n        address _stakerAddress,\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex\r\n    )\r\n        internal\r\n        view\r\n        returns\r\n        (uint amount)\r\n    {   \r\n        bytes32 reason = keccak256(abi.encodePacked(\"UW\", _stakerAddress,\r\n            _stakedContractAddress, _stakedContractIndex));\r\n        amount = tc.tokensLocked(_stakerAddress, reason);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\r\n     * @param _coverId coverId of the cover.\r\n     */\r\n    function _getLockedCNAgainstCover(uint _coverId) internal view returns(uint) {\r\n        address coverHolder = qd.getCoverMemberAddress(_coverId);\r\n        bytes32 reason = keccak256(abi.encodePacked(\"CN\", coverHolder, _coverId));\r\n        return tc.tokensLockedAtTime(coverHolder, reason, now); \r\n    }\r\n\r\n    /**\r\n     * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\r\n     * @param _of address of the coverHolder.\r\n     * @param _coverId coverId of the cover.\r\n     */\r\n    function _getUserLockedCNTokens(address _of, uint _coverId) internal view returns(uint) {\r\n        bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, _coverId));\r\n        return tc.tokensLockedAtTime(_of, reason, now); \r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to gets remaining amount of staked NXM tokens,\r\n     * against smartcontract by index\r\n     * @param _stakeAmount address of user\r\n     * @param _stakeDays staked contract address\r\n     * @param _validDays index of staking\r\n     */\r\n    function _calculateStakedTokens(\r\n        uint _stakeAmount,\r\n        uint _stakeDays,\r\n        uint _validDays\r\n    ) \r\n        internal\r\n        pure \r\n        returns (uint amount)\r\n    {\r\n        if (_validDays \u003e _stakeDays) {\r\n            uint rf = ((_validDays.sub(_stakeDays)).mul(100000)).div(_validDays);\r\n            amount = (rf.mul(_stakeAmount)).div(100000);\r\n        } else \r\n            amount = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total staked NXM tokens against Smart contract \r\n     * by all stakers\r\n     * @param _stakedContractAddress smart contract address.\r\n     * @return amount total staked NXM tokens.\r\n     */\r\n    function _burnStakerTokenLockedAgainstSmartContract(\r\n        address _stakerAddress,\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex,\r\n        uint _amount\r\n    ) \r\n        internal\r\n    {\r\n        uint stakerIndex = td.getStakedContractStakerIndex(\r\n            _stakedContractAddress, _stakedContractIndex);\r\n        td.pushBurnedTokens(_stakerAddress, stakerIndex, _amount);\r\n        bytes32 reason = keccak256(abi.encodePacked(\"UW\", _stakerAddress,\r\n            _stakedContractAddress, _stakedContractIndex));\r\n        tc.burnLockedTokens(_stakerAddress, reason, _amount);\r\n    }\r\n\r\n}"},"usingOraclize.sol":{"content":"/*\r\n\r\nORACLIZE_API\r\n\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n\r\n*/\r\npragma solidity \u003e= 0.5.0 \u003c 0.6.0; // Incompatible compiler version - please select a compiler within the stated pragma range, or use a different version of the oraclizeAPI!\r\n\r\n// Dummy contract only used to emit to end-user they are using wrong solc\r\ncontract solcChecker {\r\n/* INCOMPATIBLE SOLC: import the following instead: \"github.com/oraclize/ethereum-api/oraclizeAPI_0.4.sol\" */ function f(bytes calldata x) external;\r\n}\r\n\r\ncontract OraclizeI {\r\n\r\n    address public cbAddress;\r\n\r\n    function setProofType(byte _proofType) external;\r\n    function setCustomGasPrice(uint _gasPrice) external;\r\n    function getPrice(string memory _datasource) public returns (uint _dsprice);\r\n    function randomDS_getSessionPubKeyHash() external view returns (bytes32 _sessionKeyHash);\r\n    function getPrice(string memory _datasource, uint _gasLimit) public returns (uint _dsprice);\r\n    function queryN(uint _timestamp, string memory _datasource, bytes memory _argN) public payable returns (bytes32 _id);\r\n    function query(uint _timestamp, string calldata _datasource, string calldata _arg) external payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string memory _datasource, string memory _arg1, string memory _arg2) public payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string calldata _datasource, string calldata _arg, uint _gasLimit) external payable returns (bytes32 _id);\r\n    function queryN_withGasLimit(uint _timestamp, string calldata _datasource, bytes calldata _argN, uint _gasLimit) external payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string calldata _datasource, string calldata _arg1, string calldata _arg2, uint _gasLimit) external payable returns (bytes32 _id);\r\n}\r\n\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() public returns (address _address);\r\n}\r\n/*\r\n\r\nBegin solidity-cborutils\r\n\r\nhttps://github.com/smartcontractkit/solidity-cborutils\r\n\r\nMIT License\r\n\r\nCopyright (c) 2018 SmartContract ChainLink, Ltd.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n\r\n*/\r\nlibrary Buffer {\r\n\r\n    struct buffer {\r\n        bytes buf;\r\n        uint capacity;\r\n    }\r\n\r\n    function init(buffer memory _buf, uint _capacity) internal pure {\r\n        uint capacity = _capacity;\r\n        if (capacity % 32 != 0) {\r\n            capacity += 32 - (capacity % 32);\r\n        }\r\n        _buf.capacity = capacity; // Allocate space for the buffer data\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(_buf, ptr)\r\n            mstore(ptr, 0)\r\n            mstore(0x40, add(ptr, capacity))\r\n        }\r\n    }\r\n\r\n    function resize(buffer memory _buf, uint _capacity) private pure {\r\n        bytes memory oldbuf = _buf.buf;\r\n        init(_buf, _capacity);\r\n        append(_buf, oldbuf);\r\n    }\r\n\r\n    function max(uint _a, uint _b) private pure returns (uint _max) {\r\n        if (_a \u003e _b) {\r\n            return _a;\r\n        }\r\n        return _b;\r\n    }\r\n    /**\r\n      * @dev Appends a byte array to the end of the buffer. Resizes if doing so\r\n      *      would exceed the capacity of the buffer.\r\n      * @param _buf The buffer to append to.\r\n      * @param _data The data to append.\r\n      * @return The original buffer.\r\n      *\r\n      */\r\n    function append(buffer memory _buf, bytes memory _data) internal pure returns (buffer memory _buffer) {\r\n        if (_data.length + _buf.buf.length \u003e _buf.capacity) {\r\n            resize(_buf, max(_buf.capacity, _data.length) * 2);\r\n        }\r\n        uint dest;\r\n        uint src;\r\n        uint len = _data.length;\r\n        assembly {\r\n            let bufptr := mload(_buf) // Memory address of the buffer data\r\n            let buflen := mload(bufptr) // Length of existing buffer data\r\n            dest := add(add(bufptr, buflen), 32) // Start address = buffer address + buffer length + sizeof(buffer length)\r\n            mstore(bufptr, add(buflen, mload(_data))) // Update buffer length\r\n            src := add(_data, 32)\r\n        }\r\n        for(; len \u003e= 32; len -= 32) { // Copy word-length chunks while possible\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n        uint mask = 256 ** (32 - len) - 1; // Copy remaining bytes\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n        return _buf;\r\n    }\r\n    /**\r\n      *\r\n      * @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n      * exceed the capacity of the buffer.\r\n      * @param _buf The buffer to append to.\r\n      * @param _data The data to append.\r\n      * @return The original buffer.\r\n      *\r\n      */\r\n    function append(buffer memory _buf, uint8 _data) internal pure {\r\n        if (_buf.buf.length + 1 \u003e _buf.capacity) {\r\n            resize(_buf, _buf.capacity * 2);\r\n        }\r\n        assembly {\r\n            let bufptr := mload(_buf) // Memory address of the buffer data\r\n            let buflen := mload(bufptr) // Length of existing buffer data\r\n            let dest := add(add(bufptr, buflen), 32) // Address = buffer address + buffer length + sizeof(buffer length)\r\n            mstore8(dest, _data)\r\n            mstore(bufptr, add(buflen, 1)) // Update buffer length\r\n        }\r\n    }\r\n    /**\r\n      *\r\n      * @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n      * exceed the capacity of the buffer.\r\n      * @param _buf The buffer to append to.\r\n      * @param _data The data to append.\r\n      * @return The original buffer.\r\n      *\r\n      */\r\n    function appendInt(buffer memory _buf, uint _data, uint _len) internal pure returns (buffer memory _buffer) {\r\n        if (_len + _buf.buf.length \u003e _buf.capacity) {\r\n            resize(_buf, max(_buf.capacity, _len) * 2);\r\n        }\r\n        uint mask = 256 ** _len - 1;\r\n        assembly {\r\n            let bufptr := mload(_buf) // Memory address of the buffer data\r\n            let buflen := mload(bufptr) // Length of existing buffer data\r\n            let dest := add(add(bufptr, buflen), _len) // Address = buffer address + buffer length + sizeof(buffer length) + len\r\n            mstore(dest, or(and(mload(dest), not(mask)), _data))\r\n            mstore(bufptr, add(buflen, _len)) // Update buffer length\r\n        }\r\n        return _buf;\r\n    }\r\n}\r\n\r\nlibrary CBOR {\r\n\r\n    using Buffer for Buffer.buffer;\r\n\r\n    uint8 private constant MAJOR_TYPE_INT = 0;\r\n    uint8 private constant MAJOR_TYPE_MAP = 5;\r\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\r\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\r\n    uint8 private constant MAJOR_TYPE_STRING = 3;\r\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\r\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\r\n\r\n    function encodeType(Buffer.buffer memory _buf, uint8 _major, uint _value) private pure {\r\n        if (_value \u003c= 23) {\r\n            _buf.append(uint8((_major \u003c\u003c 5) | _value));\r\n        } else if (_value \u003c= 0xFF) {\r\n            _buf.append(uint8((_major \u003c\u003c 5) | 24));\r\n            _buf.appendInt(_value, 1);\r\n        } else if (_value \u003c= 0xFFFF) {\r\n            _buf.append(uint8((_major \u003c\u003c 5) | 25));\r\n            _buf.appendInt(_value, 2);\r\n        } else if (_value \u003c= 0xFFFFFFFF) {\r\n            _buf.append(uint8((_major \u003c\u003c 5) | 26));\r\n            _buf.appendInt(_value, 4);\r\n        } else if (_value \u003c= 0xFFFFFFFFFFFFFFFF) {\r\n            _buf.append(uint8((_major \u003c\u003c 5) | 27));\r\n            _buf.appendInt(_value, 8);\r\n        }\r\n    }\r\n\r\n    function encodeIndefiniteLengthType(Buffer.buffer memory _buf, uint8 _major) private pure {\r\n        _buf.append(uint8((_major \u003c\u003c 5) | 31));\r\n    }\r\n\r\n    function encodeUInt(Buffer.buffer memory _buf, uint _value) internal pure {\r\n        encodeType(_buf, MAJOR_TYPE_INT, _value);\r\n    }\r\n\r\n    function encodeInt(Buffer.buffer memory _buf, int _value) internal pure {\r\n        if (_value \u003e= 0) {\r\n            encodeType(_buf, MAJOR_TYPE_INT, uint(_value));\r\n        } else {\r\n            encodeType(_buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - _value));\r\n        }\r\n    }\r\n\r\n    function encodeBytes(Buffer.buffer memory _buf, bytes memory _value) internal pure {\r\n        encodeType(_buf, MAJOR_TYPE_BYTES, _value.length);\r\n        _buf.append(_value);\r\n    }\r\n\r\n    function encodeString(Buffer.buffer memory _buf, string memory _value) internal pure {\r\n        encodeType(_buf, MAJOR_TYPE_STRING, bytes(_value).length);\r\n        _buf.append(bytes(_value));\r\n    }\r\n\r\n    function startArray(Buffer.buffer memory _buf) internal pure {\r\n        encodeIndefiniteLengthType(_buf, MAJOR_TYPE_ARRAY);\r\n    }\r\n\r\n    function startMap(Buffer.buffer memory _buf) internal pure {\r\n        encodeIndefiniteLengthType(_buf, MAJOR_TYPE_MAP);\r\n    }\r\n\r\n    function endSequence(Buffer.buffer memory _buf) internal pure {\r\n        encodeIndefiniteLengthType(_buf, MAJOR_TYPE_CONTENT_FREE);\r\n    }\r\n}\r\n/*\r\n\r\nEnd solidity-cborutils\r\n\r\n*/\r\ncontract usingOraclize {\r\n\r\n    using CBOR for Buffer.buffer;\r\n\r\n    OraclizeI oraclize;\r\n    OraclizeAddrResolverI OAR;\r\n\r\n    uint constant day = 60 * 60 * 24;\r\n    uint constant week = 60 * 60 * 24 * 7;\r\n    uint constant month = 60 * 60 * 24 * 30;\r\n\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_Ledger = 0x30;\r\n    byte constant proofType_Native = 0xF0;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    byte constant proofType_Android = 0x40;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n\r\n    string oraclize_network_name;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    mapping(bytes32 =\u003e bytes32) oraclize_randomDS_args;\r\n    mapping(bytes32 =\u003e bool) oraclize_randomDS_sessionKeysHashVerified;\r\n\r\n    modifier oraclizeAPI {\r\n        if ((address(OAR) == address(0)) || (getCodeSize(address(OAR)) == 0)) {\r\n            oraclize_setNetwork(networkID_auto);\r\n        }\r\n        if (address(oraclize) != OAR.getAddress()) {\r\n            oraclize = OraclizeI(OAR.getAddress());\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string memory _result, bytes memory _proof) {\r\n        // RandomDS Proof Step 1: The prefix has to match \u0027LP\\x01\u0027 (Ledger Proof version 1)\r\n        require((_proof[0] == \"L\") \u0026\u0026 (_proof[1] == \"P\") \u0026\u0026 (uint8(_proof[2]) == uint8(1)));\r\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\r\n        require(proofVerified);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 _networkID) internal returns (bool _networkSet) {\r\n      return oraclize_setNetwork();\r\n      _networkID; // silence the warning and remain backwards compatible\r\n    }\r\n\r\n    function oraclize_setNetworkName(string memory _network_name) internal {\r\n        oraclize_network_name = _network_name;\r\n    }\r\n\r\n    function oraclize_getNetworkName() internal view returns (string memory _networkName) {\r\n        return oraclize_network_name;\r\n    }\r\n\r\n    function oraclize_setNetwork() internal returns (bool _networkSet) {\r\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed) \u003e 0) { //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n            oraclize_setNetworkName(\"eth_mainnet\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1) \u003e 0) { //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n            oraclize_setNetworkName(\"eth_ropsten3\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e) \u003e 0) { //kovan testnet\r\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n            oraclize_setNetworkName(\"eth_kovan\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48) \u003e 0) { //rinkeby testnet\r\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n            oraclize_setNetworkName(\"eth_rinkeby\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xa2998EFD205FB9D4B4963aFb70778D6354ad3A41) \u003e 0) { //goerli testnet\r\n            OAR = OraclizeAddrResolverI(0xa2998EFD205FB9D4B4963aFb70778D6354ad3A41);\r\n            oraclize_setNetworkName(\"eth_goerli\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475) \u003e 0) { //ethereum-bridge\r\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF) \u003e 0) { //ether.camp ide\r\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA) \u003e 0) { //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function __callback(bytes32 _myid, string memory _result) public {\r\n        __callback(_myid, _result, new bytes(0));\r\n    }\r\n\r\n    function __callback(bytes32 _myid, string memory _result, bytes memory _proof) public {\r\n      return;\r\n      _myid; _result; _proof; // Silence compiler warnings\r\n    }\r\n\r\n    function oraclize_getPrice(string memory _datasource) oraclizeAPI internal returns (uint _queryPrice) {\r\n        return oraclize.getPrice(_datasource);\r\n    }\r\n\r\n    function oraclize_getPrice(string memory _datasource, uint _gasLimit) oraclizeAPI internal returns (uint _queryPrice) {\r\n        return oraclize.getPrice(_datasource, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string memory _arg) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return oraclize.query.value(price)(0, _datasource, _arg);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string memory _arg) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return oraclize.query.value(price)(_timestamp, _datasource, _arg);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string memory _arg, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource,_gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return oraclize.query_withGasLimit.value(price)(_timestamp, _datasource, _arg, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string memory _arg, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n           return 0; // Unexpectedly high price\r\n        }\r\n        return oraclize.query_withGasLimit.value(price)(0, _datasource, _arg, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string memory _arg1, string memory _arg2) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return oraclize.query2.value(price)(0, _datasource, _arg1, _arg2);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string memory _arg1, string memory _arg2) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return oraclize.query2.value(price)(_timestamp, _datasource, _arg1, _arg2);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string memory _arg1, string memory _arg2, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return oraclize.query2_withGasLimit.value(price)(_timestamp, _datasource, _arg1, _arg2, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string memory _arg1, string memory _arg2, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return oraclize.query2_withGasLimit.value(price)(0, _datasource, _arg1, _arg2, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[] memory _argN) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(_argN);\r\n        return oraclize.queryN.value(price)(0, _datasource, args);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[] memory _argN) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(_argN);\r\n        return oraclize.queryN.value(price)(_timestamp, _datasource, args);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[] memory _argN, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(_argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(_timestamp, _datasource, args, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[] memory _argN, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(_argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(0, _datasource, args, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[1] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = _args[0];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[1] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = _args[0];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[1] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = _args[0];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[1] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = _args[0];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[2] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[2] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[2] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[2] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[3] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[3] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[3] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[3] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[4] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[4] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[4] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[4] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[5] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[5] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, string[5] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, string[5] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[] memory _argN) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = ba2cbor(_argN);\r\n        return oraclize.queryN.value(price)(0, _datasource, args);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[] memory _argN) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = ba2cbor(_argN);\r\n        return oraclize.queryN.value(price)(_timestamp, _datasource, args);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[] memory _argN, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = ba2cbor(_argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(_timestamp, _datasource, args, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[] memory _argN, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        uint price = oraclize.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = ba2cbor(_argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(0, _datasource, args, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[1] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = _args[0];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[1] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = _args[0];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[1] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = _args[0];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[1] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = _args[0];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[2] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[2] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[2] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[2] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[3] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[3] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[3] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[3] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[4] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[4] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[4] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[4] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[5] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return oraclize_query(_datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[5] memory _args) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return oraclize_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function oraclize_query(uint _timestamp, string memory _datasource, bytes[5] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return oraclize_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_query(string memory _datasource, bytes[5] memory _args, uint _gasLimit) oraclizeAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return oraclize_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function oraclize_setProof(byte _proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(_proofP);\r\n    }\r\n\r\n\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address _callbackAddress) {\r\n        return oraclize.cbAddress();\r\n    }\r\n\r\n    function getCodeSize(address _addr) view internal returns (uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n    function oraclize_setCustomGasPrice(uint _gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(_gasPrice);\r\n    }\r\n\r\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32 _sessionKeyHash) {\r\n        return oraclize.randomDS_getSessionPubKeyHash();\r\n    }\r\n\r\n    function parseAddr(string memory _a) internal pure returns (address _parsedAddress) {\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i = 2; i \u003c 2 + 2 * 20; i += 2) {\r\n            iaddr *= 256;\r\n            b1 = uint160(uint8(tmp[i]));\r\n            b2 = uint160(uint8(tmp[i + 1]));\r\n            if ((b1 \u003e= 97) \u0026\u0026 (b1 \u003c= 102)) {\r\n                b1 -= 87;\r\n            } else if ((b1 \u003e= 65) \u0026\u0026 (b1 \u003c= 70)) {\r\n                b1 -= 55;\r\n            } else if ((b1 \u003e= 48) \u0026\u0026 (b1 \u003c= 57)) {\r\n                b1 -= 48;\r\n            }\r\n            if ((b2 \u003e= 97) \u0026\u0026 (b2 \u003c= 102)) {\r\n                b2 -= 87;\r\n            } else if ((b2 \u003e= 65) \u0026\u0026 (b2 \u003c= 70)) {\r\n                b2 -= 55;\r\n            } else if ((b2 \u003e= 48) \u0026\u0026 (b2 \u003c= 57)) {\r\n                b2 -= 48;\r\n            }\r\n            iaddr += (b1 * 16 + b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n    function strCompare(string memory _a, string memory _b) internal pure returns (int _returnCode) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length \u003c minLength) {\r\n            minLength = b.length;\r\n        }\r\n        for (uint i = 0; i \u003c minLength; i ++) {\r\n            if (a[i] \u003c b[i]) {\r\n                return -1;\r\n            } else if (a[i] \u003e b[i]) {\r\n                return 1;\r\n            }\r\n        }\r\n        if (a.length \u003c b.length) {\r\n            return -1;\r\n        } else if (a.length \u003e b.length) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function indexOf(string memory _haystack, string memory _needle) internal pure returns (int _returnCode) {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if (h.length \u003c 1 || n.length \u003c 1 || (n.length \u003e h.length)) {\r\n            return -1;\r\n        } else if (h.length \u003e (2 ** 128 - 1)) {\r\n            return -1;\r\n        } else {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i \u003c h.length; i++) {\r\n                if (h[i] == n[0]) {\r\n                    subindex = 1;\r\n                    while(subindex \u003c n.length \u0026\u0026 (i + subindex) \u003c h.length \u0026\u0026 h[i + subindex] == n[subindex]) {\r\n                        subindex++;\r\n                    }\r\n                    if (subindex == n.length) {\r\n                        return int(i);\r\n                    }\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory _concatenatedString) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c) internal pure returns (string memory _concatenatedString) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d) internal pure returns (string memory _concatenatedString) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory _concatenatedString) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        uint i = 0;\r\n        for (i = 0; i \u003c _ba.length; i++) {\r\n            babcde[k++] = _ba[i];\r\n        }\r\n        for (i = 0; i \u003c _bb.length; i++) {\r\n            babcde[k++] = _bb[i];\r\n        }\r\n        for (i = 0; i \u003c _bc.length; i++) {\r\n            babcde[k++] = _bc[i];\r\n        }\r\n        for (i = 0; i \u003c _bd.length; i++) {\r\n            babcde[k++] = _bd[i];\r\n        }\r\n        for (i = 0; i \u003c _be.length; i++) {\r\n            babcde[k++] = _be[i];\r\n        }\r\n        return string(babcde);\r\n    }\r\n\r\n    function safeParseInt(string memory _a) internal pure returns (uint _parsedInt) {\r\n        return safeParseInt(_a, 0);\r\n    }\r\n\r\n    function safeParseInt(string memory _a, uint _b) internal pure returns (uint _parsedInt) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i = 0; i \u003c bresult.length; i++) {\r\n            if ((uint(uint8(bresult[i])) \u003e= 48) \u0026\u0026 (uint(uint8(bresult[i])) \u003c= 57)) {\r\n                if (decimals) {\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(uint8(bresult[i])) - 48;\r\n            } else if (uint(uint8(bresult[i])) == 46) {\r\n                require(!decimals, \u0027More than one decimal encountered in string!\u0027);\r\n                decimals = true;\r\n            } else {\r\n                revert(\"Non-numeral character encountered in string!\");\r\n            }\r\n        }\r\n        if (_b \u003e 0) {\r\n            mint *= 10 ** _b;\r\n        }\r\n        return mint;\r\n    }\r\n\r\n    function parseInt(string memory _a) internal pure returns (uint _parsedInt) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    function parseInt(string memory _a, uint _b) internal pure returns (uint _parsedInt) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i = 0; i \u003c bresult.length; i++) {\r\n            if ((uint(uint8(bresult[i])) \u003e= 48) \u0026\u0026 (uint(uint8(bresult[i])) \u003c= 57)) {\r\n                if (decimals) {\r\n                   if (_b == 0) {\r\n                       break;\r\n                   } else {\r\n                       _b--;\r\n                   }\r\n                }\r\n                mint *= 10;\r\n                mint += uint(uint8(bresult[i])) - 48;\r\n            } else if (uint(uint8(bresult[i])) == 46) {\r\n                decimals = true;\r\n            }\r\n        }\r\n        if (_b \u003e 0) {\r\n            mint *= 10 ** _b;\r\n        }\r\n        return mint;\r\n    }\r\n\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function stra2cbor(string[] memory _arr) internal pure returns (bytes memory _cborEncoding) {\r\n        safeMemoryCleaner();\r\n        Buffer.buffer memory buf;\r\n        Buffer.init(buf, 1024);\r\n        buf.startArray();\r\n        for (uint i = 0; i \u003c _arr.length; i++) {\r\n            buf.encodeString(_arr[i]);\r\n        }\r\n        buf.endSequence();\r\n        return buf.buf;\r\n    }\r\n\r\n    function ba2cbor(bytes[] memory _arr) internal pure returns (bytes memory _cborEncoding) {\r\n        safeMemoryCleaner();\r\n        Buffer.buffer memory buf;\r\n        Buffer.init(buf, 1024);\r\n        buf.startArray();\r\n        for (uint i = 0; i \u003c _arr.length; i++) {\r\n            buf.encodeBytes(_arr[i]);\r\n        }\r\n        buf.endSequence();\r\n        return buf.buf;\r\n    }\r\n\r\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32 _queryId) {\r\n        require((_nbytes \u003e 0) \u0026\u0026 (_nbytes \u003c= 32));\r\n        _delay *= 10; // Convert from seconds to ledger timer ticks\r\n        bytes memory nbytes = new bytes(1);\r\n        nbytes[0] = byte(uint8(_nbytes));\r\n        bytes memory unonce = new bytes(32);\r\n        bytes memory sessionKeyHash = new bytes(32);\r\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\r\n        assembly {\r\n            mstore(unonce, 0x20)\r\n            /*\r\n             The following variables can be relaxed.\r\n             Check the relaxed random contract at https://github.com/oraclize/ethereum-examples\r\n             for an idea on how to override and replace commit hash variables.\r\n            */\r\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\r\n            mstore(sessionKeyHash, 0x20)\r\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\r\n        }\r\n        bytes memory delay = new bytes(32);\r\n        assembly {\r\n            mstore(add(delay, 0x20), _delay)\r\n        }\r\n        bytes memory delay_bytes8 = new bytes(8);\r\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\r\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\r\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\r\n        bytes memory delay_bytes8_left = new bytes(8);\r\n        assembly {\r\n            let x := mload(add(delay_bytes8, 0x20))\r\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\r\n        }\r\n        oraclize_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(delay_bytes8_left, args[1], sha256(args[0]), args[2])));\r\n        return queryId;\r\n    }\r\n\r\n    function oraclize_randomDS_setCommitment(bytes32 _queryId, bytes32 _commitment) internal {\r\n        oraclize_randomDS_args[_queryId] = _commitment;\r\n    }\r\n\r\n    function verifySig(bytes32 _tosignh, bytes memory _dersig, bytes memory _pubkey) internal returns (bool _sigVerified) {\r\n        bool sigok;\r\n        address signer;\r\n        bytes32 sigr;\r\n        bytes32 sigs;\r\n        bytes memory sigr_ = new bytes(32);\r\n        uint offset = 4 + (uint(uint8(_dersig[3])) - 0x20);\r\n        sigr_ = copyBytes(_dersig, offset, 32, sigr_, 0);\r\n        bytes memory sigs_ = new bytes(32);\r\n        offset += 32 + 2;\r\n        sigs_ = copyBytes(_dersig, offset + (uint(uint8(_dersig[offset - 1])) - 0x20), 32, sigs_, 0);\r\n        assembly {\r\n            sigr := mload(add(sigr_, 32))\r\n            sigs := mload(add(sigs_, 32))\r\n        }\r\n        (sigok, signer) = safer_ecrecover(_tosignh, 27, sigr, sigs);\r\n        if (address(uint160(uint256(keccak256(_pubkey)))) == signer) {\r\n            return true;\r\n        } else {\r\n            (sigok, signer) = safer_ecrecover(_tosignh, 28, sigr, sigs);\r\n            return (address(uint160(uint256(keccak256(_pubkey)))) == signer);\r\n        }\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes memory _proof, uint _sig2offset) internal returns (bool _proofVerified) {\r\n        bool sigok;\r\n        // Random DS Proof Step 6: Verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\r\n        bytes memory sig2 = new bytes(uint(uint8(_proof[_sig2offset + 1])) + 2);\r\n        copyBytes(_proof, _sig2offset, sig2.length, sig2, 0);\r\n        bytes memory appkey1_pubkey = new bytes(64);\r\n        copyBytes(_proof, 3 + 1, 64, appkey1_pubkey, 0);\r\n        bytes memory tosign2 = new bytes(1 + 65 + 32);\r\n        tosign2[0] = byte(uint8(1)); //role\r\n        copyBytes(_proof, _sig2offset - 65, 65, tosign2, 1);\r\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\r\n        copyBytes(CODEHASH, 0, 32, tosign2, 1 + 65);\r\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\r\n        if (!sigok) {\r\n            return false;\r\n        }\r\n        // Random DS Proof Step 7: Verify the APPKEY1 provenance (must be signed by Ledger)\r\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\r\n        bytes memory tosign3 = new bytes(1 + 65);\r\n        tosign3[0] = 0xFE;\r\n        copyBytes(_proof, 3, 65, tosign3, 1);\r\n        bytes memory sig3 = new bytes(uint(uint8(_proof[3 + 65 + 1])) + 2);\r\n        copyBytes(_proof, 3 + 65, sig3.length, sig3, 0);\r\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\r\n        return sigok;\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string memory _result, bytes memory _proof) internal returns (uint8 _returnCode) {\r\n        // Random DS Proof Step 1: The prefix has to match \u0027LP\\x01\u0027 (Ledger Proof version 1)\r\n        if ((_proof[0] != \"L\") || (_proof[1] != \"P\") || (uint8(_proof[2]) != uint8(1))) {\r\n            return 1;\r\n        }\r\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\r\n        if (!proofVerified) {\r\n            return 2;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function matchBytes32Prefix(bytes32 _content, bytes memory _prefix, uint _nRandomBytes) internal pure returns (bool _matchesPrefix) {\r\n        bool match_ = true;\r\n        require(_prefix.length == _nRandomBytes);\r\n        for (uint256 i = 0; i\u003c _nRandomBytes; i++) {\r\n            if (_content[i] != _prefix[i]) {\r\n                match_ = false;\r\n            }\r\n        }\r\n        return match_;\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__main(bytes memory _proof, bytes32 _queryId, bytes memory _result, string memory _contextName) internal returns (bool _proofVerified) {\r\n        // Random DS Proof Step 2: The unique keyhash has to match with the sha256 of (context name + _queryId)\r\n        uint ledgerProofLength = 3 + 65 + (uint(uint8(_proof[3 + 65 + 1])) + 2) + 32;\r\n        bytes memory keyhash = new bytes(32);\r\n        copyBytes(_proof, ledgerProofLength, 32, keyhash, 0);\r\n        if (!(keccak256(keyhash) == keccak256(abi.encodePacked(sha256(abi.encodePacked(_contextName, _queryId)))))) {\r\n            return false;\r\n        }\r\n        bytes memory sig1 = new bytes(uint(uint8(_proof[ledgerProofLength + (32 + 8 + 1 + 32) + 1])) + 2);\r\n        copyBytes(_proof, ledgerProofLength + (32 + 8 + 1 + 32), sig1.length, sig1, 0);\r\n        // Random DS Proof Step 3: We assume sig1 is valid (it will be verified during step 5) and we verify if \u0027_result\u0027 is the _prefix of sha256(sig1)\r\n        if (!matchBytes32Prefix(sha256(sig1), _result, uint(uint8(_proof[ledgerProofLength + 32 + 8])))) {\r\n            return false;\r\n        }\r\n        // Random DS Proof Step 4: Commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\r\n        // This is to verify that the computed args match with the ones specified in the query.\r\n        bytes memory commitmentSlice1 = new bytes(8 + 1 + 32);\r\n        copyBytes(_proof, ledgerProofLength + 32, 8 + 1 + 32, commitmentSlice1, 0);\r\n        bytes memory sessionPubkey = new bytes(64);\r\n        uint sig2offset = ledgerProofLength + 32 + (8 + 1 + 32) + sig1.length + 65;\r\n        copyBytes(_proof, sig2offset - 64, 64, sessionPubkey, 0);\r\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\r\n        if (oraclize_randomDS_args[_queryId] == keccak256(abi.encodePacked(commitmentSlice1, sessionPubkeyHash))) { //unonce, nbytes and sessionKeyHash match\r\n            delete oraclize_randomDS_args[_queryId];\r\n        } else return false;\r\n        // Random DS Proof Step 5: Validity verification for sig1 (keyhash and args signed with the sessionKey)\r\n        bytes memory tosign1 = new bytes(32 + 8 + 1 + 32);\r\n        copyBytes(_proof, ledgerProofLength, 32 + 8 + 1 + 32, tosign1, 0);\r\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) {\r\n            return false;\r\n        }\r\n        // Verify if sessionPubkeyHash was verified already, if not.. let\u0027s do it!\r\n        if (!oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash]) {\r\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(_proof, sig2offset);\r\n        }\r\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\r\n    }\r\n    /*\r\n     The following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    */\r\n    function copyBytes(bytes memory _from, uint _fromOffset, uint _length, bytes memory _to, uint _toOffset) internal pure returns (bytes memory _copiedBytes) {\r\n        uint minLength = _length + _toOffset;\r\n        require(_to.length \u003e= minLength); // Buffer too small. Should be a better way?\r\n        uint i = 32 + _fromOffset; // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\r\n        uint j = 32 + _toOffset;\r\n        while (i \u003c (32 + _fromOffset + _length)) {\r\n            assembly {\r\n                let tmp := mload(add(_from, i))\r\n                mstore(add(_to, j), tmp)\r\n            }\r\n            i += 32;\r\n            j += 32;\r\n        }\r\n        return _to;\r\n    }\r\n    /*\r\n     The following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n     Duplicate Solidity\u0027s ecrecover, but catching the CALL return value\r\n    */\r\n    function safer_ecrecover(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) internal returns (bool _success, address _recoveredAddress) {\r\n        /*\r\n         We do our own memory management here. Solidity uses memory offset\r\n         0x40 to store the current end of memory. We write past it (as\r\n         writes are memory extensions), but don\u0027t update the offset so\r\n         Solidity will reuse it. The memory used here is only needed for\r\n         this context.\r\n         FIXME: inline assembly can\u0027t access return values\r\n        */\r\n        bool ret;\r\n        address addr;\r\n        assembly {\r\n            let size := mload(0x40)\r\n            mstore(size, _hash)\r\n            mstore(add(size, 32), _v)\r\n            mstore(add(size, 64), _r)\r\n            mstore(add(size, 96), _s)\r\n            ret := call(3000, 1, 0, size, 128, size, 32) // NOTE: we can reuse the request memory because we deal with the return code.\r\n            addr := mload(size)\r\n        }\r\n        return (ret, addr);\r\n    }\r\n    /*\r\n     The following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    */\r\n    function ecrecovery(bytes32 _hash, bytes memory _sig) internal returns (bool _success, address _recoveredAddress) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        if (_sig.length != 65) {\r\n            return (false, address(0));\r\n        }\r\n        /*\r\n         The signature format is a compact form of:\r\n           {bytes32 r}{bytes32 s}{uint8 v}\r\n         Compact means, uint8 is not padded to 32 bytes.\r\n        */\r\n        assembly {\r\n            r := mload(add(_sig, 32))\r\n            s := mload(add(_sig, 64))\r\n            /*\r\n             Here we are loading the last 32 bytes. We exploit the fact that\r\n             \u0027mload\u0027 will pad with zeroes if we overread.\r\n             There is no \u0027mload8\u0027 to do this, but that would be nicer.\r\n            */\r\n            v := byte(0, mload(add(_sig, 96)))\r\n            /*\r\n              Alternative solution:\r\n              \u0027byte\u0027 is not working due to the Solidity parser, so lets\r\n              use the second best option, \u0027and\u0027\r\n              v := and(mload(add(_sig, 65)), 255)\r\n            */\r\n        }\r\n        /*\r\n         albeit non-transactional signatures are not specified by the YP, one would expect it\r\n         to match the YP range of [27, 28]\r\n         geth uses [0, 1] and some clients have followed. This might change, see:\r\n         https://github.com/ethereum/go-ethereum/issues/2053\r\n        */\r\n        if (v \u003c 27) {\r\n            v += 27;\r\n        }\r\n        if (v != 27 \u0026\u0026 v != 28) {\r\n            return (false, address(0));\r\n        }\r\n        return safer_ecrecover(_hash, v, r, s);\r\n    }\r\n\r\n    function safeMemoryCleaner() internal pure {\r\n        assembly {\r\n            let fmem := mload(0x40)\r\n            codecopy(fmem, codesize, sub(msize, fmem))\r\n        }\r\n    }\r\n}\r\n/*\r\n\r\nEND ORACLIZE_API\r\n\r\n*/"}}