{"DeliverFunds.sol":{"content":"pragma solidity 0.5.12;\r\n\r\ncontract DeliverFunds {\r\n    constructor(address payable target) public payable {\r\n        selfdestruct(target);\r\n    }\r\n}"},"EthexJackpot.sol":{"content":"pragma solidity 0.5.12;\r\n\r\n/**\r\n * (E)t)h)e)x) Jackpot Contract \r\n *  This smart-contract is the part of Ethex Lottery fair game.\r\n *  See latest version at https://github.com/ethex-bet/ethex-contracts \r\n *  http://ethex.bet\r\n */\r\n\r\nimport \"./DeliverFunds.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\ncontract EthexJackpot is Ownable {\r\n    mapping(uint256 =\u003e address payable) public tickets;\r\n    mapping(uint256 =\u003e Segment[4]) public prevJackpots;\r\n    uint256[4] public amounts;\r\n    uint256[4] public starts;\r\n    uint256[4] public ends;\r\n    uint256[4] public numberStarts;\r\n    uint256 public numberEnd;\r\n    uint256 public firstNumber;\r\n    uint256 public dailyAmount;\r\n    uint256 public weeklyAmount;\r\n    uint256 public monthlyAmount;\r\n    uint256 public seasonalAmount;\r\n    bool public dailyProcessed;\r\n    bool public weeklyProcessed;\r\n    bool public monthlyProcessed;\r\n    bool public seasonalProcessed;\r\n    address public lotoAddress;\r\n    address payable public newVersionAddress;\r\n    EthexJackpot public previousContract;\r\n    uint256 public dailyNumberStartPrev;\r\n    uint256 public weeklyNumberStartPrev;\r\n    uint256 public monthlyNumberStartPrev;\r\n    uint256 public seasonalNumberStartPrev;\r\n    uint256 public dailyStart;\r\n    uint256 public weeklyStart;\r\n    uint256 public monthlyStart;\r\n    uint256 public seasonalStart;\r\n    uint256 public dailyEnd;\r\n    uint256 public weeklyEnd;\r\n    uint256 public monthlyEnd;\r\n    uint256 public seasonalEnd;\r\n    uint256 public dailyNumberStart;\r\n    uint256 public weeklyNumberStart;\r\n    uint256 public monthlyNumberStart;\r\n    uint256 public seasonalNumberStart;\r\n    uint256 public dailyNumberEndPrev;\r\n    uint256 public weeklyNumberEndPrev;\r\n    uint256 public monthlyNumberEndPrev;\r\n    uint256 public seasonalNumberEndPrev;\r\n    \r\n    struct Segment {\r\n        uint256 start;\r\n        uint256 end;\r\n        bool processed;\r\n    }\r\n    \r\n    event Jackpot (\r\n        uint256 number,\r\n        uint256 count,\r\n        uint256 amount,\r\n        byte jackpotType\r\n    );\r\n    \r\n    event Ticket (\r\n        uint256 number\r\n    );\r\n    \r\n    event Superprize (\r\n        uint256 amount,\r\n        address winner\r\n    );\r\n    \r\n    uint256[4] internal LENGTH = [5000, 35000, 150000, 450000];\r\n    uint256[4] internal PARTS = [84, 12, 3, 1];\r\n    uint256 internal constant PRECISION = 1 ether;\r\n    \r\n    modifier onlyLoto {\r\n        require(msg.sender == lotoAddress, \"Loto only\");\r\n        _;\r\n    }\r\n    \r\n    function() external payable { }\r\n    \r\n    function migrate() external {\r\n        require(msg.sender == owner || msg.sender == newVersionAddress);\r\n        newVersionAddress.transfer(address(this).balance);\r\n    }\r\n\r\n    function registerTicket(address payable gamer) external onlyLoto {\r\n        uint256 number = numberEnd + 1;\r\n        for (uint8 i = 0; i \u003c 4; i++) {\r\n            if (block.number \u003e= ends[i]) {\r\n                setJackpot(i);\r\n                numberStarts[i] = number;\r\n            }\r\n            else\r\n                if (numberStarts[i] == prevJackpots[starts[i]][i].start)\r\n                    numberStarts[i] = number;\r\n        }\r\n        numberEnd = number;\r\n        tickets[number] = gamer;\r\n        emit Ticket(number);\r\n    }\r\n    \r\n    function setLoto(address loto) external onlyOwner {\r\n        lotoAddress = loto;\r\n    }\r\n    \r\n    function setNewVersion(address payable newVersion) external onlyOwner {\r\n        newVersionAddress = newVersion;\r\n    }\r\n    \r\n    function payIn() external payable {\r\n        uint256 distributedAmount = amounts[0] + amounts[1] + amounts[2] + amounts[3];\r\n        if (distributedAmount \u003c address(this).balance) {\r\n            uint256 amount = (address(this).balance - distributedAmount) / 4;\r\n            amounts[0] += amount;\r\n            amounts[1] += amount;\r\n            amounts[2] += amount;\r\n            amounts[3] += amount;\r\n        }\r\n    }\r\n\r\n    function processJackpots(bytes32 hash, uint256[4] memory blockHeights) private {\r\n        uint48 modulo = uint48(bytes6(hash \u003c\u003c 29));\r\n        \r\n        uint256[4] memory payAmounts;\r\n        uint256[4] memory wins;\r\n        for (uint8 i = 0; i \u003c 4; i++) {\r\n            if (prevJackpots[blockHeights[i]][i].processed == false \u0026\u0026 prevJackpots[blockHeights[i]][i].start != 0) {\r\n                payAmounts[i] = amounts[i] * PRECISION / PARTS[i] / PRECISION;\r\n                amounts[i] -= payAmounts[i];\r\n                prevJackpots[blockHeights[i]][i].processed = true;\r\n                wins[i] = getNumber(prevJackpots[blockHeights[i]][i].start, prevJackpots[blockHeights[i]][i].end, modulo);\r\n                emit Jackpot(wins[i], prevJackpots[blockHeights[i]][i].end - prevJackpots[blockHeights[i]][i].start + 1, payAmounts[i], byte(uint8(1) \u003c\u003c i));\r\n            }\r\n        }\r\n        \r\n        for (uint8 i = 0; i \u003c 4; i++)\r\n            if (payAmounts[i] \u003e 0 \u0026\u0026 !getAddress(wins[i]).send(payAmounts[i]))\r\n                (new DeliverFunds).value(payAmounts[i])(getAddress(wins[i]));\r\n    }\r\n    \r\n    function settleJackpot() external {\r\n        for (uint8 i = 0; i \u003c 4; i++)\r\n            if (block.number \u003e= ends[i])\r\n                setJackpot(i);\r\n        \r\n        if (block.number == starts[0] || (starts[0] \u003c block.number - 256))\r\n            return;\r\n        \r\n        processJackpots(blockhash(starts[0]), starts);\r\n    }\r\n\r\n    function settleMissedJackpot(bytes32 hash, uint256 blockHeight) external onlyOwner {\r\n        for (uint8 i = 0; i \u003c 4; i++)\r\n            if (block.number \u003e= ends[i])\r\n                setJackpot(i);\r\n        \r\n        if (blockHeight \u003c block.number - 256)\r\n            processJackpots(hash, [blockHeight, blockHeight, blockHeight, blockHeight]);\r\n    }\r\n    \r\n    function paySuperprize(address payable winner) external onlyLoto {\r\n        uint256 superprizeAmount = amounts[0] + amounts[1] + amounts[2] + amounts[3];\r\n        amounts[0] = 0;\r\n        amounts[1] = 0;\r\n        amounts[2] = 0;\r\n        amounts[3] = 0;\r\n        emit Superprize(superprizeAmount, winner);\r\n        if (superprizeAmount \u003e 0 \u0026\u0026 !winner.send(superprizeAmount))\r\n            (new DeliverFunds).value(superprizeAmount)(winner);\r\n    }\r\n    \r\n    function setOldVersion(address payable oldAddress) external onlyOwner {\r\n        previousContract = EthexJackpot(oldAddress);\r\n        starts[0] = previousContract.dailyStart();\r\n        ends[0] = previousContract.dailyEnd();\r\n        prevJackpots[starts[0]][0].processed = previousContract.dailyProcessed();\r\n        starts[1] = previousContract.weeklyStart();\r\n        ends[1] = previousContract.weeklyEnd();\r\n        prevJackpots[starts[1]][1].processed = previousContract.weeklyProcessed();\r\n        starts[2] = previousContract.monthlyStart();\r\n        ends[2] = previousContract.monthlyEnd();\r\n        prevJackpots[starts[2]][2].processed = previousContract.monthlyProcessed();\r\n        starts[3] = previousContract.seasonalStart();\r\n        ends[3] = previousContract.seasonalEnd();\r\n        prevJackpots[starts[3]][3].processed = previousContract.seasonalProcessed();\r\n        prevJackpots[starts[0]][0].start = previousContract.dailyNumberStartPrev();\r\n        prevJackpots[starts[1]][1].start = previousContract.weeklyNumberStartPrev();\r\n        prevJackpots[starts[2]][2].start = previousContract.monthlyNumberStartPrev();\r\n        prevJackpots[starts[3]][3].start = previousContract.seasonalNumberStartPrev();\r\n        numberStarts[0] = previousContract.dailyNumberStart();\r\n        numberStarts[1] = previousContract.weeklyNumberStart();\r\n        numberStarts[2] = previousContract.monthlyNumberStart();\r\n        numberStarts[3] = previousContract.seasonalNumberStart();\r\n        prevJackpots[starts[0]][0].end = previousContract.dailyNumberEndPrev();\r\n        prevJackpots[starts[1]][1].end = previousContract.weeklyNumberEndPrev();\r\n        prevJackpots[starts[2]][2].end = previousContract.monthlyNumberEndPrev();\r\n        prevJackpots[starts[3]][3].end = previousContract.seasonalNumberEndPrev();\r\n        numberEnd = previousContract.numberEnd();        \r\n        amounts[0] = previousContract.dailyAmount();\r\n        amounts[1] = previousContract.weeklyAmount();\r\n        amounts[2] = previousContract.monthlyAmount();\r\n        amounts[3] = previousContract.seasonalAmount();\r\n        firstNumber = numberEnd;\r\n        previousContract.migrate();\r\n    }\r\n    \r\n    function getAddress(uint256 number) public returns (address payable) {\r\n        if (number \u003c= firstNumber)\r\n            return previousContract.getAddress(number);\r\n        return tickets[number];\r\n    }\r\n    \r\n    function setJackpot(uint8 jackpotType) private {\r\n        prevJackpots[ends[jackpotType]][jackpotType].processed = prevJackpots[starts[jackpotType]][jackpotType].end == numberEnd;\r\n        starts[jackpotType] = ends[jackpotType];\r\n        ends[jackpotType] = starts[jackpotType] + LENGTH[jackpotType];\r\n        prevJackpots[starts[jackpotType]][jackpotType].start = numberStarts[jackpotType];\r\n        prevJackpots[starts[jackpotType]][jackpotType].end = numberEnd;\r\n    }\r\n    \r\n    function getNumber(uint256 startNumber, uint256 endNumber, uint48 modulo) private pure returns (uint256) {\r\n        return startNumber + modulo % (endNumber - startNumber + 1);\r\n    }\r\n}"},"Ownable.sol":{"content":"pragma solidity 0.5.12;\r\n\r\ncontract Ownable {\r\n    address payable public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    \r\n    constructor () internal {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), owner);\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    function transferOwnership(address payable newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}"}}