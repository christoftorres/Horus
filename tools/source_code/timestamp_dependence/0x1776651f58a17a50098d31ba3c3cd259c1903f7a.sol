{"INXMMaster.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract INXMMaster {\r\n\r\n    address public tokenAddress;\r\n\r\n    address public owner;\r\n\r\n\r\n    uint public pauseTime;\r\n\r\n    function delegateCallBack(bytes32 myid) external;\r\n\r\n    function masterInitialized() public view returns(bool);\r\n    \r\n    function isInternal(address _add) public view returns(bool);\r\n\r\n    function isPause() public view returns(bool check);\r\n\r\n    function isOwner(address _add) public view returns(bool);\r\n\r\n    function isMember(address _add) public view returns(bool);\r\n    \r\n    function checkIsAuthToGoverned(address _add) public view returns(bool);\r\n\r\n    function updatePauseTime(uint _time) public;\r\n\r\n    function dAppLocker() public view returns(address _add);\r\n\r\n    function dAppToken() public view returns(address _add);\r\n\r\n    function getLatestAddress(bytes2 _contractName) public view returns(address payable contractAddress);\r\n}"},"Iupgradable.sol":{"content":"pragma solidity 0.5.7;\r\n\r\nimport \"./INXMMaster.sol\";\r\n\r\n\r\ncontract Iupgradable {\r\n\r\n    INXMMaster public ms;\r\n    address public nxMasterAddress;\r\n\r\n    modifier onlyInternal {\r\n        require(ms.isInternal(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier isMemberAndcheckPause {\r\n        require(ms.isPause() == false \u0026\u0026 ms.isMember(msg.sender) == true);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(ms.isOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier checkPause {\r\n        require(ms.isPause() == false);\r\n        _;\r\n    }\r\n\r\n    modifier isMember {\r\n        require(ms.isMember(msg.sender), \"Not member\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Iupgradable Interface to update dependent contract address\r\n     */\r\n    function  changeDependentContractAddress() public;\r\n\r\n    /**\r\n     * @dev change master address\r\n     * @param _masterAddress is the new address\r\n     */\r\n    function changeMasterAddress(address _masterAddress) public {\r\n        if (address(ms) != address(0)) {\r\n            require(address(ms) == msg.sender, \"Not master\");\r\n        }\r\n        ms = INXMMaster(_masterAddress);\r\n        nxMasterAddress = _masterAddress;\r\n    }\r\n\r\n}\r\n"},"QuotationData.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\nimport \"./Iupgradable.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\n\r\ncontract QuotationData is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    enum HCIDStatus { NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover }\r\n\r\n    enum CoverStatus { Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested }\r\n\r\n    struct Cover {\r\n        address payable memberAddress;\r\n        bytes4 currencyCode;\r\n        uint sumAssured;\r\n        uint16 coverPeriod;\r\n        uint validUntil;\r\n        address scAddress;\r\n        uint premiumNXM;\r\n    }\r\n\r\n    struct HoldCover {\r\n        uint holdCoverId;\r\n        address payable userAddress;\r\n        address scAddress;\r\n        bytes4 coverCurr;\r\n        uint[] coverDetails;\r\n        uint16 coverPeriod;\r\n    }\r\n\r\n    address public authQuoteEngine;\r\n  \r\n    mapping(bytes4 =\u003e uint) internal currencyCSA;\r\n    mapping(address =\u003e uint[]) internal userCover;\r\n    mapping(address =\u003e uint[]) public userHoldedCover;\r\n    mapping(address =\u003e bool) public refundEligible;\r\n    mapping(address =\u003e mapping(bytes4 =\u003e uint)) internal currencyCSAOfSCAdd;\r\n    mapping(uint =\u003e uint8) public coverStatus;\r\n    mapping(uint =\u003e uint) public holdedCoverIDStatus;\r\n    mapping(uint =\u003e bool) public timestampRepeated; \r\n    \r\n\r\n    Cover[] internal allCovers;\r\n    HoldCover[] internal allCoverHolded;\r\n\r\n    uint public stlp;\r\n    uint public stl;\r\n    uint public pm;\r\n    uint public minDays;\r\n    uint public tokensRetained;\r\n    address public kycAuthAddress;\r\n\r\n    event CoverDetailsEvent(\r\n        uint indexed cid,\r\n        address scAdd,\r\n        uint sumAssured,\r\n        uint expiry,\r\n        uint premium,\r\n        uint premiumNXM,\r\n        bytes4 curr\r\n    );\r\n\r\n    event CoverStatusEvent(uint indexed cid, uint8 statusNum);\r\n\r\n    constructor(address _authQuoteAdd, address _kycAuthAdd) public {\r\n        authQuoteEngine = _authQuoteAdd;\r\n        kycAuthAddress = _kycAuthAdd;\r\n        stlp = 90;\r\n        stl = 100;\r\n        pm = 30;\r\n        minDays = 30;\r\n        tokensRetained = 10;\r\n        allCovers.push(Cover(address(0), \"0x00\", 0, 0, 0, address(0), 0));\r\n        uint[] memory arr = new uint[](1);\r\n        allCoverHolded.push(HoldCover(0, address(0), address(0), 0x00, arr, 0));\r\n\r\n    }\r\n    \r\n    /// @dev Adds the amount in Total Sum Assured of a given currency of a given smart contract address.\r\n    /// @param _add Smart Contract Address.\r\n    /// @param _amount Amount to be added.\r\n    function addInTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\r\n        currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].add(_amount);\r\n    }\r\n\r\n    /// @dev Subtracts the amount from Total Sum Assured of a given currency and smart contract address.\r\n    /// @param _add Smart Contract Address.\r\n    /// @param _amount Amount to be subtracted.\r\n    function subFromTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\r\n        currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].sub(_amount);\r\n    }\r\n    \r\n    /// @dev Subtracts the amount from Total Sum Assured of a given currency.\r\n    /// @param _curr Currency Name.\r\n    /// @param _amount Amount to be subtracted.\r\n    function subFromTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\r\n        currencyCSA[_curr] = currencyCSA[_curr].sub(_amount);\r\n    }\r\n\r\n    /// @dev Adds the amount in Total Sum Assured of a given currency.\r\n    /// @param _curr Currency Name.\r\n    /// @param _amount Amount to be added.\r\n    function addInTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\r\n        currencyCSA[_curr] = currencyCSA[_curr].add(_amount);\r\n    }\r\n\r\n    /// @dev sets bit for timestamp to avoid replay attacks.\r\n    function setTimestampRepeated(uint _timestamp) external onlyInternal {\r\n        timestampRepeated[_timestamp] = true;\r\n    }\r\n    \r\n    /// @dev Creates a blank new cover.\r\n    function addCover(\r\n        uint16 _coverPeriod,\r\n        uint _sumAssured,\r\n        address payable _userAddress,\r\n        bytes4 _currencyCode,\r\n        address _scAddress,\r\n        uint premium,\r\n        uint premiumNXM\r\n    )   \r\n        external\r\n        onlyInternal\r\n    {\r\n        uint expiryDate = now.add(uint(_coverPeriod).mul(1 days));\r\n        allCovers.push(Cover(_userAddress, _currencyCode,\r\n                _sumAssured, _coverPeriod, expiryDate, _scAddress, premiumNXM));\r\n        uint cid = allCovers.length.sub(1);\r\n        userCover[_userAddress].push(cid);\r\n        emit CoverDetailsEvent(cid, _scAddress, _sumAssured, expiryDate, premium, premiumNXM, _currencyCode);\r\n    }\r\n\r\n    /// @dev create holded cover which will process after verdict of KYC.\r\n    function addHoldCover(\r\n        address payable from,\r\n        address scAddress,\r\n        bytes4 coverCurr, \r\n        uint[] calldata coverDetails,\r\n        uint16 coverPeriod\r\n    )   \r\n        external\r\n        onlyInternal\r\n    {\r\n        uint holdedCoverLen = allCoverHolded.length;\r\n        holdedCoverIDStatus[holdedCoverLen] = uint(HCIDStatus.kycPending);             \r\n        allCoverHolded.push(HoldCover(holdedCoverLen, from, scAddress, \r\n            coverCurr, coverDetails, coverPeriod));\r\n        userHoldedCover[from].push(allCoverHolded.length.sub(1));\r\n    \r\n    }\r\n\r\n    ///@dev sets refund eligible bit.\r\n    ///@param _add user address.\r\n    ///@param status indicates if user have pending kyc.\r\n    function setRefundEligible(address _add, bool status) external onlyInternal {\r\n        refundEligible[_add] = status;\r\n    }\r\n\r\n    /// @dev to set current status of particular holded coverID (1 for not completed KYC,\r\n    /// 2 for KYC passed, 3 for failed KYC or full refunded,\r\n    /// 4 for KYC completed but cover not processed)\r\n    function setHoldedCoverIDStatus(uint holdedCoverID, uint status) external onlyInternal {\r\n        holdedCoverIDStatus[holdedCoverID] = status;\r\n    }\r\n\r\n    /**\r\n     * @dev to set address of kyc authentication \r\n     * @param _add is the new address\r\n     */\r\n    function setKycAuthAddress(address _add) external onlyInternal {\r\n        kycAuthAddress = _add;\r\n    }\r\n\r\n    /// @dev Changes authorised address for generating quote off chain.\r\n    function changeAuthQuoteEngine(address _add) external onlyInternal {\r\n        authQuoteEngine = _add;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Uint Parameters of a code\r\n     * @param code whose details we want\r\n     * @return string value of the code\r\n     * @return associated amount (time or perc or value) to the code\r\n     */\r\n    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint val) {\r\n        codeVal = code;\r\n\r\n        if (code == \"STLP\") {\r\n            val = stlp;\r\n\r\n        } else if (code == \"STL\") {\r\n            \r\n            val = stl;\r\n\r\n        } else if (code == \"PM\") {\r\n\r\n            val = pm;\r\n\r\n        } else if (code == \"QUOMIND\") {\r\n\r\n            val = minDays;\r\n\r\n        } else if (code == \"QUOTOK\") {\r\n\r\n            val = tokensRetained;\r\n\r\n        }\r\n        \r\n    }\r\n\r\n    /// @dev Gets Product details.\r\n    /// @return  _minDays minimum cover period.\r\n    /// @return  _PM Profit margin.\r\n    /// @return  _STL short term Load.\r\n    /// @return  _STLP short term load period.\r\n    function getProductDetails()\r\n        external\r\n        view\r\n        returns (\r\n            uint _minDays,\r\n            uint _pm,\r\n            uint _stl,\r\n            uint _stlp\r\n        )\r\n    {\r\n\r\n        _minDays = minDays;\r\n        _pm = pm;\r\n        _stl = stl;\r\n        _stlp = stlp;\r\n    }\r\n\r\n    /// @dev Gets total number covers created till date.\r\n    function getCoverLength() external view returns(uint len) {\r\n        return (allCovers.length);\r\n    }\r\n\r\n    /// @dev Gets Authorised Engine address.\r\n    function getAuthQuoteEngine() external view returns(address _add) {\r\n        _add = authQuoteEngine;\r\n    }\r\n\r\n    /// @dev Gets the Total Sum Assured amount of a given currency.\r\n    function getTotalSumAssured(bytes4 _curr) external view returns(uint amount) {\r\n        amount = currencyCSA[_curr];\r\n    }\r\n\r\n    /// @dev Gets all the Cover ids generated by a given address.\r\n    /// @param _add User\u0027s address.\r\n    /// @return allCover array of covers.\r\n    function getAllCoversOfUser(address _add) external view returns(uint[] memory allCover) {\r\n        return (userCover[_add]);\r\n    }\r\n\r\n    /// @dev Gets total number of covers generated by a given address\r\n    function getUserCoverLength(address _add) external view returns(uint len) {\r\n        len = userCover[_add].length;\r\n    }\r\n\r\n    /// @dev Gets the status of a given cover.\r\n    function getCoverStatusNo(uint _cid) external view returns(uint8) {\r\n        return coverStatus[_cid];\r\n    }\r\n\r\n    /// @dev Gets the Cover Period (in days) of a given cover.\r\n    function getCoverPeriod(uint _cid) external view returns(uint32 cp) {\r\n        cp = allCovers[_cid].coverPeriod;\r\n    }\r\n\r\n    /// @dev Gets the Sum Assured Amount of a given cover.\r\n    function getCoverSumAssured(uint _cid) external view returns(uint sa) {\r\n        sa = allCovers[_cid].sumAssured;\r\n    }\r\n\r\n    /// @dev Gets the Currency Name in which a given cover is assured.\r\n    function getCurrencyOfCover(uint _cid) external view returns(bytes4 curr) {\r\n        curr = allCovers[_cid].currencyCode;\r\n    }\r\n\r\n    /// @dev Gets the validity date (timestamp) of a given cover.\r\n    function getValidityOfCover(uint _cid) external view returns(uint date) {\r\n        date = allCovers[_cid].validUntil;\r\n    }\r\n\r\n    /// @dev Gets Smart contract address of cover.\r\n    function getscAddressOfCover(uint _cid) external view returns(uint, address) {\r\n        return (_cid, allCovers[_cid].scAddress);\r\n    }\r\n\r\n    /// @dev Gets the owner address of a given cover.\r\n    function getCoverMemberAddress(uint _cid) external view returns(address payable _add) {\r\n        _add = allCovers[_cid].memberAddress;\r\n    }\r\n\r\n    /// @dev Gets the premium amount of a given cover in NXM.\r\n    function getCoverPremiumNXM(uint _cid) external view returns(uint _premiumNXM) {\r\n        _premiumNXM = allCovers[_cid].premiumNXM;\r\n    }\r\n\r\n    /// @dev Provides the details of a cover Id\r\n    /// @param _cid cover Id\r\n    /// @return memberAddress cover user address.\r\n    /// @return scAddress smart contract Address \r\n    /// @return currencyCode currency of cover\r\n    /// @return sumAssured sum assured of cover\r\n    /// @return premiumNXM premium in NXM\r\n    function getCoverDetailsByCoverID1(\r\n        uint _cid\r\n    ) \r\n        external\r\n        view\r\n        returns (\r\n            uint cid,\r\n            address _memberAddress,\r\n            address _scAddress,\r\n            bytes4 _currencyCode,\r\n            uint _sumAssured,  \r\n            uint premiumNXM \r\n        ) \r\n    {\r\n        return (\r\n            _cid,\r\n            allCovers[_cid].memberAddress,\r\n            allCovers[_cid].scAddress,\r\n            allCovers[_cid].currencyCode,\r\n            allCovers[_cid].sumAssured,\r\n            allCovers[_cid].premiumNXM\r\n        );\r\n    }\r\n\r\n    /// @dev Provides details of a cover Id\r\n    /// @param _cid cover Id\r\n    /// @return status status of cover.\r\n    /// @return sumAssured Sum assurance of cover.\r\n    /// @return coverPeriod Cover Period of cover (in days).\r\n    /// @return validUntil is validity of cover.\r\n    function getCoverDetailsByCoverID2(\r\n        uint _cid\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint cid,\r\n            uint8 status,\r\n            uint sumAssured,\r\n            uint16 coverPeriod,\r\n            uint validUntil\r\n        ) \r\n    {\r\n\r\n        return (\r\n            _cid,\r\n            coverStatus[_cid],\r\n            allCovers[_cid].sumAssured,\r\n            allCovers[_cid].coverPeriod,\r\n            allCovers[_cid].validUntil\r\n        );\r\n    }\r\n\r\n    /// @dev Provides details of a holded cover Id\r\n    /// @param _hcid holded cover Id\r\n    /// @return scAddress SmartCover address of cover.\r\n    /// @return coverCurr currency of cover.\r\n    /// @return coverPeriod Cover Period of cover (in days).\r\n    function getHoldedCoverDetailsByID1(\r\n        uint _hcid\r\n    )\r\n        external \r\n        view\r\n        returns (\r\n            uint hcid,\r\n            address scAddress,\r\n            bytes4 coverCurr,\r\n            uint16 coverPeriod\r\n        )\r\n    {\r\n        return (\r\n            _hcid,\r\n            allCoverHolded[_hcid].scAddress,\r\n            allCoverHolded[_hcid].coverCurr, \r\n            allCoverHolded[_hcid].coverPeriod\r\n        );\r\n    }\r\n\r\n    /// @dev Gets total number holded covers created till date.\r\n    function getUserHoldedCoverLength(address _add) external view returns (uint) {\r\n        return userHoldedCover[_add].length;\r\n    }\r\n\r\n    /// @dev Gets holded cover index by index of user holded covers.\r\n    function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint) {\r\n        return userHoldedCover[_add][index];\r\n    }\r\n\r\n    /// @dev Provides the details of a holded cover Id\r\n    /// @param _hcid holded cover Id\r\n    /// @return memberAddress holded cover user address.\r\n    /// @return coverDetails array contains SA, Cover Currency Price,Price in NXM, Expiration time of Qoute.    \r\n    function getHoldedCoverDetailsByID2(\r\n        uint _hcid\r\n    ) \r\n        external\r\n        view\r\n        returns (\r\n            uint hcid,\r\n            address payable memberAddress, \r\n            uint[] memory coverDetails\r\n        )\r\n    {\r\n        return (\r\n            _hcid,\r\n            allCoverHolded[_hcid].userAddress,\r\n            allCoverHolded[_hcid].coverDetails\r\n        );\r\n    }\r\n\r\n    /// @dev Gets the Total Sum Assured amount of a given currency and smart contract address.\r\n    function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns(uint amount) {\r\n        amount = currencyCSAOfSCAdd[_add][_curr];\r\n    }\r\n\r\n    //solhint-disable-next-line\r\n    function changeDependentContractAddress() public {}\r\n\r\n    /// @dev Changes the status of a given cover.\r\n    /// @param _cid cover Id.\r\n    /// @param _stat New status.\r\n    function changeCoverStatusNo(uint _cid, uint8 _stat) public onlyInternal {\r\n        coverStatus[_cid] = _stat;\r\n        emit CoverStatusEvent(_cid, _stat);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates Uint Parameters of a code\r\n     * @param code whose details we want to update\r\n     * @param val value to set\r\n     */\r\n    function updateUintParameters(bytes8 code, uint val) public {\r\n\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        if (code == \"STLP\") {\r\n            _changeSTLP(val);\r\n\r\n        } else if (code == \"STL\") {\r\n            \r\n            _changeSTL(val);\r\n\r\n        } else if (code == \"PM\") {\r\n\r\n            _changePM(val);\r\n\r\n        } else if (code == \"QUOMIND\") {\r\n\r\n            _changeMinDays(val);\r\n\r\n        } else if (code == \"QUOTOK\") {\r\n\r\n            _setTokensRetained(val);\r\n\r\n        } else {\r\n\r\n            revert(\"Invalid param code\");\r\n        }\r\n        \r\n    }\r\n    \r\n    /// @dev Changes the existing Profit Margin value\r\n    function _changePM(uint _pm) internal {\r\n        pm = _pm;\r\n    }\r\n\r\n    /// @dev Changes the existing Short Term Load Period (STLP) value.\r\n    function _changeSTLP(uint _stlp) internal {\r\n        stlp = _stlp;\r\n    }\r\n\r\n    /// @dev Changes the existing Short Term Load (STL) value.\r\n    function _changeSTL(uint _stl) internal {\r\n        stl = _stl;\r\n    }\r\n\r\n    /// @dev Changes the existing Minimum cover period (in days)\r\n    function _changeMinDays(uint _days) internal {\r\n        minDays = _days;\r\n    }\r\n    \r\n    /**\r\n     * @dev to set the the amount of tokens retained \r\n     * @param val is the amount retained\r\n     */\r\n    function _setTokensRetained(uint val) internal {\r\n        tokensRetained = val;\r\n    }\r\n}\r\n"},"SafeMath.sol":{"content":"pragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003e 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003c= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n"}}