{"C3.sol":{"content":"pragma solidity ^0.5.0 \u003c0.6.0;\n\nimport \"./C3StorageInterface.sol\";\nimport \"./ERC20ControllerInterface.sol\";\nimport \"./C3Emitter.sol\";\n\nimport \"./C3Base.sol\";\nimport \"./C3Events.sol\";\nimport \"./Ownable.sol\";\nimport \"./InteropOwnable.sol\";\n\ncontract C3 is C3Base, C3Emitter, C3Events, Ownable {\n  address private _logicBoardAddress;\n  address private _storageAddress;\n\n  string  private _name;\n  string  private _symbol;\n  uint8   private _decimals;\n\n  constructor(\n    string memory pname, string memory psymbol, uint8 pdecimals,\n    address _logicBoard, address _storage\n  ) public {\n    _name = pname;\n    _symbol = psymbol;\n    _decimals = pdecimals;\n\n    _logicBoardAddress = _logicBoard;\n    _storageAddress = _storage;\n    _ownerAddr = msg.sender;\n  }\n\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  function upgradeLogicBoard(address _newLogicBoard) public onlyOwner {\n    require(_newLogicBoard != address(0x0), \"can\u0027t set logic board to a null address\");\n    _logicBoardAddress = _newLogicBoard;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return C3StorageInterface(_storageAddress).totalSupply();\n  }\n\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return C3StorageInterface(_storageAddress).balanceOf(_owner);\n  }\n\n  function transfer(address _to, uint256 _value) public returns (bool success) {\n    return ERC20ControllerInterface(_logicBoardAddress).transfer(msg.sender, _to, _value);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n    return ERC20ControllerInterface(_logicBoardAddress).transferFrom(msg.sender, _from, _to, _value);\n  }\n\n  function approve(address _spender, uint256 _value) public returns (bool success) {\n    return ERC20ControllerInterface(_logicBoardAddress).approve(msg.sender, _spender, _value);\n  }\n\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n    return ERC20ControllerInterface(_logicBoardAddress).allowance(msg.sender, _owner, _spender);\n  }\n\n  function burn(uint256 value) public returns (bool success) {\n    return ERC20ControllerInterface(_logicBoardAddress).burn(msg.sender, value);\n  }\n\n  function burnFrom(address from, uint256 value) public returns (bool success) {\n    return ERC20ControllerInterface(_logicBoardAddress).burnFrom(msg.sender, from, value);\n  }\n\n  modifier internalUsage {\n    require(msg.sender == _storageAddress || msg.sender == _logicBoardAddress);\n    _;\n  }\n\n  function fireTransferEvent(address from, address to, uint256 tokens) public internalUsage {\n    emit Transfer(from, to, tokens);\n  }\n\n  function fireApprovalEvent(address tokenOwner, address spender, uint tokens) public internalUsage {\n    emit Approval(tokenOwner, spender, tokens);\n  }\n\n  function logicBoard() internal view returns (address) {\n    return _logicBoardAddress;\n  }\n}\n"},"C3Base.sol":{"content":"pragma solidity ^0.5.0 \u003c0.6.0;\n\ncontract C3Base {\n  function () external payable {\n    _fallback();\n  }\n\n  function _fallback() internal {\n    _delegateCall(logicBoard());\n  }\n\n  function logicBoard() internal view returns (address);\n\n  function _delegateCall(address _logicBoard) internal {\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      // Load msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize)\n\n      // Call the logicBoard.\n      // out and outsize are 0 because we don\u0027t know the size yet.\n      let result := delegatecall(gas, _logicBoard, 0, calldatasize, 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize)\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 { revert(0, returndatasize) }\n      default { return(0, returndatasize) }\n    }\n  }\n}\n"},"C3Emitter.sol":{"content":"pragma solidity ^0.5.0 \u003c0.6.0;\n\ninterface C3Emitter {\n  function fireTransferEvent(address from, address to, uint256 tokens) external;\n\n  function fireApprovalEvent(address tokenOwner, address spender, uint tokens) external;\n}\n"},"C3Events.sol":{"content":"pragma solidity ^0.5.0 \u003c0.6.0;\n\ncontract C3Events {\n  event Transfer(address indexed from, address indexed to, uint tokens);\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n"},"C3LogicBoard_v0.sol":{"content":"pragma solidity ^0.5.0 \u003c0.6.0;\n\nimport \"./C3Emitter.sol\";\nimport \"./ERC20ControllerInterface.sol\";\n\nimport \"./InteropOwnable.sol\";\nimport \"./C3StorageInterface.sol\";\nimport \"./SafeMath.sol\";\n\n// solium-disable-next-line camelcase\ncontract C3LogicBoard_V0 is ERC20ControllerInterface, InteropOwnable {\n  using SafeMath for uint256;\n\n  C3StorageInterface private _storage;\n\n  C3Emitter private _emitter;\n\n  /**\n   * deprecation flag used to disable old logic boards.\n   * board owner can use setDeprecationFlag to control this.\n   **/\n  bool private deprecated = false;\n\n  constructor(address storageImpl) public {\n    _storage = C3StorageInterface(storageImpl);\n\n    _ownerAddr = msg.sender;\n  }\n\n  function setDeprecationFlag(bool isDeprecated) external onlyOwner {\n    deprecated = isDeprecated;\n  }\n\n  function setStorage(C3StorageInterface _newStorage) external onlyOwner {\n    _storage = _newStorage;\n  }\n\n  function balanceOf(\n    address /*_requestedBy*/,\n    address owner) external view returns (uint256 balance) {\n    require(!deprecated);\n    return _storage.balanceOf(owner);\n  }\n\n  function transfer(\n    address _requestedBy,\n    address _to, uint256 _value) external onlyInteropOwner returns (bool success) {\n    require(!deprecated);\n    return _transfer(_requestedBy, _requestedBy, _to, _value);\n  }\n\n  function transferFrom(\n    address _requestedBy,\n    address _from, address _to, uint256 _value) external onlyInteropOwner returns (bool success) {\n    require(!deprecated);\n\n    return _transfer(_requestedBy, _from, _to, _value);\n  }\n\n  function approve(address _requestedBy, address _spender, uint256 _value)\n    external onlyInteropOwner returns (bool success) {\n    require(!deprecated);\n    require(_storage.balanceOf(_requestedBy) \u003e= _value, \"insufficient funds\");\n\n    // see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM\n    require(\n      _storage.allowance(_requestedBy, _spender) == 0 || _value == 0,\n      \"you should reset your previous allowance value for this spender.\"\n    );\n\n    _emitter.fireApprovalEvent(_requestedBy, _spender, _value);\n    return _storage.approve(_requestedBy, _spender, _value);\n  }\n\n  function allowance(\n    address /*_requestedBy*/,\n    address _owner, address _spender) external onlyInteropOwner view returns (uint256 remaining) {\n    require(!deprecated);\n    require(_spender != address(0x0));\n    return _storage.allowance(_owner, _spender);\n  }\n\n  function totalSupply(address /*requestedBy*/) external view returns (uint256) {\n    require(!deprecated);\n    return _storage.totalSupply();\n  }\n\n  function burn(address requestedBy, uint256 value) external onlyInteropOwner returns (bool success) {\n    require(!deprecated);\n    return _burn(requestedBy, requestedBy, value);\n  }\n\n  function burnFrom(address requestedBy, address from, uint256 value) external onlyInteropOwner returns (bool success) {\n    require(!deprecated);\n    return _burn(requestedBy, from, value);\n  }\n\n  function setEmitterAddress(address emitter) public onlyOwner {\n    require(emitter != address(0x0));\n    _emitter = C3Emitter(emitter);\n  }\n\n  function _burn(address _requestedBy, address _from, uint256 _value) private returns (bool success) {\n    require(!deprecated);\n    if (_requestedBy == _from) {\n    // if transfer requested by owner, check if owner got enough funds\n      require(_storage.balanceOf(_from) \u003e= _value, \"insufficient funds\");\n    } else {\n      // if transfer was not requested by owner, we must check for both:\n      //   1) if owner allowed enough funds to the potential spender (a.k.a. request\u0027s sender)\n      //   2) and if owner actually got enough funds for the spender\n      require(_storage.allowance(_from, _requestedBy) \u003e= _value \u0026\u0026 _storage.balanceOf(_from) \u003e= _value, \"insufficient allowance or funds\");\n    }\n\n    if (_value != 0) {\n      require(_storage.balanceSub(_from, _value));\n      require(_storage.totalSupplySub(_value));\n    }\n    _emitter.fireTransferEvent(_from, address(0x0), _value);\n\n    return true;\n  }\n\n  function _transfer(address _requestedBy, address _from, address _to, uint256 _value) private returns (bool success) {\n    require(!deprecated);\n    //solium-disable operator-whitespace\n    require(\n      // burn operation requires additional checks and operations,\n      // so we\u0027re disabling this via _transfer\n      _to != address(0x0) \u0026\u0026\n      // transfering tokens to logic boards, storage or root token contract\n      // is basically is a burn operation. without reducing totalSupply\n      // that tokens would be wasted.\n      _to != address(this) \u0026\u0026\n      _to != address(_storage) \u0026\u0026\n      _to != address(_emitter),\n      \"use burn()/burnFrom() method instead\"\n    );\n\n    if (_requestedBy == _from) {\n    // if transfer requested by owner, check if owner got enough funds\n      require(_storage.balanceOf(_from) \u003e= _value, \"insufficient funds\");\n    } else {\n      // if transfer was not requested by owner, we must check for both:\n      //   1) if owner allowed enough funds to the potential spender (a.k.a. request\u0027s sender)\n      //   2) and if owner actually got enough funds for the spender\n      require(_storage.allowance(_from, _requestedBy) \u003e= _value \u0026\u0026 _storage.balanceOf(_from) \u003e= _value, \"insufficient allowance or funds\");\n    }\n\n    // transfers with _value = 0 MUST be treated as normal transfers and fire the Transfer event.\n    if (_value != 0) {\n      require(_storage.balanceTransfer(_from, _to, _value));\n    }\n    _emitter.fireTransferEvent(_from, _to, _value);\n\n    return true;\n  }\n}\n"},"C3Storage.sol":{"content":"pragma solidity ^0.5.0 \u003c0.6.0;\n\nimport \"./C3Emitter.sol\";\n\nimport \"./InteropOwnable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./C3Events.sol\";\n\nimport \"./ReentrancyGuard.sol\";\n\ncontract C3Storage is InteropOwnable, C3Events, ReentrancyGuard {\n  using SafeMath for uint256;\n\n  mapping (address =\u003e uint256) private _balances;\n  mapping (address =\u003e mapping (address =\u003e uint256)) private _allowed;\n\n  uint256 private _totalSupply;\n  address private _emitter;\n  bool private storageInitialized;\n\n  constructor(uint256 initialSupply) public {\n    _totalSupply = initialSupply;\n    _ownerAddr = msg.sender;\n  }\n\n  function balanceOf(address owner) external view returns (uint256) {\n    require(storageInitialized);\n    return _balances[owner];\n  }\n\n  function balanceAdd(address _owner, uint256 value) external onlyInteropOwner nonReentrant returns (bool success) {\n    require(storageInitialized);\n    if (_balances[_owner] == 0) {\n      _balances[_owner] = value;\n      return true;\n    }\n    _balances[_owner] = _balances[_owner].add(value);\n    return true;\n  }\n\n  function balanceSub(address _owner, uint256 value) external onlyInteropOwner nonReentrant returns (bool success) {\n    require(storageInitialized);\n    if (_balances[_owner] \u003c value) {\n      return false;\n    }\n\n    _balances[_owner] = _balances[_owner].sub(value);\n    return true;\n  }\n\n  function balanceTransfer(address _from, address _to, uint256 value)\n    external onlyInteropOwner nonReentrant returns (bool success) {\n    require(storageInitialized);\n    if (_balances[_from] \u003c value) {\n      return false;\n    }\n    _balances[_from] = _balances[_from].sub(value);\n    _balances[_to] = _balances[_to].add(value);\n    return true;\n  }\n\n  function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\n    require(storageInitialized);\n    return _allowed[_owner][_spender];\n  }\n\n  function approve(address _owner, address _spender, uint256 value) external onlyInteropOwner returns (bool success) {\n    require(storageInitialized);\n    _allowed[_owner][_spender] = value;\n\n    return true;\n  }\n\n  function totalSupply() external view returns (uint256) {\n    require(storageInitialized);\n    return _totalSupply;\n  }\n\n  function totalSupplyAdd(uint256 value) external onlyInteropOwner returns (bool success) {\n    require(storageInitialized);\n    _totalSupply = _totalSupply.add(value);\n    return true;\n  }\n\n  function totalSupplySub(uint256 value) external onlyInteropOwner returns (bool success) {\n    require(storageInitialized);\n    if (value \u003e _totalSupply) {\n      return false;\n    }\n\n    _totalSupply = _totalSupply.sub(value);\n    return true;\n  }\n\n  function setEmitterAddress(address emitter) external onlyOwner {\n    require(emitter != address(0x0));\n    _emitter = emitter;\n  }\n\n  function initializeTokens() public onlyOwner {\n    require(!storageInitialized \u0026\u0026 _emitter != address(0x0), \"storage was already initialized or emitter was not set\");\n    _balances[_ownerAddr] = _totalSupply;\n    C3Emitter(_emitter).fireTransferEvent(address(0x0), _ownerAddr, _totalSupply);\n    storageInitialized = true;\n  }\n}\n"},"C3StorageInterface.sol":{"content":"pragma solidity ^0.5.0 \u003c0.6.0;\n\ninterface C3StorageInterface {\n  function balanceOf(address _owner) external view returns (uint256 balance);\n  function balanceAdd(address _to, uint256 value) external returns (bool success);\n  function balanceSub(address _to, uint256 value) external returns (bool success);\n  function balanceTransfer(address _from, address _to, uint256 value)\n    external returns (bool success);\n\n  function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n  function approve(address _owner, address _to, uint256 value) external returns (bool success);\n\n  function totalSupply() external view returns (uint256);\n  function totalSupplyAdd(uint256 value) external returns (bool success);\n  function totalSupplySub(uint256 value) external returns (bool success);\n}\n"},"ERC20ControllerInterface.sol":{"content":"pragma solidity ^0.5.0 \u003c0.6.0;\n\ninterface ERC20ControllerInterface {\n  function totalSupply(address _requestedBy) external view returns (uint256);\n  function balanceOf(address _requestedBy, address tokenOwner) external view returns (uint256 balance);\n  function allowance(address _requestedBy, address tokenOwner, address spender)\n    external view returns (uint256 remaining);\n  function transfer(address _requestedBy, address to, uint256 tokens) external returns (bool success);\n  function approve(address _requestedBy, address spender, uint256 tokens) external returns (bool success);\n  function transferFrom(address _requestedBy, address from, address to, uint256 tokens) external returns (bool success);\n\n  function burn(address _requestedBy, uint256 value) external returns (bool success);\n  function burnFrom(address _requestedBy, address from, uint256 value) external returns (bool success);\n}\n"},"ERC20Interface.sol":{"content":"pragma solidity ^0.5.0 \u003c0.6.0;\n\ncontract ERC20Interface {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address tokenOwner) public view returns (uint256 balance);\n  function allowance(address tokenOwner, address spender) public view returns (uint256 remaining);\n  function transfer(address to, uint256 tokens) public returns (bool success);\n  function approve(address spender, uint256 tokens) public returns (bool success);\n  function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\n}\n"},"InteropOwnable.sol":{"content":"pragma solidity ^0.5.0 \u003c0.6.0;\n\nimport \"./Ownable.sol\";\n\ncontract InteropOwnable is Ownable {\n  mapping (address =\u003e bool) internal _interopOwners;\n\n  modifier onlyInteropOwner {\n    require(_interopOwners[msg.sender], \"this method is only for interop owner\");\n    _;\n  }\n\n  function addInteropOwner(address newOwner) public onlyOwner {\n    _interopOwners[newOwner] = true;\n  }\n\n  function removeInteropOwner(address newOwner) public onlyOwner {\n    _interopOwners[newOwner] = false;\n  }\n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.5.0 \u003c0.6.0;\n\ncontract Ownable {\n  address internal _ownerAddr;\n\n  modifier onlyOwner {\n    require(msg.sender == _ownerAddr, \"this method is only for owner\");\n    _;\n  }\n\n  function updateOwner(address newOwner) public onlyOwner {\n    _ownerAddr = newOwner;\n  }\n}\n"},"ReentrancyGuard.sol":{"content":"pragma solidity ^0.5.0 \u003c0.6.0;\n\ncontract ReentrancyGuard {\n  uint256 private _currentCounterState;\n\n  constructor () public {\n    _currentCounterState = 1;\n  }\n\n  modifier nonReentrant() {\n    _currentCounterState++;\n    uint256 originalCounterState = _currentCounterState;\n    _;\n    require(originalCounterState == _currentCounterState);\n  }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0 \u003c0.6.0;\n\nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c \u003e= a, \"overflow protection\");\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b \u003c= a, \"overflow protection\");\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b \u003e 0, \"divide by zero\");\n    uint256 c = a / b;\n\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"overflow protection\");\n\n    return c;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"divide by zero\");\n\n    uint256 c = a % b;\n    return c;\n  }\n}\n"},"Utils.sol":{"content":"pragma solidity ^0.5.0 \u003c0.6.0;\n\ncontract C3Utils {\n  function isContract(address x) internal view returns(bool) {\n    uint256 size;\n    // For now there is no better way to check if there is a contract in an address\n    // than to check the size of the code at that address.\n    // See https://ethereum.stackexchange.com/a/14016/36603\n    // for more details about how this works.\n\n    // solium-disable-next-line security/no-inline-assembly\n    assembly { size := extcodesize(x) }\n    return size \u003e 0;\n  }\n}"}}