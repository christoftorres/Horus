{"LinkedList.sol":{"content":"pragma solidity ^0.5.0;\n\ncontract LinkedList{\n    mapping(address=\u003emapping(bool=\u003eaddress)) dllIndex;\n    mapping(address =\u003e uint) balances;\n    address head;\n    address tail;\n    uint arraySize = 0;\n    \n    constructor(address _owner) public{\n        head=_owner;\n        dllIndex[head][true]=_owner;\n        dllIndex[head][false]=_owner;\n        tail=_owner;\n        dllIndex[tail][true]=_owner;\n        dllIndex[tail][false]=_owner;\n        arraySize++;\n    }\n    \n    function add(address _addr) public\n    {\n        address nullAddress;\n        \n        if (dllIndex[_addr][false]==nullAddress \u0026\u0026 dllIndex[_addr][true]==nullAddress){\n            //false==PREV\n            //true==NEXT\n            dllIndex[_addr][false] = tail;\n            dllIndex[_addr][true] = _addr;\n        \n            // Insert the new node\n            dllIndex[tail][true] = _addr;\n            tail=_addr;\n            arraySize++;\n            getList();\n        }\n        \n    }\n\n    function remove(address _addr) public\n    {\n        if (arraySize\u003e1){\n            address previous = dllIndex[_addr][false];\n            address next = dllIndex[_addr][true];\n            \n        \n            if (_addr == head){\n                head=next;\n                dllIndex[previous][false]=next;\n            } else if(_addr == tail){\n                tail=previous;\n                dllIndex[next][false]=previous;\n            }else{\n                dllIndex[dllIndex[_addr][false]][true] = next;\n                dllIndex[dllIndex[_addr][true]][false] = previous;\n            }\n            //Delete state storage\n            delete dllIndex[_addr][false];\n            delete dllIndex[_addr][true];\n            delete balances[_addr];\n            arraySize--;\n        }\n        \n    }\n    \n    function getList() public view returns(address[] memory){\n        address[] memory addressList = new address[](arraySize);\n        addressList[0]=head;\n        if(arraySize==1){\n            return addressList;\n        }else{\n            buildList(head, addressList, 1);\n            return addressList;\n        }\n    }\n    \n    function buildList(address currentLink, address[] memory currentList, uint currentIndex) public view{\n        if (currentLink != dllIndex[currentLink][true]){\n            currentList[currentIndex]=dllIndex[currentLink][true];\n            currentIndex++;\n            buildList(dllIndex[currentLink][true], currentList, currentIndex);\n        }\n    }\n    \n    function getElement(address itemAddress) public view returns(address previous, address next){\n        previous = dllIndex[itemAddress][false];\n        next = dllIndex[itemAddress][true];\n    }\n}"},"tfy.sol":{"content":"pragma solidity ^0.5.0;\nimport \"./LinkedList.sol\";\n\nlibrary SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n}\n\ncontract ERC223ReceivingContract { \n    function tokenFallback(address _from, uint _value, bytes memory _data) public;\n}\n\n\ncontract tfy{\n    \n    using SafeMath for uint256;\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    \n    function name() public pure returns (string memory _name){\n        _name = \"TradeForYou\";\n    }\n    \n    function symbol() public pure returns (bytes32 _symbol){\n        _symbol = \"TFY\";\n    }\n    \n    function decimals() public pure returns (uint8 _decimals){\n        _decimals = 8;\n    }\n    \n    mapping (address =\u003e bool) public isOwner;\n    uint private _quantidadeOwners = 0;\n    LinkedList private _owners;\n    \n    mapping(address=\u003eaccount) users;\n    \n    struct account{\n        uint balance;\n        uint headDividendos;\n        uint[] dividendos;\n    }\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    constructor() public{\n        _totalSupply= 200000000* 10 ** uint(decimals());\n        users[msg.sender].balance=_totalSupply;\n        isOwner[msg.sender]=true;\n        _quantidadeOwners++;\n        _owners = new LinkedList(msg.sender);\n    }\n    \n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address owner) public view returns (uint256) {\n        return users[owner].balance;\n    }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function transfer(address to, uint256 value) public returns (bool) {\n        bytes memory empty;\n        transfer(to, value, empty);\n        return true;\n    }\n    function transfer(address to, uint256 value, bytes memory data) public returns (bool) {\n        _transfer(msg.sender, to, value, data);\n        return true;\n    }\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        bytes memory empty;\n        _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));\n        _transfer(from, to, value, empty);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n    function _transfer(address from, address to, uint256 value, bytes memory data) internal {\n        uint codeLength;\n        assembly {\n            // Retrieve the size of the code on target address, this needs assembly .\n            codeLength := extcodesize(to)\n        }\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        users[from].balance = users[from].balance.sub(value);\n        users[to].balance = users[to].balance.add(value);\n        emit Transfer(from, to, value);\n        if(codeLength\u003e0) {\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(to);\n            receiver.tokenFallback(msg.sender, value, data);\n        }\n    }\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n    \n    function getOwnersList() public view returns(address[] memory){\n         return _owners.getList();\n    }\n    \n    function addOwner(address _newOwner) public returns(bool){\n        require(isOwner[msg.sender]);\n        isOwner[_newOwner]=true;\n        _quantidadeOwners++;\n        _owners.add(_newOwner);\n        return true;\n    }\n    function removeOwner(address _oldOwner) public returns(bool){\n        require(isOwner[msg.sender]);\n        require(_quantidadeOwners\u003e1);\n        isOwner[_oldOwner]=false;\n        _quantidadeOwners--;\n        _owners.remove(_oldOwner);\n        return true;\n    }\n    \n    function mintTokens(uint _toMint) public{\n        require(isOwner[msg.sender]);\n        users[msg.sender].balance+=_toMint;\n        _totalSupply+=_toMint;\n    }\n    \n}"}}