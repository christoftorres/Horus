{"tsa.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n* @title SafeMath\n* @dev Math operations with safety checks that throw on error\n* */\nlibrary SafeMath {\n/**\n* @dev Multiplies two numbers, throws on overflow.\n*/\n\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n// Gas optimization: this is cheaper than asserting \u0027a\u0027 not being zero, but the // benefit is lost if \u0027b\u0027 is also tested.\n// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\nif (a == 0) {\nreturn 0;\n}\nc = a * b;\nassert(c / a == b);\nreturn c;\n}\n\n/**\n* @dev Integer division of two numbers, truncating the quotient.\n*/\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n// assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n// uint256 c = a / b;\n// assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\nreturn a / b;\n}\n/**\n* @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n*/\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\nassert(b \u003c= a);\nreturn a - b;\n}\n\n\n/**\n* @dev Adds two numbers, throws on overflow.\n*/\nfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\nc = a + b;\nassert(c \u003e= a);\nreturn c;\n}\n}\n\n/**\n* @title ERC20Basic\n* @dev Simpler version of ERC20 interface\n* @dev see https://github.com/ethereum/EIPs/issues/179 */\ncontract ERC20Basic {\nfunction totalSupply() public view returns (uint256);\nfunction balanceOf(address who) public view returns (uint256);\nfunction transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\n/**\n* @title Basic token\n* @dev Basic version of StandardToken, with no allowances. */\n\ncontract BasicToken is ERC20Basic {\nusing SafeMath for uint256;\nmapping(address =\u003e uint256) balances;\nuint256 totalSupply_;\n\n/**\n* @dev total number of tokens in existence\n* */\nfunction totalSupply() public view returns (uint256){\nreturn totalSupply_;\n}\n\n/**\n* @dev transfer token for a specified address\n* @param _to The address to transfer to.\n* @param _value The amount to be transferred.\n*/\nfunction transfer(address _to, uint256 _value) public returns (bool) {\nrequire(_to != address(0));\nrequire(_value \u003c= balances[msg.sender]);\n\nbalances[msg.sender] = balances[msg.sender].sub(_value);\nbalances[_to] = balances[_to].add(_value);\nemit Transfer(msg.sender, _to, _value);\nreturn true; //AUDIT// 返回值符合 EIP20 规范\n}\n\n/**\n* @dev Gets the balance of the specified address.\n* @param _owner The address to query the the balance of.\n* @return An uint256 representing the amount owned by the passed address. */\n\nfunction balanceOf(address _owner) public view returns (uint256) {\nreturn balances[_owner];\n}\n}\n/**\n* @title ERC20 interface\n* @dev see https://github.com/ethereum/EIPs/issues/20 */\n\ncontract ERC20 is ERC20Basic {\nfunction allowance(address owner, address spender)\npublic view returns (uint256);\n\nfunction transferFrom(address from, address to, uint256 value)\npublic returns (bool);\n\nfunction approve(address spender, uint256 value) public returns (bool);\nevent Approval(\naddress indexed owner,\naddress indexed spender,\nuint256 value\n);\n}\n\n\ncontract StandardToken is ERC20, BasicToken {\n\nmapping (address =\u003e mapping (address =\u003e uint256)) internal allowed;\n\n/**\n* @dev Transfer tokens from one address to another\n* @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to\n* @param _value uint256 the amount of tokens to be transferred\n*/\nfunction transferFrom(\naddress _from,\naddress _to,\nuint256 _value\n)\npublic\nreturns (bool)\n{\nrequire(_to != address(0));\nrequire(_value \u003c= balances[_from]);\nrequire(_value \u003c= allowed[_from][msg.sender]);\n\nbalances[_from] = balances[_from].sub(_value);\nbalances[_to] = balances[_to].add(_value);\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\nemit Transfer(_from, _to, _value);\nreturn true; //AUDIT// 返回值符合 EIP20 规范\n}\n/**\n* @dev Approve the passed address to spend the specified amount of tokens on behalf of\nmsg.sender. *\n* Beware that changing an allowance with this method brings the risk that someone may use both the old\n* and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n* race condition is to first reduce the spender\u0027s allowance to 0 and set the desired value afterwards:\n* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds.\n* @param _value The amount of tokens to be spent.\n*/\nfunction approve(address _spender, uint256 _value) public returns (bool) {\nallowed[msg.sender][_spender] = _value;\nemit Approval(msg.sender, _spender, _value);\nreturn true;\n}\n\n/**\n* @dev Function to check the amount of tokens that an owner allowed to a spender.\n* @param _owner address The address which owns the funds.\n* @param _spender address The address which will spend the funds.\n* @return A uint256 specifying the amount of tokens still available for the spender. */\nfunction allowance(\naddress _owner,\naddress _spender\n)\npublic\nview\nreturns (uint256)\n{\nreturn allowed[_owner][_spender];\n}\n\n}\n\n/* 父类:账户管理员 */\ncontract owned {\naddress public owner;\n\nconstructor() public {\nowner = msg.sender;\n}\n\nmodifier onlyOwner {\nrequire(msg.sender == owner);\n_;\n}\n\nfunction transferOwnership(address newOwner) onlyOwner public {\nowner = newOwner;\n}\n}\n\n\ncontract TsaToken is owned, StandardToken {\nstring public name = \"TSA\";\nstring public symbol = \"TSA\";\nuint8 public decimals = 5;\n\n/* 构造函数 */\nconstructor() public {\n//发行量:10 亿(小数位:5)\ntotalSupply_ = 100 * 1000 * 10000 * 100000;\nbalances[msg.sender] = totalSupply_;\n}\n\n}\n"},"tsa1.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n* @title SafeMath\n* @dev Math operations with safety checks that throw on error\n* */\nlibrary SafeMath {\n/**\n* @dev Multiplies two numbers, throws on overflow.\n*/\n\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n// Gas optimization: this is cheaper than asserting \u0027a\u0027 not being zero, but the // benefit is lost if \u0027b\u0027 is also tested.\n// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\nif (a == 0) {\nreturn 0;\n}\nc = a * b;\nassert(c / a == b);\nreturn c;\n}\n\n/**\n* @dev Integer division of two numbers, truncating the quotient.\n*/\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n// assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n// uint256 c = a / b;\n// assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\nreturn a / b;\n}\n/**\n* @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n*/\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\nassert(b \u003c= a);\nreturn a - b;\n}\n\n\n/**\n* @dev Adds two numbers, throws on overflow.\n*/\nfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\nc = a + b;\nassert(c \u003e= a);\nreturn c;\n}\n}\n\n/**\n* @title ERC20Basic\n* @dev Simpler version of ERC20 interface\n* @dev see https://github.com/ethereum/EIPs/issues/179 */\ncontract ERC20Basic {\nfunction totalSupply() public view returns (uint256);\nfunction balanceOf(address who) public view returns (uint256);\nfunction transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\n/**\n* @title Basic token\n* @dev Basic version of StandardToken, with no allowances. */\n\ncontract BasicToken is ERC20Basic {\nusing SafeMath for uint256;\nmapping(address =\u003e uint256) balances;\nuint256 totalSupply_;\n\n/**\n* @dev total number of tokens in existence\n* */\nfunction totalSupply() public view returns (uint256){\nreturn totalSupply_;\n}\n\n/**\n* @dev transfer token for a specified address\n* @param _to The address to transfer to.\n* @param _value The amount to be transferred.\n*/\nfunction transfer(address _to, uint256 _value) public returns (bool) {\nrequire(_to != address(0));\nrequire(_value \u003c= balances[msg.sender]);\n\nbalances[msg.sender] = balances[msg.sender].sub(_value);\nbalances[_to] = balances[_to].add(_value);\nemit Transfer(msg.sender, _to, _value);\nreturn true; //AUDIT// 返回值符合 EIP20 规范\n}\n\n/**\n* @dev Gets the balance of the specified address.\n* @param _owner The address to query the the balance of.\n* @return An uint256 representing the amount owned by the passed address. */\n\nfunction balanceOf(address _owner) public view returns (uint256) {\nreturn balances[_owner];\n}\n}\n/**\n* @title ERC20 interface\n* @dev see https://github.com/ethereum/EIPs/issues/20 */\n\ncontract ERC20 is ERC20Basic {\nfunction allowance(address owner, address spender)\npublic view returns (uint256);\n\nfunction transferFrom(address from, address to, uint256 value)\npublic returns (bool);\n\nfunction approve(address spender, uint256 value) public returns (bool);\nevent Approval(\naddress indexed owner,\naddress indexed spender,\nuint256 value\n);\n}\n\n\ncontract StandardToken is ERC20, BasicToken {\n\nmapping (address =\u003e mapping (address =\u003e uint256)) internal allowed;\n\n/**\n* @dev Transfer tokens from one address to another\n* @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to\n* @param _value uint256 the amount of tokens to be transferred\n*/\nfunction transferFrom(\naddress _from,\naddress _to,\nuint256 _value\n)\npublic\nreturns (bool)\n{\nrequire(_to != address(0));\nrequire(_value \u003c= balances[_from]);\nrequire(_value \u003c= allowed[_from][msg.sender]);\n\nbalances[_from] = balances[_from].sub(_value);\nbalances[_to] = balances[_to].add(_value);\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\nemit Transfer(_from, _to, _value);\nreturn true; //AUDIT// 返回值符合 EIP20 规范\n}\n/**\n* @dev Approve the passed address to spend the specified amount of tokens on behalf of\nmsg.sender. *\n* Beware that changing an allowance with this method brings the risk that someone may use both the old\n* and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n* race condition is to first reduce the spender\u0027s allowance to 0 and set the desired value afterwards:\n* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds.\n* @param _value The amount of tokens to be spent.\n*/\nfunction approve(address _spender, uint256 _value) public returns (bool) {\nallowed[msg.sender][_spender] = _value;\nemit Approval(msg.sender, _spender, _value);\nreturn true;\n}\n\n/**\n* @dev Function to check the amount of tokens that an owner allowed to a spender.\n* @param _owner address The address which owns the funds.\n* @param _spender address The address which will spend the funds.\n* @return A uint256 specifying the amount of tokens still available for the spender. */\nfunction allowance(\naddress _owner,\naddress _spender\n)\npublic\nview\nreturns (uint256)\n{\nreturn allowed[_owner][_spender];\n}\n\n}\n\n/* 父类:账户管理员 */\ncontract owned {\naddress public owner;\n\nconstructor() public {\nowner = msg.sender;\n}\n\nmodifier onlyOwner {\nrequire(msg.sender == owner);\n_;\n}\n\nfunction transferOwnership(address newOwner) onlyOwner public {\nowner = newOwner;\n}\n}\n\n\ncontract TsaToken is owned, StandardToken {\nstring public name = \"TSA\";\nstring public symbol = \"TSA\";\nuint8 public decimals = 5;\n\n/* 构造函数 */\nconstructor() public {\n//发行量:10 亿(小数位:5)\ntotalSupply_ = 100 * 1000 * 10000 * 100000;\nbalances[msg.sender] = totalSupply_;\n}\n\n}\n"}}