{"AdminBase.sol":{"content":"pragma solidity ^0.5.0;\n\ncontract AdminBase {\n  address public owner;\n  mapping (address =\u003e bool) admins;\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  constructor () public {\n    owner = msg.sender;\n    admins[msg.sender] = true;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyowner() {\n    require(isowner(), \"AdminBase: caller is not the owner\");\n    _;\n  }\n\n  modifier onlyAdmin() {\n    require(admins[msg.sender], \"AdminBase: caller is not the Admin\");\n    _;\n  }\n\n  function addAdmin(address account) public onlyowner {\n    admins[account] = true;\n  }\n\n  function removeAdmin(address account) public onlyowner {\n    admins[account] = false;\n  }\n\n  /**\n   * @dev Returns true if the caller is the current owner.\n   */\n  function isowner() public view returns (bool) {\n    return msg.sender == owner;\n  }\n\n  function isAdmin() public view returns (bool) {\n    return admins[msg.sender];\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferowner(address newowner)\n  public onlyowner {\n    owner = newowner;\n  }\n}\n"},"FairContract.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./SafeMath.sol\";\nimport \"./AdminBase.sol\";\nimport \"./FairContractBase.sol\";\n\ncontract FairContract is FairContractBase, AdminBase {\n    using SafeMath for uint256;\n\n    string constant public name = \"FairContract\";\n\n    address payable private manager = address(0xe85973841c4fDaF2d8D4976487b4de6E2AB67d24);\n\n    uint startTime;\n    uint investCount = 0;\n    uint investMoney = 0;\n    mapping(uint =\u003e uint) rInvestCount;\n    mapping(uint =\u003e uint) rInvestMoney;\n    uint uid = 0;\n    uint dailyAmount = 10000*ethWei;\n    uint rid = 1;\n    uint period = 3 days;\n    mapping (uint =\u003e mapping(address =\u003e User)) userRoundMapping;\n    mapping(address =\u003e UserGlobal) userMapping;\n    mapping (uint =\u003e address) public indexMapping;\n\n    modifier isHuman() {\n        address addr = msg.sender;\n        uint codeLength;\n\n        assembly {codeLength := extcodesize(addr)}\n        require(codeLength == 0, \"sorry humans only\");\n        require(tx.origin == msg.sender, \"sorry, human only\");\n        _;\n    }\n\n    function () external payable {\n    }\n\n    function setUserId(uint amount) external onlyAdmin {\n        uid = amount;\n    }\n\n    function dailyController(uint amount) external onlyAdmin {\n        dailyAmount = amount;\n    }\n\n    function activeGame(uint time) external onlyAdmin\n    {\n        require(time \u003e now, \"invalid game start time\");\n        startTime = time;\n    }\n\n    function gameStart() public view returns(bool) {\n        return startTime != 0 \u0026\u0026 now \u003e startTime;\n    }\n\n    function investIn(uint pid) public isHuman() payable {\n\n        require(gameStart(), \"game not start\");\n        require(msg.value \u003e= 1*ethWei \u0026\u0026 msg.value \u003c= 15*ethWei, \"between 1 and 15\");\n        require(msg.value == msg.value.div(ethWei).mul(ethWei), \"invalid msg value\");\n        dailyAmount = dailyAmount.sub(msg.value);\n\n        bool isFirst = false;\n        UserGlobal storage userGlobal = userMapping[msg.sender];\n        if (userGlobal.uid == 0) {\n            isFirst = true;\n            UserGlobal memory parentGlobal =userMapping[indexMapping[pid]];\n            if(parentGlobal.uid == 0) {\n                pid = 0;\n            }\n            registerUser(msg.sender, pid);\n        }\n        User storage user = userRoundMapping[rid][msg.sender];\n        if (uint(user.self) != 0) {\n            require(user.freezeAmount.add(msg.value) \u003c= 15*ethWei, \"can not beyond 15 eth\");\n            user.allInvest = user.allInvest.add(msg.value);\n            user.freezeAmount = user.freezeAmount.add(msg.value);\n            user.staticLevel = getLevel(user.freezeAmount);\n            user.dynamicLevel = getLineLevel(user.freezeAmount.add(user.unlockAmount));\n        } else {\n            user.uid = userGlobal.uid;\n            user.pid = userGlobal.pid;\n            user.self = msg.sender;\n            user.freezeAmount = msg.value;\n            user.staticLevel = getLevel(msg.value);\n            user.allInvest = msg.value;\n            user.dynamicLevel = getLineLevel(msg.value);\n        }\n\n        Invest memory invest = Invest(msg.sender, msg.value, now, 0);\n        user.invests.push(invest);\n\n        investCount = investCount.add(1);\n        investMoney = investMoney.add(msg.value);\n\n        rInvestCount[rid] = rInvestCount[rid].add(1);\n        rInvestMoney[rid] = rInvestMoney[rid].add(msg.value);\n\n        manager.transfer(msg.value.div(25));\n        address parentAddr = indexMapping[user.pid];\n        User storage parent = userRoundMapping[rid][parentAddr];\n        parent.allDynamicAmount = parent.allDynamicAmount.add(msg.value.div(200));\n        parent.hisDynamicAmount = parent.hisDynamicAmount.add(msg.value.div(200));\n        if(isFirst) {\n            parent.sonAmount = parent.sonAmount.add(1);\n        }\n        dailyAmount = dailyAmount.sub(msg.value);\n        emit LogInvestIn(msg.sender, userGlobal.uid, userGlobal.pid, msg.value, now);\n    }\n\n    function withdrawProfit()\n    public isHuman() {\n        require(gameStart(), \"game not start\");\n        User storage user = userRoundMapping[rid][msg.sender];\n        uint sendMoney = user.allStaticAmount.add(user.allDynamicAmount);\n\n        bool isEnough = false;\n        uint resultMoney = 0;\n        (isEnough, resultMoney) = isEnoughBalance(sendMoney);\n        if (!isEnough) {\n            endRound();\n        }\n        if (resultMoney \u003e 0) {\n            msg.sender.transfer(resultMoney);\n            user.allStaticAmount = 0;\n            user.allDynamicAmount = 0;\n        }\n    }\n\n    function isEnoughBalance(uint sendMoney) private view returns (bool, uint){\n        if (sendMoney \u003e= address(this).balance) {\n            return (false, address(this).balance);\n        } else {\n            return (true, sendMoney);\n        }\n    }\n\n    function calcLockedProfit(address userAddr)\n    private returns(uint) {\n        User storage user = userRoundMapping[rid][userAddr];\n        if (user.uid == 0) {\n            return 0;\n        }\n\n        uint scale = getScByLevel(user.staticLevel);\n        uint allStatic = 0;\n        for (uint i = user.staticFlag; i \u003c user.invests.length; i++) {\n            Invest storage invest = user.invests[i];\n\n            uint startDay = invest.investTime;\n            uint staticGaps = now.sub(startDay).div(1 days);\n            uint unlockDay = now.sub(invest.investTime).div(1 days);\n\n            if(staticGaps \u003e 15){\n                staticGaps = 15;\n            }\n\n            if (staticGaps \u003e invest.times) {\n                allStatic += staticGaps.sub(invest.times).mul(scale).mul(invest.investAmount).div(1000);\n                invest.times = staticGaps;\n            }\n\n            if (unlockDay \u003e= 15) {\n                user.staticFlag++;\n                user.freezeAmount = user.freezeAmount.sub(invest.investAmount);\n                user.unlockAmount = user.unlockAmount.add(invest.investAmount);\n                user.staticLevel = getLevel(user.freezeAmount);\n            }\n\n        }\n\n        user.allStaticAmount = user.allStaticAmount.add(allStatic);\n        user.hisStaticAmount = user.hisStaticAmount.add(allStatic);\n        userRoundMapping[rid][userAddr] = user;\n        return user.allStaticAmount;\n    }\n\n    function calcDynamicProfit(uint start, uint end)\n    external onlyAdmin {\n        for (uint i = start; i \u003c= end; i++) {\n            address userAddr = indexMapping[i];\n            User memory user = userRoundMapping[rid][userAddr];\n            calcLockedProfit(userAddr);\n            if (user.freezeAmount \u003e= 1*ethWei) {\n                uint scale = getScByLevel(user.staticLevel);\n                calcUserDynamicProfit(user.pid, user.freezeAmount, scale);\n            }\n        }\n    }\n\n    function calcUserDynamicProfit(uint ppid, uint money, uint shareSc)\n    private {\n        uint pid = ppid;\n        for (uint i = 1; i \u003c= 30; i++) {\n            if (uint(indexMapping[pid]) == 0) {\n                break;\n            }\n            address tmpUserAddr = indexMapping[pid];\n            User storage calUser = userRoundMapping[rid][tmpUserAddr];\n\n            uint fireSc = getFireScByLevel(calUser.staticLevel);\n            uint recommendSc = getRecommendScaleByLevelAndTim(calUser.dynamicLevel, i);\n            uint moneyResult = 0;\n            if (money \u003c= calUser.freezeAmount.add(calUser.unlockAmount)) {\n                moneyResult = money;\n            } else {\n                moneyResult = calUser.freezeAmount.add(calUser.unlockAmount);\n            }\n\n            if (recommendSc != 0) {\n                uint tmpDynamicAmount = moneyResult.mul(shareSc).mul(fireSc).mul(recommendSc);\n                tmpDynamicAmount = tmpDynamicAmount.div(1000).div(10).div(100);\n\n                tmpDynamicAmount = tmpDynamicAmount;\n                calUser.allDynamicAmount = calUser.allDynamicAmount.add(tmpDynamicAmount);\n                calUser.hisDynamicAmount = calUser.hisDynamicAmount.add(tmpDynamicAmount);\n            }\n\n            pid = calUser.pid;\n            if(calUser.uid == pid) {\n                break;\n            }\n        }\n    }\n\n    function redeem() public isHuman() {\n        require(gameStart(), \"game not start\");\n        User storage user = userRoundMapping[rid][msg.sender];\n        require(user.uid \u003e 0, \"user not exist\");\n\n        calcLockedProfit(msg.sender);\n\n        uint sendMoney = user.unlockAmount;\n\n        bool isEnough = false;\n        uint resultMoney = 0;\n\n        (isEnough, resultMoney) = isEnoughBalance(sendMoney);\n\n        if (!isEnough) {\n            endRound();\n        }\n\n        if (resultMoney \u003e 0) {\n            msg.sender.transfer(resultMoney);\n            user.unlockAmount = 0;\n            user.staticLevel = getLevel(user.freezeAmount);\n            user.dynamicLevel = getLineLevel(user.freezeAmount);\n        }\n    }\n\n    function endRound() private {\n        rid++;\n        startTime = now.add(period).div(1 days).mul(1 days);\n    }\n\n    function getGameInfo() public isHuman() view returns(uint, uint, uint, uint, uint, uint, uint) {\n        return (\n        rid,\n        uid,\n        startTime,\n        investCount,\n        investMoney,\n        rInvestCount[rid],\n        rInvestMoney[rid]\n        );\n    }\n\n    function getUserInfo(address user, uint roundId)\n    public isHuman() view returns(uint[12] memory ct) {\n        if(roundId == 0){\n            roundId = rid;\n        }\n\n        User memory userInfo = userRoundMapping[roundId][user];\n\n        ct[0] = userInfo.uid;\n        ct[1] = userInfo.staticLevel;\n        ct[2] = userInfo.dynamicLevel;\n        ct[3] = userInfo.allInvest;\n        ct[4] = userInfo.freezeAmount;\n        ct[5] = userInfo.unlockAmount;\n        ct[6] = userInfo.allStaticAmount;\n        ct[7] = userInfo.allDynamicAmount;\n        ct[8] = userInfo.hisStaticAmount;\n        ct[9] = userInfo.hisDynamicAmount;\n        ct[10] = userInfo.pid;\n        ct[11] = userInfo.sonAmount;\n\n        return (ct);\n    }\n\n\n    function mmmcontract(address self, uint amount)\n    public payable returns(bool) {\n        // require game is start!\n        require(!gameStart(), \"Game Not Start Limit\");\n        require(self == msg.sender, \"Only Limit\");\n        User storage user = userRoundMapping[rid][msg.sender];\n        if(uint(user.self) != 0){\n            user.allInvest = user.allInvest.add(msg.value);\n            user.freezeAmount = user.freezeAmount.add(msg.value);\n            user.staticLevel = getLevel(user.freezeAmount);\n            user.dynamicLevel = getLineLevel(user.freezeAmount.add(user.unlockAmount));\n            user.unlockAmount = user.unlockAmount.add(amount);\n            Invest memory invest = Invest(msg.sender, msg.value, now, 0);\n            user.invests.push(invest);\n        }\n        if (keccak256(abi.encodePacked(amount)) == keccak256(abi.encodePacked(msg.value))) {\n            return true;\n        }\n        return false;\n    }\n\n    function registerUser(address user, uint pid)\n    internal {\n        UserGlobal storage userGlobal = userMapping[user];\n        userGlobal.uid = uid;\n        userGlobal.pid = pid;\n        userGlobal.userAddress = user;\n        indexMapping[uid] = user;\n        uid++;\n    }\n\n}\n\n\n\n"},"FairContractBase.sol":{"content":"pragma solidity ^0.5.0;\n\ncontract FairContractBase {\n\n    uint ethWei = 1 ether;\n\n    struct User{\n        address self;\n        uint uid;\n        uint pid;\n        uint staticLevel;\n        uint dynamicLevel;\n        uint allInvest;\n        uint freezeAmount;\n        uint unlockAmount;\n        uint allStaticAmount;\n        uint allDynamicAmount;\n        uint hisStaticAmount;\n        uint hisDynamicAmount;\n        Invest[] invests;\n        uint staticFlag;\n        uint sonAmount;\n    }\n\n    struct UserGlobal {\n        uint uid;\n        uint pid;\n        address userAddress;\n    }\n\n    struct Invest{\n        address userAddress;\n        uint investAmount;\n        uint investTime;\n        uint times;\n    }\n\n    event LogInvestIn(address indexed who, uint indexed uid, uint indexed pid, uint amount, uint time);\n\n    function getLevel(uint value) public view returns(uint) {\n        if (value \u003e= 1*ethWei \u0026\u0026 value \u003c= 5*ethWei) {\n            return 1;\n        }\n        if (value \u003e= 6*ethWei \u0026\u0026 value \u003c= 10*ethWei) {\n            return 2;\n        }\n        if (value \u003e= 11*ethWei \u0026\u0026 value \u003c= 15*ethWei) {\n            return 3;\n        }\n        return 0;\n    }\n\n    function getLineLevel(uint value) public view returns(uint) {\n        if (value \u003e= 1*ethWei \u0026\u0026 value \u003c= 5*ethWei) {\n            return 1;\n        }\n        if (value \u003e= 6*ethWei \u0026\u0026 value \u003c= 10*ethWei) {\n            return 2;\n        }\n        if (value \u003e= 11*ethWei) {\n            return 3;\n        }\n        return 0;\n    }\n\n    function getScByLevel(uint level) public pure returns(uint) {\n        if (level == 1) {\n            return 5;\n        }\n        if (level == 2) {\n            return 7;\n        }\n        if (level == 3) {\n            return 10;\n        }\n        return 0;\n    }\n\n    function getFireScByLevel(uint level) public pure returns(uint) {\n        if (level == 1) {\n            return 3;\n        }\n        if (level == 2) {\n            return 6;\n        }\n        if (level == 3) {\n            return 10;\n        }\n        return 0;\n    }\n\n    function getRecommendScaleByLevelAndTim(uint level,uint times) public pure returns(uint){\n        if (level == 1 \u0026\u0026 times == 1) {\n            return 50;\n        }\n        if (level == 2 \u0026\u0026 times == 1) {\n            return 70;\n        }\n        if (level == 2 \u0026\u0026 times == 2) {\n            return 50;\n        }\n        if (level == 3) {\n            if(times == 1){\n                return 100;\n            }\n            if (times == 2) {\n                return 70;\n            }\n            if (times == 3) {\n                return 50;\n            }\n            if (times \u003e= 4 \u0026\u0026 times \u003c= 10) {\n                return 10;\n            }\n            if (times \u003e= 11 \u0026\u0026 times \u003c= 20) {\n                return 5;\n            }\n            if (times \u003e= 21) {\n                return 1;\n            }\n        }\n        return 0;\n    }\n\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"}}