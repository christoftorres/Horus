{"HashedTimelockGXC.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./IHashedTimelock.sol\";\nimport \"./Ownable.sol\";\n\npragma solidity ^0.5.0;\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\ncontract HashedTimelockGXC is IHashedTimelock {\n    struct Htlc {\n        address sender;\n        address recipient;\n        address tokenContract;\n        uint amount;\n        bytes32 hashlock;\n        uint timelock;\n        bool withdrawn;\n        bool refunded;\n        bytes32 preimage;\n        bytes32 data;\n    }\n\n    struct Config {\n        address target;\n        uint minAmount;\n        uint minDuration;\n    }\n\n    mapping(bytes32 =\u003e Htlc) internal contracts;\n    mapping(address =\u003e Config) internal configs;\n\n    event LogHtlcNew(\n        bytes32 indexed contractId,\n        address sender,\n        address recipient,\n        address tokenContract,\n        uint amount,\n        bytes32 hashlock,\n        uint timelock,\n        bytes32 indexed data\n    );\n    event LogHtlcWithdraw(bytes32 indexed contractId);\n    event LogHtlcRefund(bytes32 indexed contractId);\n\n    modifier configured(address tokenContract) {\n        require(configs[tokenContract].target != address(0x0), \"not configured\");\n        _;\n    }\n\n    function getConfig(address tokenContract) external view returns (address, uint, uint) {\n        if (configs[tokenContract].target == address(0x0))\n            return (address(0x0), 0, 0);\n        return (configs[tokenContract].target, configs[tokenContract].minAmount, configs[tokenContract].minDuration);\n    }\n\n    function setConfig(address tokenContract, address target, uint minAmount, uint minDuration) external {\n        require(address(msg.sender) == Ownable(tokenContract).owner(), \"msg.sender must be token owner\");\n\n        configs[tokenContract].target = target;\n        configs[tokenContract].minAmount = minAmount;\n        configs[tokenContract].minDuration = minDuration;\n    }\n\n    modifier contractExists(bytes32 contractId) {\n        require(haveContract(contractId), \"contractId does not exist\");\n        _;\n    }\n\n    modifier hashlockMatches(bytes32 contractId, bytes32 preimage) {\n        require(contracts[contractId].hashlock == sha256(abi.encodePacked(preimage)), \"hashlock does not match\");\n        _;\n    }\n\n    modifier withdrawable(bytes32 contractId) {\n        require(contracts[contractId].withdrawn == false, \"withdrawable: already withdrawn\");\n        require(contracts[contractId].timelock \u003e now, \"withdrawable: timelock is expired\");\n        _;\n    }\n\n    modifier refundable(bytes32 contractId) {\n        require(contracts[contractId].refunded == false, \"refundable: already refunded\");\n        require(contracts[contractId].withdrawn == false, \"refundable: already withdrawn\");\n        require(contracts[contractId].timelock \u003c= now, \"refundable: timelock not yet passed\");\n        _;\n    }\n\n    function newContract(\n        address recipient,\n        address tokenContract,\n        uint amount,\n        bytes32 hashlock,\n        uint timelock,\n        bytes32 data\n    )\n        external\n        configured(tokenContract)\n        returns (bytes32 contractId)\n    {\n        Config storage c = configs[tokenContract];\n\n        // workaround fix `Stack too deep`, direct insert instead of separated modifier\n\n        // transferable\n        require(amount \u003e= c.minAmount, \"token amount must be greater than configured minAmount\");\n        require(IERC20(tokenContract).allowance(msg.sender, address(this)) \u003e= amount, \"token allowance must be equal or greater than amount\");\n\n        // hasEnoughDuration\n        uint minDuration = (msg.sender == c.target) ? 0 : c.minDuration;\n        require(timelock \u003e= now + minDuration, \"timelock expiration is too early\");\n\n        // onlyTarget\n        require(recipient == c.target || msg.sender == c.target, \"invalid target\");\n\n        contractId = sha256(abi.encodePacked(msg.sender, recipient, tokenContract, amount, hashlock, timelock, data));\n\n        require(!haveContract(contractId), \"contractId already exists\");\n        require(IERC20(tokenContract).transferFrom(msg.sender, address(this), amount), \"failed to transfer token from msg.sender\");\n\n        contracts[contractId] = Htlc(msg.sender, recipient, tokenContract, amount, hashlock, timelock, false, false, 0x0, data);\n        emit LogHtlcNew(contractId, msg.sender, recipient, tokenContract, amount, hashlock, timelock, data);\n    }\n\n    function withdraw(bytes32 contractId, bytes32 preimage)\n        external\n        contractExists(contractId)\n        hashlockMatches(contractId, preimage)\n        withdrawable(contractId)\n        returns (bool)\n    {\n        Htlc storage c = contracts[contractId];\n        c.preimage = preimage;\n        c.withdrawn = true;\n        IERC20(c.tokenContract).transfer(c.recipient, c.amount);\n        emit LogHtlcWithdraw(contractId);\n        return true;\n    }\n\n    function refund(bytes32 contractId)\n        external\n        contractExists(contractId)\n        refundable(contractId)\n        returns (bool)\n    {\n        Htlc storage c = contracts[contractId];\n        c.refunded = true;\n        IERC20(c.tokenContract).transfer(c.sender, c.amount);\n        emit LogHtlcRefund(contractId);\n        return true;\n    }\n\n    function getContract(bytes32 contractId)\n        public\n        view\n        returns (\n            address sender,\n            address recipient,\n            address tokenContract,\n            uint amount,\n            bytes32 hashlock,\n            uint timelock,\n            bool withdrawn,\n            bool refunded,\n            bytes32 preimage,\n            bytes32 data\n        )\n    {\n        if (haveContract(contractId) == false)\n            return (address(0x0), address(0x0), address(0x0), 0, 0, 0, false, false, 0x0, 0x0);\n        Htlc storage c = contracts[contractId];\n        return (c.sender, c.recipient, c.tokenContract, c.amount, c.hashlock, c.timelock, c.withdrawn, c.refunded, c.preimage, c.data);\n    }\n\n    function haveContract(bytes32 contractId) public view returns (bool exists) {\n        exists = (contracts[contractId].sender != address(0x0));\n    }\n}\n"},"IHashedTimelock.sol":{"content":"pragma solidity ^0.5.2;\n\ninterface IHashedTimelock {\n    function newContract(\n        address recipient,\n        address tokenContract,\n        uint amount,\n        bytes32 hashlock,\n        uint timelock,\n        bytes32 data\n    ) external returns (bytes32);\n\n    function withdraw(bytes32 contractId, bytes32 preimage) external returns (bool);\n\n    function refund(bytes32 contractId) external returns (bool);\n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.5.2;\n\ncontract Ownable {\n  address public owner;\n  address public admin;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender != address(0) \u0026\u0026 (msg.sender == owner || msg.sender == admin));\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    require(newOwner != owner);\n    require(newOwner != admin);\n\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n  function setAdmin(address newAdmin) onlyOwner public {\n    require(admin != newAdmin);\n    require(owner != newAdmin);\n\n    admin = newAdmin;\n  }\n}\n"}}