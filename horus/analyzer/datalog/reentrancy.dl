#include "lib/horus.dl"

/* Reentrancy */
.decl Reentrancy(hash:symbol, timestamp:number, caller:Address, callee:Address, depth:number, amount:Value)
Reentrancy(hash, timestamp, caller, callee, depth1, amount) :-
  call(step1, hash, "CALL", caller, callee, input_data, amount, depth1, 1),
  call(step2, hash, "CALL", caller, callee, input_data, amount, depth2, 1),
  step1 < step2,
  depth1 < depth2,
  !match("0", amount),
  transaction(hash, _, _, _, 1, block),
  block(block, _, _, timestamp).
.output Reentrancy

/* ERC777Reentrancy */
.decl ERC777Reentrancy(hash:symbol, timestamp:number, caller:Address, callee:Address, amount:Value, asset:symbol)
ERC777Reentrancy(hash, timestamp, caller, callee, amount, asset) :-
  call(step1, hash, "CALL", caller, callee, input_data1, _, _, 1),
  substr(input_data1, 0, 8) = "75ab9782",
  call(step2, hash, "CALL", caller, callee, input_data2, _, _, 1),
  substr(input_data2, 0, 8) = "75ab9782",
  step1 < step2,
  call(step3, hash, "CALL", callee, from, _, amount, _, 1),
  !match("0", amount),
  step2 < step3,
  transaction(hash, from, _, _, 1, block),
  block(block, _, _, timestamp),
  asset = "Ether";

  call(step1, hash, "CALL", caller, callee, input_data1, _, _, 1),
  substr(input_data1, 0, 8) = "75ab9782",
  call(step2, hash, "CALL", caller, callee, input_data2, _, _, 1),
  substr(input_data2, 0, 8) = "75ab9782",
  step1 < step2,
  transfer(step3, hash, callee, to, _),
  transfer(step4, hash, to, callee, amount),
  !match("0", amount),
  step3 < step4,
  transaction(hash, _, _, _, 1, block),
  block(block, _, _, timestamp),
  asset = "Token".
.output ERC777Reentrancy

/* Cross-Function Reentrancy */
.decl CrossFunctionReentrancy(hash:symbol, timestamp:number, caller:Address, callee:Address, depth:number, amount:Value)
CrossFunctionReentrancy(hash, timestamp, callee, caller, depth2, amount) :-
  call(step1, hash, "CALL", caller, callee, input_data1, "0", depth1, 1),
  call(step2, hash, "CALL", callee, caller, "", amount, depth2, 1),
  call(step3, hash, "CALL", caller, callee, input_data2, "0", depth3, 1),
  storage(step4, "SSTORE", block, hash, _, contract, index),
  storage(step5, "SSTORE", block, hash, _, contract, index),
  step1 < step2,
  step2 < step3,
  step3 < step4,
  step4 < step5,
  depth1 < depth2,
  depth2 < depth3,
  substr(input_data1, 0, 8) != substr(input_data2, 0, 8),
  !match("0", amount),
  transaction(hash, _, _, _, 1, block),
  block(block, _, _, timestamp).
.output CrossFunctionReentrancy

/* Delegated Reentrancy */
.decl DelegatedReentrancy(hash:symbol, timestamp:number, caller:Address, callee:Address, depth:number, amount:Value)
DelegatedReentrancy(hash, timestamp, caller, callee2, depth4, amount) :-
  call(step1, hash, "DELEGATECALL", caller, callee1, input_data, "0", depth1, 1),
  call(step2, hash, "CALL", callee1, callee2, "", amount, depth2, 1),
  call(step3, hash, "DELEGATECALL", caller, callee1, input_data, "0", depth3, 1),
  call(step4, hash, "CALL", callee1, callee2, "", amount, depth4, 1),
  step1 < step2,
  step2 < step3,
  step3 < step4,
  depth1 < depth2,
  depth2 < depth3,
  depth3 < depth4,
  !match("0", amount),
  transaction(hash, _, _, _, 1, block),
  block(block, _, _, timestamp).
.output DelegatedReentrancy

/* Create-Based Reentrancy */
.decl CreateBasedReentrancy(hash:symbol, timestamp:number, caller:Address, callee:Address, depth:number, amount:Value)
CreateBasedReentrancy(hash, timestamp, caller, callee2, depth3, amount) :-
  call(step1, hash, "CALL", caller, callee1, _, amount, depth1, 1),
  call(step2, hash, "CREATE", callee1, _, input_data, _, depth2, 1),
  call(step3, hash, "CREATE", callee1, callee2, input_data, _, depth3, 1),
  call(step4, hash, "CALL", callee2, caller, _, amount, depth4, 1),
  step1 < step2,
  step2 < step3,
  step3 < step4,
  depth1 < depth2,
  depth2 < depth3,
  depth1 < depth4,
  !match("0", amount),
  transaction(hash, _, _, _, 1, block),
  block(block, _, _, timestamp).
.output CreateBasedReentrancy
